contract main {




// =====================  Runtime code  =====================


#
#  - sub_6e207eb0(?)
#
address owner;
mapping of uint8 stor1;
array of address userList;
uint32 stor3;
address treasuryAddress;
uint256 stor3;
uint256 sub_eba431c1;
uint256 sub_64b958ca;
address setTokenAddress;
uint256 sub_1ab70811;

function sub_1370b5e9(?) {
    return userList.length
}

function sub_1ab70811(?) {
    return sub_1ab70811
}

function sub_588c5e21(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor1[address(arg1)])
}

function treasury() {
    return address(treasuryAddress)
}

function sub_64b958ca(?) {
    return sub_64b958ca
}

function owner() {
    return owner
}

function userList(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < userList.length
    return address(userList[arg1])
}

function sub_eba431c1(?) {
    return sub_eba431c1
}

function setToken() {
    return setTokenAddress
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_035175b7(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_64b958ca = arg1
}

function sub_5a5e1851(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_eba431c1 = arg1
}

function changeTreasury(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(treasuryAddress) = arg1
}

function sub_22395f3d(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(treasuryAddress) = address(arg1)
}

function sub_9532ec4c(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(treasuryAddress) = address(arg1)
}

function sub_e799ffb1(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call address(treasuryAddress) with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function addUser(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor1[address(arg1)]:
        revert with 0, 'Account already listed'
    stor1[address(arg1)] = 1
    userList.length++
    address(userList[userList.length]) = arg1
}

function sub_9f904de8(?) payable {
    if msg.value < sub_64b958ca:
        revert with 0, 'Not paying enough for the Fee'
    if stor1[msg.sender]:
        revert with 0, 'Account: You are already listed'
    stor1[msg.sender] = 1
    userList.length++
    uint256(userList[userList.length]) = msg.sender or Mask(96, 160, uint256(userList[userList.length]))
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function sub_549ada6d(?) {
    if not stor1[msg.sender]:
        revert with 0, 'Account: You are not in the List'
    idx = 0
    while idx < userList.length:
        mem[0] = 2
        if address(userList[idx]) != msg.sender:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if userList.length < 1:
            revert with 0, 17
        if userList.length - 1 >= userList.length:
            revert with 0, 50
        if idx >= userList.length:
            revert with 0, 50
        address(userList[idx]) = address(userList[userList.length])
        stor1[msg.sender] = 0
        if not userList.length:
            revert with 0, 49
        address(userList[userList.length]) = 0
        userList.length--
}

function removeUserFromList(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor1[address(arg1)]:
        revert with 0, 'Account: User is not in the List'
    idx = 0
    while idx < userList.length:
        mem[0] = 2
        if address(userList[idx]) != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if userList.length < 1:
            revert with 0, 17
        if userList.length - 1 >= userList.length:
            revert with 0, 50
        if idx >= userList.length:
            revert with 0, 50
        address(userList[idx]) = address(userList[userList.length])
        stor1[address(arg1)] = 0
        if not userList.length:
            revert with 0, 49
        address(userList[userList.length]) = 0
        userList.length--
}

function sub_780947d8(?) payable {
    mem[64] = 96
    require not msg.value
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < userList.length:
        mem[0] = 2
        mem[mem[64] + 4] = address(userList[idx])
        staticcall setTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(userList[idx])
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_16] >= sub_1ab70811:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if userList.length < 1:
            revert with 0, 17
        if userList.length - 1 >= userList.length:
            revert with 0, 50
        if idx >= userList.length:
            revert with 0, 50
        address(userList[idx]) = address(userList[userList.length])
        stor1[address(stor2[idx])] = 0
        if not userList.length:
            revert with 0, 49
        address(userList[userList.length]) = 0
        userList.length--
}

function addManyUsers(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 > test266151307() or ceil32(32 * arg1.length) + 97 < 96:
        revert with 0, 65
    require (32 * arg1.length) + arg1 + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < (32 * arg1.length) + arg1 + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        if idx >= arg1.length:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 1
        if not stor1[mem[(32 * idx) + 140 len 20]]:
            if idx >= arg1.length:
                revert with 0, 50
            mem[32] = 1
            stor1[mem[(32 * idx) + 140 len 20]] = 1
            if idx >= arg1.length:
                revert with 0, 50
            userList.length++
            mem[0] = 2
            address(userList[userList.length]) = mem[(32 * idx) + 140 len 20]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_ac5cad56(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[100] = this.address
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[ceil32(return_data.size) + 132] = address(treasuryAddress)
    mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 0, stor3)
    mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
    mem[ceil32(return_data.size) + 196] = 32
    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(address(arg1)):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0
    mem[ceil32(return_data.size) + 328] = 0
    call address(arg1) with:
       funct Mask(32, 224, unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
            if not uint32(this.address), mem[132 len 28]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
            if not mem[ceil32(return_data.size) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function sub_bed16063(?) payable {
    require calldata.size - 4 >= 96
    require cd[36] == address(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 97 > test266151307() or ceil32(32 * ('cd', 68).length) + 97 < 96:
        revert with 0, 65
    mem[96] = ('cd', 68).length
    require (32 * ('cd', 68).length) + cd[68] + 36 <= calldata.size
    idx = cd[68] + 36
    s = 128
    while idx < (32 * ('cd', 68).length) + cd[68] + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if msg.value < sub_eba431c1:
        revert with 0, 'Not paying enough for the Fee'
    mem[ceil32(32 * ('cd', 68).length) + 101] = this.address
    staticcall address(cd[36]).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(32 * ('cd', 68).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 133] = msg.sender
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 165] = this.address
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 197] = cd[4]
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 97] = 100
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 129 len 4] = unknown_0x23b872dd(?????)
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 229] = 32
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 261] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(address(cd[36])):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 293 len 128] = 0, msg.sender, address(this.address), cd[4], 0
    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 393] = 0
    call address(cd[36]) with:
       funct Mask(32, 224, 0, msg.sender, address(this.address), cd[4], 0) >> 224
         gas gas_remaining wei
        args (Mask(768, -544, 0, msg.sender, address(this.address), cd[4], 0) << 544)
    if not return_data.size:
        if not ext_call.success:
            if ('cd', 68).length:
                revert with memory
                  from 128
                   len ('cd', 68).length
            revert with 0, 'SafeERC20: low-level call failed'
        if not ('cd', 68).length:
            if 1 > !('cd', 68).length:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 297] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 293
            require return_data.size >= 32
            if ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 17
            if not ('cd', 68).length + 1:
                revert with 0, 18
            idx = 0
            while idx < ('cd', 68).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _3561 = mem[64]
                mem[mem[64] + 36] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                _3584 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_3584 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_3584 + 36 len 28]
                mem[64] = _3561 + 164
                mem[_3561 + 100] = 32
                mem[_3561 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(cd[36])):
                    revert with 0, 'Address: call to non-contract'
                _3677 = mem[_3584]
                s = 0
                while s < _3677:
                    mem[s + _3561 + 164] = mem[s + _3584 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3677) > _3677:
                    mem[_3677 + _3561 + 164] = 0
                call address(cd[36]).mem[_3561 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_3561 + 168 len _3677 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_3561 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3561 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3561 + 232] = mem[idx + _3561 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3561 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[64] = _3561 + ceil32(return_data.size) + 165
                    mem[_3561 + 164] = return_data.size
                    mem[_3561 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3561 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3561 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3561 + ceil32(return_data.size) + 233] = mem[idx + _3561 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3561 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3561 + 196] == bool(mem[_3561 + 196])
                        if not mem[_3561 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3549 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3583 = mem[_3549]
            _3609 = mem[64]
            mem[mem[64] + 36] = address(treasuryAddress)
            mem[mem[64] + 68] = _3583
            _3621 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_3609 + 100] = 32
            mem[_3609 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(cd[36])):
                revert with 0, 'Address: call to non-contract'
            _3729 = mem[_3621]
            mem[_3609 + 164 len ceil32(mem[_3621])] = mem[_3621 + 32 len ceil32(mem[_3621])]
            if ceil32(_3729) > _3729:
                mem[_3729 + _3609 + 164] = 0
            call address(cd[36]) with:
                 gas gas_remaining wei
                args mem[_3609 + 168 len _3729 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_3609 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_3609 + 196] == bool(mem[_3609 + 196])
                    if not mem[_3609 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            require ('cd', 68).length >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if 1 > !('cd', 68).length:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 297] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 293
            require return_data.size >= 32
            if ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 17
            if not ('cd', 68).length + 1:
                revert with 0, 18
            idx = 0
            while idx < ('cd', 68).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _3562 = mem[64]
                mem[mem[64] + 36] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                _3587 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_3587 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_3587 + 36 len 28]
                mem[64] = _3562 + 164
                mem[_3562 + 100] = 32
                mem[_3562 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(cd[36])):
                    revert with 0, 'Address: call to non-contract'
                _3679 = mem[_3587]
                s = 0
                while s < _3679:
                    mem[s + _3562 + 164] = mem[s + _3587 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3679) > _3679:
                    mem[_3679 + _3562 + 164] = 0
                call address(cd[36]).mem[_3562 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_3562 + 168 len _3679 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_3562 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3562 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3562 + 232] = mem[idx + _3562 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3562 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[64] = _3562 + ceil32(return_data.size) + 165
                    mem[_3562 + 164] = return_data.size
                    mem[_3562 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3562 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3562 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3562 + ceil32(return_data.size) + 233] = mem[idx + _3562 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3562 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3562 + 196] == bool(mem[_3562 + 196])
                        if not mem[_3562 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3551 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3586 = mem[_3551]
            _3610 = mem[64]
            mem[mem[64] + 36] = address(treasuryAddress)
            mem[mem[64] + 68] = _3586
            _3623 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_3610 + 100] = 32
            mem[_3610 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(cd[36])):
                revert with 0, 'Address: call to non-contract'
            _3732 = mem[_3623]
            mem[_3610 + 164 len ceil32(mem[_3623])] = mem[_3623 + 32 len ceil32(mem[_3623])]
            if ceil32(_3732) > _3732:
                mem[_3732 + _3610 + 164] = 0
            call address(cd[36]) with:
                 gas gas_remaining wei
                args mem[_3610 + 168 len _3732 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_3610 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_3610 + 196] == bool(mem[_3610 + 196])
                    if not mem[_3610 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 293] = return_data.size
        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if not return_data.size:
            if 1 > !('cd', 68).length:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
            require return_data.size >= 32
            if ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 17
            if not ('cd', 68).length + 1:
                revert with 0, 18
            idx = 0
            while idx < ('cd', 68).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _3563 = mem[64]
                mem[mem[64] + 36] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                _3592 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_3592 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_3592 + 36 len 28]
                mem[64] = _3563 + 164
                mem[_3563 + 100] = 32
                mem[_3563 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(cd[36])):
                    revert with 0, 'Address: call to non-contract'
                _3681 = mem[_3592]
                s = 0
                while s < _3681:
                    mem[s + _3563 + 164] = mem[s + _3592 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3681) > _3681:
                    mem[_3681 + _3563 + 164] = 0
                call address(cd[36]).mem[_3563 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_3563 + 168 len _3681 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_3563 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3563 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3563 + 232] = mem[idx + _3563 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3563 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[64] = _3563 + ceil32(return_data.size) + 165
                    mem[_3563 + 164] = return_data.size
                    mem[_3563 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3563 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3563 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3563 + ceil32(return_data.size) + 233] = mem[idx + _3563 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3563 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3563 + 196] == bool(mem[_3563 + 196])
                        if not mem[_3563 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3553 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3591 = mem[_3553]
            _3611 = mem[64]
            mem[mem[64] + 36] = address(treasuryAddress)
            mem[mem[64] + 68] = _3591
            _3625 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_3611 + 100] = 32
            mem[_3611 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(cd[36])):
                revert with 0, 'Address: call to non-contract'
            _3735 = mem[_3625]
            mem[_3611 + 164 len ceil32(mem[_3625])] = mem[_3625 + 32 len ceil32(mem[_3625])]
            if ceil32(_3735) > _3735:
                mem[_3735 + _3611 + 164] = 0
            call address(cd[36]) with:
                 gas gas_remaining wei
                args mem[_3611 + 168 len _3735 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_3611 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_3611 + 196] == bool(mem[_3611 + 196])
                    if not mem[_3611 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            require return_data.size >= 32
            require mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325] == bool(mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325])
            if not mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if 1 > !('cd', 68).length:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
            require return_data.size >= 32
            if ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 17
            if not ('cd', 68).length + 1:
                revert with 0, 18
            idx = 0
            while idx < ('cd', 68).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _3564 = mem[64]
                mem[mem[64] + 36] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                _3595 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_3595 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_3595 + 36 len 28]
                mem[64] = _3564 + 164
                mem[_3564 + 100] = 32
                mem[_3564 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(cd[36])):
                    revert with 0, 'Address: call to non-contract'
                _3683 = mem[_3595]
                s = 0
                while s < _3683:
                    mem[s + _3564 + 164] = mem[s + _3595 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3683) > _3683:
                    mem[_3683 + _3564 + 164] = 0
                call address(cd[36]).mem[_3564 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_3564 + 168 len _3683 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_3564 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3564 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3564 + 232] = mem[idx + _3564 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3564 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[64] = _3564 + ceil32(return_data.size) + 165
                    mem[_3564 + 164] = return_data.size
                    mem[_3564 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3564 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3564 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3564 + ceil32(return_data.size) + 233] = mem[idx + _3564 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3564 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3564 + 196] == bool(mem[_3564 + 196])
                        if not mem[_3564 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            staticcall address(cd[36]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3555 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3594 = mem[_3555]
            _3612 = mem[64]
            mem[mem[64] + 36] = address(treasuryAddress)
            mem[mem[64] + 68] = _3594
            _3627 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_3612 + 100] = 32
            mem[_3612 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(cd[36])):
                revert with 0, 'Address: call to non-contract'
            _3738 = mem[_3627]
            mem[_3612 + 164 len ceil32(mem[_3627])] = mem[_3627 + 32 len ceil32(mem[_3627])]
            if ceil32(_3738) > _3738:
                mem[_3738 + _3612 + 164] = 0
            call address(cd[36]) with:
                 gas gas_remaining wei
                args mem[_3612 + 168 len _3738 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_3612 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_3612 + 196] == bool(mem[_3612 + 196])
                    if not mem[_3612 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function sub_45a18b3c(?) {
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[100] = this.address
    staticcall address(arg2).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[ceil32(return_data.size) + 132] = msg.sender
    mem[ceil32(return_data.size) + 164] = this.address
    mem[ceil32(return_data.size) + 196] = arg1
    mem[ceil32(return_data.size) + 96] = 100
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
    mem[ceil32(return_data.size) + 128 len 4] = unknown_0x23b872dd(?????)
    mem[ceil32(return_data.size) + 228] = 32
    mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(address(arg2)):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0
    mem[ceil32(return_data.size) + 392] = 0
    call address(arg2) with:
       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0) >> 224
         gas gas_remaining wei
        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0) << 544)
    if arg3 <= userList.length:
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if not ext_call.return_data[0]:
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4639 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4670 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4670 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4670 + 36 len 28]
                    mem[64] = _4639 + 164
                    mem[_4639 + 100] = 32
                    mem[_4639 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4867 = mem[_4670]
                    s = 0
                    while s < _4867:
                        mem[s + _4639 + 164] = mem[s + _4670 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4867) > _4867:
                        mem[_4867 + _4639 + 164] = 0
                    call address(arg2).mem[_4639 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4639 + 168 len _4867 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4639 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4639 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4639 + 232] = mem[idx + _4639 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4639 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4639 + ceil32(return_data.size) + 165
                        mem[_4639 + 164] = return_data.size
                        mem[_4639 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4639 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4639 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4639 + ceil32(return_data.size) + 233] = mem[idx + _4639 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4639 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4639 + 196] == bool(mem[_4639 + 196])
                            if not mem[_4639 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4611 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4669 = mem[_4611]
                _4735 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4669
                _4755 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4735 + 100] = 32
                mem[_4735 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4967 = mem[_4755]
                mem[_4735 + 164 len ceil32(mem[_4755])] = mem[_4755 + 32 len ceil32(mem[_4755])]
                if ceil32(_4967) > _4967:
                    mem[_4967 + _4735 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4735 + 168 len _4967 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4735 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4735 + 196] == bool(mem[_4735 + 196])
                        if not mem[_4735 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_call.return_data[0] >= 32
                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                if not uint32(this.address), mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4640 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4673 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4673 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4673 + 36 len 28]
                    mem[64] = _4640 + 164
                    mem[_4640 + 100] = 32
                    mem[_4640 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4869 = mem[_4673]
                    s = 0
                    while s < _4869:
                        mem[s + _4640 + 164] = mem[s + _4673 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4869) > _4869:
                        mem[_4869 + _4640 + 164] = 0
                    call address(arg2).mem[_4640 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4640 + 168 len _4869 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4640 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4640 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4640 + 232] = mem[idx + _4640 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4640 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4640 + ceil32(return_data.size) + 165
                        mem[_4640 + 164] = return_data.size
                        mem[_4640 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4640 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4640 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4640 + ceil32(return_data.size) + 233] = mem[idx + _4640 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4640 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4640 + 196] == bool(mem[_4640 + 196])
                            if not mem[_4640 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4613 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4672 = mem[_4613]
                _4736 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4672
                _4757 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4736 + 100] = 32
                mem[_4736 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4970 = mem[_4757]
                mem[_4736 + 164 len ceil32(mem[_4757])] = mem[_4757 + 32 len ceil32(mem[_4757])]
                if ceil32(_4970) > _4970:
                    mem[_4970 + _4736 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4736 + 168 len _4970 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4736 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4736 + 196] == bool(mem[_4736 + 196])
                        if not mem[_4736 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292] = return_data.size
            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4641 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4678 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4678 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4678 + 36 len 28]
                    mem[64] = _4641 + 164
                    mem[_4641 + 100] = 32
                    mem[_4641 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4871 = mem[_4678]
                    s = 0
                    while s < _4871:
                        mem[s + _4641 + 164] = mem[s + _4678 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4871) > _4871:
                        mem[_4871 + _4641 + 164] = 0
                    call address(arg2).mem[_4641 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4641 + 168 len _4871 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4641 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4641 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4641 + 232] = mem[idx + _4641 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4641 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4641 + ceil32(return_data.size) + 165
                        mem[_4641 + 164] = return_data.size
                        mem[_4641 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4641 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4641 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4641 + ceil32(return_data.size) + 233] = mem[idx + _4641 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4641 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4641 + 196] == bool(mem[_4641 + 196])
                            if not mem[_4641 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4615 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4677 = mem[_4615]
                _4737 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4677
                _4759 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4737 + 100] = 32
                mem[_4737 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4973 = mem[_4759]
                mem[_4737 + 164 len ceil32(mem[_4759])] = mem[_4759 + 32 len ceil32(mem[_4759])]
                if ceil32(_4973) > _4973:
                    mem[_4973 + _4737 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4737 + 168 len _4973 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4737 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4737 + 196] == bool(mem[_4737 + 196])
                        if not mem[_4737 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                if not mem[ceil32(return_data.size) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4642 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4681 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4681 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4681 + 36 len 28]
                    mem[64] = _4642 + 164
                    mem[_4642 + 100] = 32
                    mem[_4642 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4873 = mem[_4681]
                    s = 0
                    while s < _4873:
                        mem[s + _4642 + 164] = mem[s + _4681 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4873) > _4873:
                        mem[_4873 + _4642 + 164] = 0
                    call address(arg2).mem[_4642 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4642 + 168 len _4873 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4642 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4642 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4642 + 232] = mem[idx + _4642 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4642 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4642 + ceil32(return_data.size) + 165
                        mem[_4642 + 164] = return_data.size
                        mem[_4642 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4642 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4642 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4642 + ceil32(return_data.size) + 233] = mem[idx + _4642 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4642 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4642 + 196] == bool(mem[_4642 + 196])
                            if not mem[_4642 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4617 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4680 = mem[_4617]
                _4738 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4680
                _4761 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4738 + 100] = 32
                mem[_4738 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4976 = mem[_4761]
                mem[_4738 + 164 len ceil32(mem[_4761])] = mem[_4761 + 32 len ceil32(mem[_4761])]
                if ceil32(_4976) > _4976:
                    mem[_4976 + _4738 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4738 + 168 len _4976 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4738 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4738 + 196] == bool(mem[_4738 + 196])
                        if not mem[_4738 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if not ext_call.return_data[0]:
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4647 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4702 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4702 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4702 + 36 len 28]
                    mem[64] = _4647 + 164
                    mem[_4647 + 100] = 32
                    mem[_4647 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4883 = mem[_4702]
                    s = 0
                    while s < _4883:
                        mem[s + _4647 + 164] = mem[s + _4702 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4883) > _4883:
                        mem[_4883 + _4647 + 164] = 0
                    call address(arg2).mem[_4647 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4647 + 168 len _4883 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4647 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4647 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4647 + 232] = mem[idx + _4647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4647 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4647 + ceil32(return_data.size) + 165
                        mem[_4647 + 164] = return_data.size
                        mem[_4647 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4647 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4647 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4647 + ceil32(return_data.size) + 233] = mem[idx + _4647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4647 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4647 + 196] == bool(mem[_4647 + 196])
                            if not mem[_4647 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4627 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4701 = mem[_4627]
                _4743 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4701
                _4771 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4743 + 100] = 32
                mem[_4743 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4991 = mem[_4771]
                mem[_4743 + 164 len ceil32(mem[_4771])] = mem[_4771 + 32 len ceil32(mem[_4771])]
                if ceil32(_4991) > _4991:
                    mem[_4991 + _4743 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4743 + 168 len _4991 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4743 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4743 + 196] == bool(mem[_4743 + 196])
                        if not mem[_4743 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_call.return_data[0] >= 32
                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                if not uint32(this.address), mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4648 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4705 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4705 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4705 + 36 len 28]
                    mem[64] = _4648 + 164
                    mem[_4648 + 100] = 32
                    mem[_4648 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4885 = mem[_4705]
                    s = 0
                    while s < _4885:
                        mem[s + _4648 + 164] = mem[s + _4705 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4885) > _4885:
                        mem[_4885 + _4648 + 164] = 0
                    call address(arg2).mem[_4648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4648 + 168 len _4885 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4648 + 232] = mem[idx + _4648 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4648 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4648 + ceil32(return_data.size) + 165
                        mem[_4648 + 164] = return_data.size
                        mem[_4648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4648 + ceil32(return_data.size) + 233] = mem[idx + _4648 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4648 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4648 + 196] == bool(mem[_4648 + 196])
                            if not mem[_4648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4629 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4704 = mem[_4629]
                _4744 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4704
                _4773 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4744 + 100] = 32
                mem[_4744 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4994 = mem[_4773]
                mem[_4744 + 164 len ceil32(mem[_4773])] = mem[_4773 + 32 len ceil32(mem[_4773])]
                if ceil32(_4994) > _4994:
                    mem[_4994 + _4744 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4744 + 168 len _4994 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4744 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4744 + 196] == bool(mem[_4744 + 196])
                        if not mem[_4744 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292] = return_data.size
            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4649 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4710 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4710 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4710 + 36 len 28]
                    mem[64] = _4649 + 164
                    mem[_4649 + 100] = 32
                    mem[_4649 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4887 = mem[_4710]
                    s = 0
                    while s < _4887:
                        mem[s + _4649 + 164] = mem[s + _4710 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4887) > _4887:
                        mem[_4887 + _4649 + 164] = 0
                    call address(arg2).mem[_4649 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4649 + 168 len _4887 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4649 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4649 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4649 + 232] = mem[idx + _4649 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4649 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4649 + ceil32(return_data.size) + 165
                        mem[_4649 + 164] = return_data.size
                        mem[_4649 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4649 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4649 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4649 + ceil32(return_data.size) + 233] = mem[idx + _4649 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4649 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4649 + 196] == bool(mem[_4649 + 196])
                            if not mem[_4649 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4631 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4709 = mem[_4631]
                _4745 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4709
                _4775 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4745 + 100] = 32
                mem[_4745 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4997 = mem[_4775]
                mem[_4745 + 164 len ceil32(mem[_4775])] = mem[_4775 + 32 len ceil32(mem[_4775])]
                if ceil32(_4997) > _4997:
                    mem[_4997 + _4745 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4745 + 168 len _4997 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4745 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4745 + 196] == bool(mem[_4745 + 196])
                        if not mem[_4745 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                if not mem[ceil32(return_data.size) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4650 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4713 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4713 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4713 + 36 len 28]
                    mem[64] = _4650 + 164
                    mem[_4650 + 100] = 32
                    mem[_4650 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4889 = mem[_4713]
                    s = 0
                    while s < _4889:
                        mem[s + _4650 + 164] = mem[s + _4713 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4889) > _4889:
                        mem[_4889 + _4650 + 164] = 0
                    call address(arg2).mem[_4650 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4650 + 168 len _4889 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4650 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4650 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4650 + 232] = mem[idx + _4650 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4650 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4650 + ceil32(return_data.size) + 165
                        mem[_4650 + 164] = return_data.size
                        mem[_4650 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4650 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4650 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4650 + ceil32(return_data.size) + 233] = mem[idx + _4650 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4650 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4650 + 196] == bool(mem[_4650 + 196])
                            if not mem[_4650 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4633 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4712 = mem[_4633]
                _4746 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4712
                _4777 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4746 + 100] = 32
                mem[_4746 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _5000 = mem[_4777]
                mem[_4746 + 164 len ceil32(mem[_4777])] = mem[_4777 + 32 len ceil32(mem[_4777])]
                if ceil32(_5000) > _5000:
                    mem[_5000 + _4746 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4746 + 168 len _5000 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4746 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4746 + 196] == bool(mem[_4746 + 196])
                        if not mem[_4746 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function sub_35324282(?) payable {
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    if msg.value < sub_eba431c1:
        revert with 0, 'Not paying enough for the Fee'
    mem[100] = this.address
    staticcall address(arg2).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[ceil32(return_data.size) + 132] = msg.sender
    mem[ceil32(return_data.size) + 164] = this.address
    mem[ceil32(return_data.size) + 196] = arg1
    mem[ceil32(return_data.size) + 96] = 100
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
    mem[ceil32(return_data.size) + 128 len 4] = unknown_0x23b872dd(?????)
    mem[ceil32(return_data.size) + 228] = 32
    mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(address(arg2)):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0
    mem[ceil32(return_data.size) + 392] = 0
    call address(arg2) with:
       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0) >> 224
         gas gas_remaining wei
        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg1, 0) << 544)
    if arg3 <= userList.length:
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if not ext_call.return_data[0]:
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4639 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4670 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4670 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4670 + 36 len 28]
                    mem[64] = _4639 + 164
                    mem[_4639 + 100] = 32
                    mem[_4639 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4867 = mem[_4670]
                    s = 0
                    while s < _4867:
                        mem[s + _4639 + 164] = mem[s + _4670 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4867) > _4867:
                        mem[_4867 + _4639 + 164] = 0
                    call address(arg2).mem[_4639 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4639 + 168 len _4867 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4639 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4639 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4639 + 232] = mem[idx + _4639 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4639 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4639 + ceil32(return_data.size) + 165
                        mem[_4639 + 164] = return_data.size
                        mem[_4639 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4639 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4639 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4639 + ceil32(return_data.size) + 233] = mem[idx + _4639 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4639 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4639 + 196] == bool(mem[_4639 + 196])
                            if not mem[_4639 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4611 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4669 = mem[_4611]
                _4735 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4669
                _4755 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4735 + 100] = 32
                mem[_4735 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4967 = mem[_4755]
                mem[_4735 + 164 len ceil32(mem[_4755])] = mem[_4755 + 32 len ceil32(mem[_4755])]
                if ceil32(_4967) > _4967:
                    mem[_4967 + _4735 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4735 + 168 len _4967 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4735 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4735 + 196] == bool(mem[_4735 + 196])
                        if not mem[_4735 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_call.return_data[0] >= 32
                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                if not uint32(this.address), mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4640 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4673 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4673 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4673 + 36 len 28]
                    mem[64] = _4640 + 164
                    mem[_4640 + 100] = 32
                    mem[_4640 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4869 = mem[_4673]
                    s = 0
                    while s < _4869:
                        mem[s + _4640 + 164] = mem[s + _4673 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4869) > _4869:
                        mem[_4869 + _4640 + 164] = 0
                    call address(arg2).mem[_4640 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4640 + 168 len _4869 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4640 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4640 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4640 + 232] = mem[idx + _4640 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4640 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4640 + ceil32(return_data.size) + 165
                        mem[_4640 + 164] = return_data.size
                        mem[_4640 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4640 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4640 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4640 + ceil32(return_data.size) + 233] = mem[idx + _4640 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4640 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4640 + 196] == bool(mem[_4640 + 196])
                            if not mem[_4640 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4613 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4672 = mem[_4613]
                _4736 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4672
                _4757 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4736 + 100] = 32
                mem[_4736 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4970 = mem[_4757]
                mem[_4736 + 164 len ceil32(mem[_4757])] = mem[_4757 + 32 len ceil32(mem[_4757])]
                if ceil32(_4970) > _4970:
                    mem[_4970 + _4736 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4736 + 168 len _4970 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4736 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4736 + 196] == bool(mem[_4736 + 196])
                        if not mem[_4736 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292] = return_data.size
            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4641 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4678 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4678 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4678 + 36 len 28]
                    mem[64] = _4641 + 164
                    mem[_4641 + 100] = 32
                    mem[_4641 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4871 = mem[_4678]
                    s = 0
                    while s < _4871:
                        mem[s + _4641 + 164] = mem[s + _4678 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4871) > _4871:
                        mem[_4871 + _4641 + 164] = 0
                    call address(arg2).mem[_4641 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4641 + 168 len _4871 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4641 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4641 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4641 + 232] = mem[idx + _4641 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4641 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4641 + ceil32(return_data.size) + 165
                        mem[_4641 + 164] = return_data.size
                        mem[_4641 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4641 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4641 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4641 + ceil32(return_data.size) + 233] = mem[idx + _4641 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4641 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4641 + 196] == bool(mem[_4641 + 196])
                            if not mem[_4641 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4615 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4677 = mem[_4615]
                _4737 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4677
                _4759 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4737 + 100] = 32
                mem[_4737 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4973 = mem[_4759]
                mem[_4737 + 164 len ceil32(mem[_4759])] = mem[_4759 + 32 len ceil32(mem[_4759])]
                if ceil32(_4973) > _4973:
                    mem[_4973 + _4737 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4737 + 168 len _4973 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4737 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4737 + 196] == bool(mem[_4737 + 196])
                        if not mem[_4737 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                if not mem[ceil32(return_data.size) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !arg3:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not arg3 + 1:
                    revert with 0, 18
                idx = 0
                while idx < arg3:
                    if idx >= userList.length:
                        revert with 0, 50
                    mem[0] = 2
                    _4642 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / arg3 + 1
                    _4681 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4681 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4681 + 36 len 28]
                    mem[64] = _4642 + 164
                    mem[_4642 + 100] = 32
                    mem[_4642 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4873 = mem[_4681]
                    s = 0
                    while s < _4873:
                        mem[s + _4642 + 164] = mem[s + _4681 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4873) > _4873:
                        mem[_4873 + _4642 + 164] = 0
                    call address(arg2).mem[_4642 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4642 + 168 len _4873 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4642 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4642 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4642 + 232] = mem[idx + _4642 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4642 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4642 + ceil32(return_data.size) + 165
                        mem[_4642 + 164] = return_data.size
                        mem[_4642 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4642 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4642 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4642 + ceil32(return_data.size) + 233] = mem[idx + _4642 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4642 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4642 + 196] == bool(mem[_4642 + 196])
                            if not mem[_4642 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4617 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4680 = mem[_4617]
                _4738 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4680
                _4761 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4738 + 100] = 32
                mem[_4738 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4976 = mem[_4761]
                mem[_4738 + 164 len ceil32(mem[_4761])] = mem[_4761 + 32 len ceil32(mem[_4761])]
                if ceil32(_4976) > _4976:
                    mem[_4976 + _4738 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4738 + 168 len _4976 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4738 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4738 + 196] == bool(mem[_4738 + 196])
                        if not mem[_4738 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if not ext_call.return_data[0]:
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4647 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4702 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4702 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4702 + 36 len 28]
                    mem[64] = _4647 + 164
                    mem[_4647 + 100] = 32
                    mem[_4647 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4883 = mem[_4702]
                    s = 0
                    while s < _4883:
                        mem[s + _4647 + 164] = mem[s + _4702 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4883) > _4883:
                        mem[_4883 + _4647 + 164] = 0
                    call address(arg2).mem[_4647 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4647 + 168 len _4883 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4647 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4647 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4647 + 232] = mem[idx + _4647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4647 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4647 + ceil32(return_data.size) + 165
                        mem[_4647 + 164] = return_data.size
                        mem[_4647 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4647 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4647 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4647 + ceil32(return_data.size) + 233] = mem[idx + _4647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4647 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4647 + 196] == bool(mem[_4647 + 196])
                            if not mem[_4647 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4627 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4701 = mem[_4627]
                _4743 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4701
                _4771 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4743 + 100] = 32
                mem[_4743 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4991 = mem[_4771]
                mem[_4743 + 164 len ceil32(mem[_4771])] = mem[_4771 + 32 len ceil32(mem[_4771])]
                if ceil32(_4991) > _4991:
                    mem[_4991 + _4743 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4743 + 168 len _4991 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4743 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4743 + 196] == bool(mem[_4743 + 196])
                        if not mem[_4743 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_call.return_data[0] >= 32
                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                if not uint32(this.address), mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + 296] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 292] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 292
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4648 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4705 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4705 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4705 + 36 len 28]
                    mem[64] = _4648 + 164
                    mem[_4648 + 100] = 32
                    mem[_4648 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4885 = mem[_4705]
                    s = 0
                    while s < _4885:
                        mem[s + _4648 + 164] = mem[s + _4705 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4885) > _4885:
                        mem[_4885 + _4648 + 164] = 0
                    call address(arg2).mem[_4648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4648 + 168 len _4885 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4648 + 232] = mem[idx + _4648 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4648 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4648 + ceil32(return_data.size) + 165
                        mem[_4648 + 164] = return_data.size
                        mem[_4648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4648 + ceil32(return_data.size) + 233] = mem[idx + _4648 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4648 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4648 + 196] == bool(mem[_4648 + 196])
                            if not mem[_4648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4629 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4704 = mem[_4629]
                _4744 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4704
                _4773 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4744 + 100] = 32
                mem[_4744 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4994 = mem[_4773]
                mem[_4744 + 164 len ceil32(mem[_4773])] = mem[_4773 + 32 len ceil32(mem[_4773])]
                if ceil32(_4994) > _4994:
                    mem[_4994 + _4744 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4744 + 168 len _4994 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4744 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4744 + 196] == bool(mem[_4744 + 196])
                        if not mem[_4744 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292] = return_data.size
            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4649 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4710 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4710 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4710 + 36 len 28]
                    mem[64] = _4649 + 164
                    mem[_4649 + 100] = 32
                    mem[_4649 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4887 = mem[_4710]
                    s = 0
                    while s < _4887:
                        mem[s + _4649 + 164] = mem[s + _4710 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4887) > _4887:
                        mem[_4887 + _4649 + 164] = 0
                    call address(arg2).mem[_4649 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4649 + 168 len _4887 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4649 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4649 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4649 + 232] = mem[idx + _4649 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4649 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4649 + ceil32(return_data.size) + 165
                        mem[_4649 + 164] = return_data.size
                        mem[_4649 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4649 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4649 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4649 + ceil32(return_data.size) + 233] = mem[idx + _4649 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4649 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4649 + 196] == bool(mem[_4649 + 196])
                            if not mem[_4649 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4631 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4709 = mem[_4631]
                _4745 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4709
                _4775 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4745 + 100] = 32
                mem[_4745 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _4997 = mem[_4775]
                mem[_4745 + 164 len ceil32(mem[_4775])] = mem[_4775 + 32 len ceil32(mem[_4775])]
                if ceil32(_4997) > _4997:
                    mem[_4997 + _4745 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4745 + 168 len _4997 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4745 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4745 + 196] == bool(mem[_4745 + 196])
                        if not mem[_4745 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                if not mem[ceil32(return_data.size) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if 1 > !userList.length:
                    revert with 0, 17
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 297] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not userList.length + 1:
                    revert with 0, 18
                idx = 0
                while idx < userList.length:
                    mem[0] = 2
                    _4650 = mem[64]
                    mem[mem[64] + 36] = address(userList[idx])
                    mem[mem[64] + 68] = 0 / userList.length + 1
                    _4713 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4713 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4713 + 36 len 28]
                    mem[64] = _4650 + 164
                    mem[_4650 + 100] = 32
                    mem[_4650 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _4889 = mem[_4713]
                    s = 0
                    while s < _4889:
                        mem[s + _4650 + 164] = mem[s + _4713 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4889) > _4889:
                        mem[_4889 + _4650 + 164] = 0
                    call address(arg2).mem[_4650 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4650 + 168 len _4889 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4650 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4650 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4650 + 232] = mem[idx + _4650 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4650 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _4650 + ceil32(return_data.size) + 165
                        mem[_4650 + 164] = return_data.size
                        mem[_4650 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4650 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4650 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4650 + ceil32(return_data.size) + 233] = mem[idx + _4650 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4650 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4650 + 196] == bool(mem[_4650 + 196])
                            if not mem[_4650 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4633 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4712 = mem[_4633]
                _4746 = mem[64]
                mem[mem[64] + 36] = address(treasuryAddress)
                mem[mem[64] + 68] = _4712
                _4777 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_4746 + 100] = 32
                mem[_4746 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(arg2)):
                    revert with 0, 'Address: call to non-contract'
                _5000 = mem[_4777]
                mem[_4746 + 164 len ceil32(mem[_4777])] = mem[_4777 + 32 len ceil32(mem[_4777])]
                if ceil32(_5000) > _5000:
                    mem[_5000 + _4746 + 164] = 0
                call address(arg2) with:
                     gas gas_remaining wei
                    args mem[_4746 + 168 len _5000 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_4746 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_4746 + 196] == bool(mem[_4746 + 196])
                        if not mem[_4746 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function sub_749d558f(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3 <= userList.length:
        idx = 0
        s = 0
        while idx < arg3:
            if idx >= userList.length:
                revert with 0, 50
            mem[0] = 2
            mem[mem[64] + 4] = address(userList[idx])
            staticcall setTokenAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(userList[idx])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _229 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = mem[_229]
            if idx >= mem[96]:
                revert with 0, 50
            if s > !mem[(32 * idx) + 128]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[(32 * idx) + 128]
            continue 
        mem[mem[64] + 4] = this.address
        staticcall address(arg2).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _221 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _231 = mem[_221]
        _235 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = this.address
        mem[mem[64] + 100] = arg1
        _239 = mem[64]
        mem[mem[64]] = 100
        mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
        mem[64] = mem[64] + 196
        mem[_235 + 132] = 32
        mem[_235 + 164] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(address(arg2)):
            revert with 0, 'Address: call to non-contract'
        _257 = mem[_239]
        mem[_235 + 196 len ceil32(mem[_239])] = mem[_239 + 32 len ceil32(mem[_239])]
        if ceil32(_257) <= _257:
            call address(arg2) with:
                 gas gas_remaining wei
                args mem[_235 + 200 len _257 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    mem[_235 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5057 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5105 = mem[_5057]
                        if mem[_5057] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5057]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5202 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5105 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5236 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5236 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5236 + 36 len 28]
                        mem[64] = _5202 + 164
                        mem[_5202 + 100] = 32
                        mem[_5202 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5441 = mem[_5236]
                        s = 0
                        while s < _5441:
                            mem[s + _5202 + 164] = mem[s + _5236 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5441) > _5441:
                            mem[_5441 + _5202 + 164] = 0
                        call address(arg2).mem[_5202 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5202 + 168 len _5441 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5202 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5202 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5202 + 232] = mem[idx + _5202 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5202 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5202 + ceil32(return_data.size) + 165
                            mem[_5202 + 164] = return_data.size
                            mem[_5202 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5202 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5202 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5202 + ceil32(return_data.size) + 233] = mem[idx + _5202 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5202 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5202 + 196] == bool(mem[_5202 + 196])
                                if not mem[_5202 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4993 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5075 = mem[_4993]
                    _5121 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5075
                    _5137 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5121 + 100] = 32
                    mem[_5121 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5313 = mem[_5137]
                    mem[_5121 + 164 len ceil32(mem[_5137])] = mem[_5137 + 32 len ceil32(mem[_5137])]
                    if ceil32(_5313) > _5313:
                        mem[_5313 + _5121 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5121 + 168 len _5313 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5121 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5121 + 196] == bool(mem[_5121 + 196])
                            if not mem[_5121 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_235 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5058 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5106 = mem[_5058]
                        if mem[_5058] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5058]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5204 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5106 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5241 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5241 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5241 + 36 len 28]
                        mem[64] = _5204 + 164
                        mem[_5204 + 100] = 32
                        mem[_5204 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5443 = mem[_5241]
                        s = 0
                        while s < _5443:
                            mem[s + _5204 + 164] = mem[s + _5241 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5443) > _5443:
                            mem[_5443 + _5204 + 164] = 0
                        call address(arg2).mem[_5204 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5204 + 168 len _5443 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5204 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5204 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5204 + 232] = mem[idx + _5204 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5204 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5204 + ceil32(return_data.size) + 165
                            mem[_5204 + 164] = return_data.size
                            mem[_5204 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5204 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5204 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5204 + ceil32(return_data.size) + 233] = mem[idx + _5204 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5204 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5204 + 196] == bool(mem[_5204 + 196])
                                if not mem[_5204 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4997 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5076 = mem[_4997]
                    _5122 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5076
                    _5139 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5122 + 100] = 32
                    mem[_5122 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5316 = mem[_5139]
                    mem[_5122 + 164 len ceil32(mem[_5139])] = mem[_5139 + 32 len ceil32(mem[_5139])]
                    var80001 = ceil32(_5316)
                    if ceil32(_5316) > _5316:
                        mem[_5316 + _5122 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5122 + 168 len _5316 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5122 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5122 + 196] == bool(mem[_5122 + 196])
                            if not mem[_5122 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_235 + 196] = return_data.size
                mem[_235 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[_235 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5059 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5107 = mem[_5059]
                        if mem[_5059] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5059]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5206 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5107 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5246 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5246 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5246 + 36 len 28]
                        mem[64] = _5206 + 164
                        mem[_5206 + 100] = 32
                        mem[_5206 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5445 = mem[_5246]
                        s = 0
                        while s < _5445:
                            mem[s + _5206 + 164] = mem[s + _5246 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5445) > _5445:
                            mem[_5445 + _5206 + 164] = 0
                        call address(arg2).mem[_5206 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5206 + 168 len _5445 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5206 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5206 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5206 + 232] = mem[idx + _5206 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5206 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5206 + ceil32(return_data.size) + 165
                            mem[_5206 + 164] = return_data.size
                            mem[_5206 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5206 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5206 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5206 + ceil32(return_data.size) + 233] = mem[idx + _5206 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5206 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5206 + 196] == bool(mem[_5206 + 196])
                                if not mem[_5206 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5001 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5079 = mem[_5001]
                    _5123 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5079
                    _5141 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5123 + 100] = 32
                    mem[_5123 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5319 = mem[_5141]
                    mem[_5123 + 164 len ceil32(mem[_5141])] = mem[_5141 + 32 len ceil32(mem[_5141])]
                    if ceil32(_5319) > _5319:
                        mem[_5319 + _5123 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5123 + 168 len _5319 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5123 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5123 + 196] == bool(mem[_5123 + 196])
                            if not mem[_5123 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require return_data.size >= 32
                    require mem[_235 + 228] == bool(mem[_235 + 228])
                    if not mem[_235 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_235 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5060 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5108 = mem[_5060]
                        if mem[_5060] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5060]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5208 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5108 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5251 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5251 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5251 + 36 len 28]
                        mem[64] = _5208 + 164
                        mem[_5208 + 100] = 32
                        mem[_5208 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5447 = mem[_5251]
                        s = 0
                        while s < _5447:
                            mem[s + _5208 + 164] = mem[s + _5251 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5447) > _5447:
                            mem[_5447 + _5208 + 164] = 0
                        call address(arg2).mem[_5208 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5208 + 168 len _5447 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5208 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5208 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5208 + 232] = mem[idx + _5208 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5208 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5208 + ceil32(return_data.size) + 165
                            mem[_5208 + 164] = return_data.size
                            mem[_5208 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5208 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5208 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5208 + ceil32(return_data.size) + 233] = mem[idx + _5208 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5208 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5208 + 196] == bool(mem[_5208 + 196])
                                if not mem[_5208 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5005 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5080 = mem[_5005]
                    _5124 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5080
                    _5143 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5124 + 100] = 32
                    mem[_5124 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5322 = mem[_5143]
                    mem[_5124 + 164 len ceil32(mem[_5143])] = mem[_5143 + 32 len ceil32(mem[_5143])]
                    var80001 = ceil32(_5322)
                    if ceil32(_5322) > _5322:
                        mem[_5322 + _5124 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5124 + 168 len _5322 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5124 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5124 + 196] == bool(mem[_5124 + 196])
                            if not mem[_5124 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[_257 + _235 + 196] = 0
            call address(arg2) with:
                 gas gas_remaining wei
                args mem[_235 + 200 len _257 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    mem[_235 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5061 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5109 = mem[_5061]
                        if mem[_5061] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5061]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5210 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5109 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5256 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5256 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5256 + 36 len 28]
                        mem[64] = _5210 + 164
                        mem[_5210 + 100] = 32
                        mem[_5210 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5449 = mem[_5256]
                        s = 0
                        while s < _5449:
                            mem[s + _5210 + 164] = mem[s + _5256 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5449) > _5449:
                            mem[_5449 + _5210 + 164] = 0
                        call address(arg2).mem[_5210 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5210 + 168 len _5449 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5210 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5210 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5210 + 232] = mem[idx + _5210 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5210 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5210 + ceil32(return_data.size) + 165
                            mem[_5210 + 164] = return_data.size
                            mem[_5210 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5210 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5210 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5210 + ceil32(return_data.size) + 233] = mem[idx + _5210 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5210 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5210 + 196] == bool(mem[_5210 + 196])
                                if not mem[_5210 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5009 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5083 = mem[_5009]
                    _5125 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5083
                    _5145 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5125 + 100] = 32
                    mem[_5125 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5325 = mem[_5145]
                    mem[_5125 + 164 len ceil32(mem[_5145])] = mem[_5145 + 32 len ceil32(mem[_5145])]
                    if ceil32(_5325) > _5325:
                        mem[_5325 + _5125 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5125 + 168 len _5325 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5125 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5125 + 196] == bool(mem[_5125 + 196])
                            if not mem[_5125 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_235 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5062 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5110 = mem[_5062]
                        if mem[_5062] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5062]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5212 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5110 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5261 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5261 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5261 + 36 len 28]
                        mem[64] = _5212 + 164
                        mem[_5212 + 100] = 32
                        mem[_5212 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5451 = mem[_5261]
                        s = 0
                        while s < _5451:
                            mem[s + _5212 + 164] = mem[s + _5261 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5451) > _5451:
                            mem[_5451 + _5212 + 164] = 0
                        call address(arg2).mem[_5212 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5212 + 168 len _5451 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5212 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5212 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5212 + 232] = mem[idx + _5212 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5212 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5212 + ceil32(return_data.size) + 165
                            mem[_5212 + 164] = return_data.size
                            mem[_5212 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5212 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5212 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5212 + ceil32(return_data.size) + 233] = mem[idx + _5212 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5212 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5212 + 196] == bool(mem[_5212 + 196])
                                if not mem[_5212 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5013 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5084 = mem[_5013]
                    _5126 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5084
                    _5147 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5126 + 100] = 32
                    mem[_5126 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5328 = mem[_5147]
                    mem[_5126 + 164 len ceil32(mem[_5147])] = mem[_5147 + 32 len ceil32(mem[_5147])]
                    var80001 = ceil32(_5328)
                    if ceil32(_5328) > _5328:
                        mem[_5328 + _5126 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5126 + 168 len _5328 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5126 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5126 + 196] == bool(mem[_5126 + 196])
                            if not mem[_5126 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_235 + 196] = return_data.size
                mem[_235 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[_235 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5063 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5111 = mem[_5063]
                        if mem[_5063] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5063]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5214 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5111 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5266 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5266 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5266 + 36 len 28]
                        mem[64] = _5214 + 164
                        mem[_5214 + 100] = 32
                        mem[_5214 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5453 = mem[_5266]
                        s = 0
                        while s < _5453:
                            mem[s + _5214 + 164] = mem[s + _5266 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5453) > _5453:
                            mem[_5453 + _5214 + 164] = 0
                        call address(arg2).mem[_5214 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5214 + 168 len _5453 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5214 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5214 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5214 + 232] = mem[idx + _5214 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5214 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5214 + ceil32(return_data.size) + 165
                            mem[_5214 + 164] = return_data.size
                            mem[_5214 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5214 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5214 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5214 + ceil32(return_data.size) + 233] = mem[idx + _5214 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5214 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5214 + 196] == bool(mem[_5214 + 196])
                                if not mem[_5214 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5017 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5087 = mem[_5017]
                    _5127 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5087
                    _5149 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5127 + 100] = 32
                    mem[_5127 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5331 = mem[_5149]
                    mem[_5127 + 164 len ceil32(mem[_5149])] = mem[_5149 + 32 len ceil32(mem[_5149])]
                    if ceil32(_5331) > _5331:
                        mem[_5331 + _5127 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5127 + 168 len _5331 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5127 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5127 + 196] == bool(mem[_5127 + 196])
                            if not mem[_5127 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require return_data.size >= 32
                    require mem[_235 + 228] == bool(mem[_235 + 228])
                    if not mem[_235 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_235 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_235 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _235 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _231:
                        revert with 0, 17
                    if not s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3:
                        revert with 0, 18
                    idx = 0
                    while idx < arg3:
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5064 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5112 = mem[_5064]
                        if mem[_5064] and ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 > -1 / mem[_5064]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5216 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5112 * ext_call.return_data[0] - _231 / s * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3 * arg3
                        _5271 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5271 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5271 + 36 len 28]
                        mem[64] = _5216 + 164
                        mem[_5216 + 100] = 32
                        mem[_5216 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5455 = mem[_5271]
                        s = 0
                        while s < _5455:
                            mem[s + _5216 + 164] = mem[s + _5271 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5455) > _5455:
                            mem[_5455 + _5216 + 164] = 0
                        call address(arg2).mem[_5216 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5216 + 168 len _5455 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5216 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5216 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5216 + 232] = mem[idx + _5216 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5216 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5216 + ceil32(return_data.size) + 165
                            mem[_5216 + 164] = return_data.size
                            mem[_5216 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5216 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5216 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5216 + ceil32(return_data.size) + 233] = mem[idx + _5216 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5216 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5216 + 196] == bool(mem[_5216 + 196])
                                if not mem[_5216 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5021 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5088 = mem[_5021]
                    _5128 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5088
                    _5151 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5128 + 100] = 32
                    mem[_5128 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5334 = mem[_5151]
                    mem[_5128 + 164 len ceil32(mem[_5151])] = mem[_5151 + 32 len ceil32(mem[_5151])]
                    var80001 = ceil32(_5334)
                    if ceil32(_5334) > _5334:
                        mem[_5334 + _5128 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5128 + 168 len _5334 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5128 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var93001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5128 + 196] == bool(mem[_5128 + 196])
                            if not mem[_5128 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        idx = 0
        s = 0
        while idx < userList.length:
            mem[0] = 2
            mem[mem[64] + 4] = address(userList[idx])
            staticcall setTokenAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(userList[idx])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = mem[_230]
            if idx >= mem[96]:
                revert with 0, 50
            if s > !mem[(32 * idx) + 128]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[(32 * idx) + 128]
            continue 
        mem[mem[64] + 4] = this.address
        staticcall address(arg2).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _225 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _232 = mem[_225]
        _237 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = this.address
        mem[mem[64] + 100] = arg1
        _242 = mem[64]
        mem[mem[64]] = 100
        mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
        mem[64] = mem[64] + 196
        mem[_237 + 132] = 32
        mem[_237 + 164] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(address(arg2)):
            revert with 0, 'Address: call to non-contract'
        _259 = mem[_242]
        mem[_237 + 196 len ceil32(mem[_242])] = mem[_242 + 32 len ceil32(mem[_242])]
        if ceil32(_259) <= _259:
            call address(arg2) with:
                 gas gas_remaining wei
                args mem[_237 + 200 len _259 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    mem[_237 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5065 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5113 = mem[_5065]
                        if mem[_5065] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5065]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5218 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5113 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5276 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5276 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5276 + 36 len 28]
                        mem[64] = _5218 + 164
                        mem[_5218 + 100] = 32
                        mem[_5218 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5457 = mem[_5276]
                        s = 0
                        while s < _5457:
                            mem[s + _5218 + 164] = mem[s + _5276 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5457) > _5457:
                            mem[_5457 + _5218 + 164] = 0
                        call address(arg2).mem[_5218 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5218 + 168 len _5457 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5218 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5218 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5218 + 232] = mem[idx + _5218 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5218 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5218 + ceil32(return_data.size) + 165
                            mem[_5218 + 164] = return_data.size
                            mem[_5218 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5218 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5218 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5218 + ceil32(return_data.size) + 233] = mem[idx + _5218 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5218 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5218 + 196] == bool(mem[_5218 + 196])
                                if not mem[_5218 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5025 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5091 = mem[_5025]
                    _5129 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5091
                    _5153 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5129 + 100] = 32
                    mem[_5129 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5337 = mem[_5153]
                    mem[_5129 + 164 len ceil32(mem[_5153])] = mem[_5153 + 32 len ceil32(mem[_5153])]
                    if ceil32(_5337) > _5337:
                        mem[_5337 + _5129 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5129 + 168 len _5337 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5129 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5129 + 196] == bool(mem[_5129 + 196])
                            if not mem[_5129 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_237 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5066 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5114 = mem[_5066]
                        if mem[_5066] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5066]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5220 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5114 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5281 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5281 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5281 + 36 len 28]
                        mem[64] = _5220 + 164
                        mem[_5220 + 100] = 32
                        mem[_5220 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5459 = mem[_5281]
                        s = 0
                        while s < _5459:
                            mem[s + _5220 + 164] = mem[s + _5281 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5459) > _5459:
                            mem[_5459 + _5220 + 164] = 0
                        call address(arg2).mem[_5220 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5220 + 168 len _5459 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5220 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5220 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5220 + 232] = mem[idx + _5220 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5220 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5220 + ceil32(return_data.size) + 165
                            mem[_5220 + 164] = return_data.size
                            mem[_5220 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5220 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5220 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5220 + ceil32(return_data.size) + 233] = mem[idx + _5220 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5220 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5220 + 196] == bool(mem[_5220 + 196])
                                if not mem[_5220 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5029 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5092 = mem[_5029]
                    _5130 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5092
                    _5155 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5130 + 100] = 32
                    mem[_5130 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5340 = mem[_5155]
                    mem[_5130 + 164 len ceil32(mem[_5155])] = mem[_5155 + 32 len ceil32(mem[_5155])]
                    var81001 = ceil32(_5340)
                    if ceil32(_5340) > _5340:
                        mem[_5340 + _5130 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5130 + 168 len _5340 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5130 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5130 + 196] == bool(mem[_5130 + 196])
                            if not mem[_5130 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_237 + 196] = return_data.size
                mem[_237 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[_237 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5067 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5115 = mem[_5067]
                        if mem[_5067] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5067]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5222 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5115 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5286 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5286 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5286 + 36 len 28]
                        mem[64] = _5222 + 164
                        mem[_5222 + 100] = 32
                        mem[_5222 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5461 = mem[_5286]
                        s = 0
                        while s < _5461:
                            mem[s + _5222 + 164] = mem[s + _5286 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5461) > _5461:
                            mem[_5461 + _5222 + 164] = 0
                        call address(arg2).mem[_5222 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5222 + 168 len _5461 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5222 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5222 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5222 + 232] = mem[idx + _5222 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5222 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5222 + ceil32(return_data.size) + 165
                            mem[_5222 + 164] = return_data.size
                            mem[_5222 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5222 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5222 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5222 + ceil32(return_data.size) + 233] = mem[idx + _5222 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5222 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5222 + 196] == bool(mem[_5222 + 196])
                                if not mem[_5222 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5033 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5095 = mem[_5033]
                    _5131 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5095
                    _5157 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5131 + 100] = 32
                    mem[_5131 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5343 = mem[_5157]
                    mem[_5131 + 164 len ceil32(mem[_5157])] = mem[_5157 + 32 len ceil32(mem[_5157])]
                    if ceil32(_5343) > _5343:
                        mem[_5343 + _5131 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5131 + 168 len _5343 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5131 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5131 + 196] == bool(mem[_5131 + 196])
                            if not mem[_5131 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require return_data.size >= 32
                    require mem[_237 + 228] == bool(mem[_237 + 228])
                    if not mem[_237 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_237 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5068 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5116 = mem[_5068]
                        if mem[_5068] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5068]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5224 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5116 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5291 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5291 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5291 + 36 len 28]
                        mem[64] = _5224 + 164
                        mem[_5224 + 100] = 32
                        mem[_5224 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5463 = mem[_5291]
                        s = 0
                        while s < _5463:
                            mem[s + _5224 + 164] = mem[s + _5291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5463) > _5463:
                            mem[_5463 + _5224 + 164] = 0
                        call address(arg2).mem[_5224 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5224 + 168 len _5463 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5224 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5224 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5224 + 232] = mem[idx + _5224 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5224 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5224 + ceil32(return_data.size) + 165
                            mem[_5224 + 164] = return_data.size
                            mem[_5224 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5224 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5224 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5224 + ceil32(return_data.size) + 233] = mem[idx + _5224 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5224 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5224 + 196] == bool(mem[_5224 + 196])
                                if not mem[_5224 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5037 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5096 = mem[_5037]
                    _5132 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5096
                    _5159 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5132 + 100] = 32
                    mem[_5132 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5346 = mem[_5159]
                    mem[_5132 + 164 len ceil32(mem[_5159])] = mem[_5159 + 32 len ceil32(mem[_5159])]
                    var81001 = ceil32(_5346)
                    if ceil32(_5346) > _5346:
                        mem[_5346 + _5132 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5132 + 168 len _5346 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5132 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5132 + 196] == bool(mem[_5132 + 196])
                            if not mem[_5132 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[_259 + _237 + 196] = 0
            call address(arg2) with:
                 gas gas_remaining wei
                args mem[_237 + 200 len _259 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    mem[_237 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5069 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5117 = mem[_5069]
                        if mem[_5069] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5069]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5226 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5117 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5296 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5296 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5296 + 36 len 28]
                        mem[64] = _5226 + 164
                        mem[_5226 + 100] = 32
                        mem[_5226 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5465 = mem[_5296]
                        s = 0
                        while s < _5465:
                            mem[s + _5226 + 164] = mem[s + _5296 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5465) > _5465:
                            mem[_5465 + _5226 + 164] = 0
                        call address(arg2).mem[_5226 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5226 + 168 len _5465 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5226 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5226 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5226 + 232] = mem[idx + _5226 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5226 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5226 + ceil32(return_data.size) + 165
                            mem[_5226 + 164] = return_data.size
                            mem[_5226 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5226 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5226 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5226 + ceil32(return_data.size) + 233] = mem[idx + _5226 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5226 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5226 + 196] == bool(mem[_5226 + 196])
                                if not mem[_5226 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5041 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5099 = mem[_5041]
                    _5133 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5099
                    _5161 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5133 + 100] = 32
                    mem[_5133 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5349 = mem[_5161]
                    mem[_5133 + 164 len ceil32(mem[_5161])] = mem[_5161 + 32 len ceil32(mem[_5161])]
                    if ceil32(_5349) > _5349:
                        mem[_5349 + _5133 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5133 + 168 len _5349 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5133 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5133 + 196] == bool(mem[_5133 + 196])
                            if not mem[_5133 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_237 + 200] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + 196] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + 196
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5070 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5118 = mem[_5070]
                        if mem[_5070] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5070]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5228 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5118 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5301 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5301 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5301 + 36 len 28]
                        mem[64] = _5228 + 164
                        mem[_5228 + 100] = 32
                        mem[_5228 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5467 = mem[_5301]
                        s = 0
                        while s < _5467:
                            mem[s + _5228 + 164] = mem[s + _5301 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5467) > _5467:
                            mem[_5467 + _5228 + 164] = 0
                        call address(arg2).mem[_5228 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5228 + 168 len _5467 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5228 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5228 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5228 + 232] = mem[idx + _5228 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5228 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5228 + ceil32(return_data.size) + 165
                            mem[_5228 + 164] = return_data.size
                            mem[_5228 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5228 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5228 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5228 + ceil32(return_data.size) + 233] = mem[idx + _5228 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5228 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5228 + 196] == bool(mem[_5228 + 196])
                                if not mem[_5228 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5045 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5100 = mem[_5045]
                    _5134 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5100
                    _5163 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5134 + 100] = 32
                    mem[_5134 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5352 = mem[_5163]
                    mem[_5134 + 164 len ceil32(mem[_5163])] = mem[_5163 + 32 len ceil32(mem[_5163])]
                    var81001 = ceil32(_5352)
                    if ceil32(_5352) > _5352:
                        mem[_5352 + _5134 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5134 + 168 len _5352 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5134 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5134 + 196] == bool(mem[_5134 + 196])
                            if not mem[_5134 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_237 + 196] = return_data.size
                mem[_237 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[_237 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5071 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5119 = mem[_5071]
                        if mem[_5071] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5071]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5230 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5119 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5306 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5306 + 36 len 28]
                        mem[64] = _5230 + 164
                        mem[_5230 + 100] = 32
                        mem[_5230 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5469 = mem[_5306]
                        s = 0
                        while s < _5469:
                            mem[s + _5230 + 164] = mem[s + _5306 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5469) > _5469:
                            mem[_5469 + _5230 + 164] = 0
                        call address(arg2).mem[_5230 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5230 + 168 len _5469 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5230 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5230 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5230 + 232] = mem[idx + _5230 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5230 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5230 + ceil32(return_data.size) + 165
                            mem[_5230 + 164] = return_data.size
                            mem[_5230 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5230 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5230 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5230 + ceil32(return_data.size) + 233] = mem[idx + _5230 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5230 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5230 + 196] == bool(mem[_5230 + 196])
                                if not mem[_5230 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5049 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5103 = mem[_5049]
                    _5135 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5103
                    _5165 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5135 + 100] = 32
                    mem[_5135 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5355 = mem[_5165]
                    mem[_5135 + 164 len ceil32(mem[_5165])] = mem[_5165 + 32 len ceil32(mem[_5165])]
                    if ceil32(_5355) > _5355:
                        mem[_5355 + _5135 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5135 + 168 len _5355 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5135 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5135 + 196] == bool(mem[_5135 + 196])
                            if not mem[_5135 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    require return_data.size >= 32
                    require mem[_237 + 228] == bool(mem[_237 + 228])
                    if not mem[_237 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[_237 + ceil32(return_data.size) + 201] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[_237 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _237 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _232:
                        revert with 0, 17
                    if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                        revert with 0, 18
                    idx = 0
                    while idx < userList.length:
                        mem[0] = 2
                        mem[mem[64] + 4] = address(userList[idx])
                        staticcall setTokenAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(userList[idx])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5072 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5120 = mem[_5072]
                        if mem[_5072] and ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_5072]:
                            revert with 0, 17
                        if idx >= userList.length:
                            revert with 0, 50
                        mem[0] = 2
                        _5232 = mem[64]
                        mem[mem[64] + 36] = address(userList[idx])
                        mem[mem[64] + 68] = _5120 * ext_call.return_data[0] - _232 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                        _5311 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5311 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_5311 + 36 len 28]
                        mem[64] = _5232 + 164
                        mem[_5232 + 100] = 32
                        mem[_5232 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(arg2)):
                            revert with 0, 'Address: call to non-contract'
                        _5471 = mem[_5311]
                        s = 0
                        while s < _5471:
                            mem[s + _5232 + 164] = mem[s + _5311 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_5471) > _5471:
                            mem[_5471 + _5232 + 164] = 0
                        call address(arg2).mem[_5232 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5232 + 168 len _5471 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5232 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5232 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5232 + 232] = mem[idx + _5232 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5232 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[64] = _5232 + ceil32(return_data.size) + 165
                            mem[_5232 + 164] = return_data.size
                            mem[_5232 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5232 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5232 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _5232 + ceil32(return_data.size) + 233] = mem[idx + _5232 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5232 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_5232 + 196] == bool(mem[_5232 + 196])
                                if not mem[_5232 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5053 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5104 = mem[_5053]
                    _5136 = mem[64]
                    mem[mem[64] + 36] = address(treasuryAddress)
                    mem[mem[64] + 68] = _5104
                    _5167 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5136 + 100] = 32
                    mem[_5136 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg2)):
                        revert with 0, 'Address: call to non-contract'
                    _5358 = mem[_5167]
                    mem[_5136 + 164 len ceil32(mem[_5167])] = mem[_5167 + 32 len ceil32(mem[_5167])]
                    var81001 = ceil32(_5358)
                    if ceil32(_5358) > _5358:
                        mem[_5358 + _5136 + 164] = 0
                    call address(arg2) with:
                         gas gas_remaining wei
                        args mem[_5136 + 168 len _5358 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5136 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            var94001 = 32
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5136 + 196] == bool(mem[_5136 + 196])
                            if not mem[_5136 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function _fallback() payable {
    mem[64] = 128
    if calldata.size < 4:
        require not calldata.size
    else:
        if unknown_0x715018a6(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xac5cad56(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xeba431c1(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0xeba431c1(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_eba431c1
                    if uint32(call.func_hash) >> 224 != unknown_0xed28ef51(?????):
                        if unknown_0xed9cf58c(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return setTokenAddress
                        require unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not address(cd[4]):
                            revert with 0, 'Ownable: new owner is the zero address'
                        owner = address(cd[4])
                        emit OwnershipTransferred(owner, address(cd[4]));
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] <= test266151307()
                        require cd[4] + 35 < calldata.size
                        if ('cd', 4).length > test266151307():
                            revert with 0, 65
                        if ceil32(32 * ('cd', 4).length) + 129 > test266151307() or ceil32(32 * ('cd', 4).length) + 129 < 128:
                            revert with 0, 65
                        require (32 * ('cd', 4).length) + cd[4] + 36 <= calldata.size
                        idx = cd[4] + 36
                        s = 160
                        while idx < (32 * ('cd', 4).length) + cd[4] + 36:
                            require cd[idx] == address(cd[idx])
                            mem[s] = cd[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 172 len 20]
                            mem[32] = 1
                            if not stor1[mem[(32 * idx) + 172 len 20]]:
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                mem[32] = 1
                                stor1[mem[(32 * idx) + 172 len 20]] = 1
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                userList.length++
                                mem[0] = 2
                                address(userList[userList.length]) = mem[(32 * idx) + 172 len 20]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    if unknown_0xac5cad56(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        mem[132] = this.address
                        staticcall address(cd[4]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(return_data.size) + 164] = address(treasuryAddress)
                        mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + 128] = 68
                        mem[ceil32(return_data.size) + 164 len 28] = Mask(224, 0, stor3)
                        mem[ceil32(return_data.size) + 160 len 4] = unknown_0xa9059cbb(?????)
                        mem[ceil32(return_data.size) + 228] = 32
                        mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(cd[4])):
                            revert with 0, 'Address: call to non-contract'
                        mem[ceil32(return_data.size) + 292 len 96] = unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0
                        mem[ceil32(return_data.size) + 360] = 0
                        call address(cd[4]) with:
                           funct Mask(32, 224, unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0) >> 224
                             gas gas_remaining wei
                            args (Mask(512, -288, unknown_0xa9059cbb(?????), Mask(224, 0, stor3), uint32(stor3), ext_call.return_data[0], 0) << 288)
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                                if not mem[ceil32(return_data.size) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        if unknown_0xb14f2a39(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            address(treasuryAddress) = address(cd[4])
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0xbed16063(?????):
                                require unknown_0xe799ffb1(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                call address(treasuryAddress) with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require calldata.size - 4 >= 96
                                require cd[36] == address(cd[36])
                                require cd[68] <= test266151307()
                                require cd[68] + 35 < calldata.size
                                if ('cd', 68).length > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * ('cd', 68).length) + 129 > test266151307() or ceil32(32 * ('cd', 68).length) + 129 < 128:
                                    revert with 0, 65
                                mem[128] = ('cd', 68).length
                                require (32 * ('cd', 68).length) + cd[68] + 36 <= calldata.size
                                idx = cd[68] + 36
                                s = 160
                                while idx < (32 * ('cd', 68).length) + cd[68] + 36:
                                    require cd[idx] == address(cd[idx])
                                    mem[s] = cd[idx]
                                    idx = idx + 32
                                    s = s + 32
                                    continue 
                                if msg.value < sub_eba431c1:
                                    revert with 0, 'Not paying enough for the Fee'
                                mem[ceil32(32 * ('cd', 68).length) + 133] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(32 * ('cd', 68).length) + 129] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 165] = msg.sender
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 197] = this.address
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 229] = cd[4]
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 129] = 100
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 161 len 4] = unknown_0x23b872dd(?????)
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 261] = 32
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 293] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325 len 128] = 0, msg.sender, address(this.address), cd[4], 0
                                mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 425] = 0
                                call address(cd[36]) with:
                                   funct Mask(32, 224, 0, msg.sender, address(this.address), cd[4], 0) >> 224
                                     gas gas_remaining wei
                                    args (Mask(768, -544, 0, msg.sender, address(this.address), cd[4], 0) << 544)
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        if 1 > !('cd', 68).length:
                                            revert with 0, 17
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 329] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 325
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        if not ('cd', 68).length + 1:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < ('cd', 68).length:
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27405 = mem[64]
                                            mem[mem[64] + 36] = mem[(32 * idx) + 172 len 20]
                                            mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                                            _27620 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_27620 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_27620 + 36 len 28]
                                            mem[64] = _27405 + 164
                                            mem[_27405 + 100] = 32
                                            mem[_27405 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29057 = mem[_27620]
                                            s = 0
                                            while s < _29057:
                                                mem[s + _27405 + 164] = mem[s + _27620 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_29057) > _29057:
                                                mem[_29057 + _27405 + 164] = 0
                                            call address(cd[36]).mem[_27405 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_27405 + 168 len _29057 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_27405 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27405 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27405 + 232] = mem[idx + _27405 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27405 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _27405 + ceil32(return_data.size) + 165
                                                mem[_27405 + 164] = return_data.size
                                                mem[_27405 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_27405 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27405 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27405 + ceil32(return_data.size) + 233] = mem[idx + _27405 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27405 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27405 + 196] == bool(mem[_27405 + 196])
                                                    if not mem[_27405 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27361 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27619 = mem[_27361]
                                        _27837 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27619
                                        _27913 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27837 + 100] = 32
                                        mem[_27837 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29941 = mem[_27913]
                                        mem[_27837 + 164 len ceil32(mem[_27913])] = mem[_27913 + 32 len ceil32(mem[_27913])]
                                        if ceil32(_29941) > _29941:
                                            mem[_29941 + _27837 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27837 + 168 len _29941 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27837 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27837 + 196] == bool(mem[_27837 + 196])
                                                if not mem[_27837 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require mem[96] >= 32
                                        require ('cd', 68).length == bool(('cd', 68).length)
                                        if not ('cd', 68).length:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if 1 > !('cd', 68).length:
                                            revert with 0, 17
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 329] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + 325
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        if not ('cd', 68).length + 1:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < ('cd', 68).length:
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27406 = mem[64]
                                            mem[mem[64] + 36] = mem[(32 * idx) + 172 len 20]
                                            mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                                            _27623 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_27623 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_27623 + 36 len 28]
                                            mem[64] = _27406 + 164
                                            mem[_27406 + 100] = 32
                                            mem[_27406 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29059 = mem[_27623]
                                            s = 0
                                            while s < _29059:
                                                mem[s + _27406 + 164] = mem[s + _27623 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_29059) > _29059:
                                                mem[_29059 + _27406 + 164] = 0
                                            call address(cd[36]).mem[_27406 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_27406 + 168 len _29059 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_27406 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27406 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27406 + 232] = mem[idx + _27406 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27406 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _27406 + ceil32(return_data.size) + 165
                                                mem[_27406 + 164] = return_data.size
                                                mem[_27406 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_27406 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27406 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27406 + ceil32(return_data.size) + 233] = mem[idx + _27406 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27406 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27406 + 196] == bool(mem[_27406 + 196])
                                                    if not mem[_27406 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27363 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27622 = mem[_27363]
                                        _27838 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27622
                                        _27915 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27838 + 100] = 32
                                        mem[_27838 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29944 = mem[_27915]
                                        mem[_27838 + 164 len ceil32(mem[_27915])] = mem[_27915 + 32 len ceil32(mem[_27915])]
                                        if ceil32(_29944) > _29944:
                                            mem[_29944 + _27838 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27838 + 168 len _29944 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27838 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27838 + 196] == bool(mem[_27838 + 196])
                                                if not mem[_27838 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 325] = return_data.size
                                    mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        if 1 > !('cd', 68).length:
                                            revert with 0, 17
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        if not ('cd', 68).length + 1:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < ('cd', 68).length:
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27407 = mem[64]
                                            mem[mem[64] + 36] = mem[(32 * idx) + 172 len 20]
                                            mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                                            _27628 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_27628 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_27628 + 36 len 28]
                                            mem[64] = _27407 + 164
                                            mem[_27407 + 100] = 32
                                            mem[_27407 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29061 = mem[_27628]
                                            s = 0
                                            while s < _29061:
                                                mem[s + _27407 + 164] = mem[s + _27628 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_29061) > _29061:
                                                mem[_29061 + _27407 + 164] = 0
                                            call address(cd[36]).mem[_27407 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_27407 + 168 len _29061 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_27407 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27407 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27407 + 232] = mem[idx + _27407 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27407 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _27407 + ceil32(return_data.size) + 165
                                                mem[_27407 + 164] = return_data.size
                                                mem[_27407 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_27407 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27407 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27407 + ceil32(return_data.size) + 233] = mem[idx + _27407 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27407 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27407 + 196] == bool(mem[_27407 + 196])
                                                    if not mem[_27407 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27365 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27627 = mem[_27365]
                                        _27839 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27627
                                        _27917 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27839 + 100] = 32
                                        mem[_27839 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29947 = mem[_27917]
                                        mem[_27839 + 164 len ceil32(mem[_27917])] = mem[_27917 + 32 len ceil32(mem[_27917])]
                                        if ceil32(_29947) > _29947:
                                            mem[_29947 + _27839 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27839 + 168 len _29947 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27839 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27839 + 196] == bool(mem[_27839 + 196])
                                                if not mem[_27839 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require return_data.size >= 32
                                        require mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 357] == bool(mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 357])
                                        if not mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 357]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if 1 > !('cd', 68).length:
                                            revert with 0, 17
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(32 * ('cd', 68).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        if not ('cd', 68).length + 1:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < ('cd', 68).length:
                                            if idx >= mem[128]:
                                                revert with 0, 50
                                            _27408 = mem[64]
                                            mem[mem[64] + 36] = mem[(32 * idx) + 172 len 20]
                                            mem[mem[64] + 68] = 0 / ('cd', 68).length + 1
                                            _27631 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_27631 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_27631 + 36 len 28]
                                            mem[64] = _27408 + 164
                                            mem[_27408 + 100] = 32
                                            mem[_27408 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29063 = mem[_27631]
                                            s = 0
                                            while s < _29063:
                                                mem[s + _27408 + 164] = mem[s + _27631 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_29063) > _29063:
                                                mem[_29063 + _27408 + 164] = 0
                                            call address(cd[36]).mem[_27408 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_27408 + 168 len _29063 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_27408 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27408 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27408 + 232] = mem[idx + _27408 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27408 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _27408 + ceil32(return_data.size) + 165
                                                mem[_27408 + 164] = return_data.size
                                                mem[_27408 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_27408 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_27408 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _27408 + ceil32(return_data.size) + 233] = mem[idx + _27408 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_27408 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27408 + 196] == bool(mem[_27408 + 196])
                                                    if not mem[_27408 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27367 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27630 = mem[_27367]
                                        _27840 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27630
                                        _27919 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27840 + 100] = 32
                                        mem[_27840 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29950 = mem[_27919]
                                        mem[_27840 + 164 len ceil32(mem[_27919])] = mem[_27919 + 32 len ceil32(mem[_27919])]
                                        if ceil32(_29950) > _29950:
                                            mem[_29950 + _27840 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27840 + 168 len _29950 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27840 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27840 + 196] == bool(mem[_27840 + 196])
                                                if not mem[_27840 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                if unknown_0x8da5cb5b(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return owner
                    if unknown_0x9532ec4c(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        address(treasuryAddress) = address(cd[4])
                    else:
                        if unknown_0x9f4216e8(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] < userList.length
                            return address(userList[cd[4]])
                        require unknown_0x9f904de8(?????) == uint32(call.func_hash) >> 224
                        if msg.value < sub_64b958ca:
                            revert with 0, 'Not paying enough for the Fee'
                        if stor1[msg.sender]:
                            revert with 0, 'Account: You are already listed'
                        stor1[msg.sender] = 1
                        userList.length++
                        uint256(userList[userList.length]) = msg.sender or Mask(96, 160, uint256(userList[userList.length]))
                else:
                    if unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        owner = 0
                        emit OwnershipTransferred(owner, 0);
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0x749d558f(?????):
                            require unknown_0x780947d8(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            idx = 0
                            while idx < userList.length:
                                mem[0] = 2
                                mem[mem[64] + 4] = address(userList[idx])
                                staticcall setTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(userList[idx])
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6402 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6402] >= sub_1ab70811:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if userList.length < 1:
                                    revert with 0, 17
                                if userList.length - 1 >= userList.length:
                                    revert with 0, 50
                                if idx >= userList.length:
                                    revert with 0, 50
                                address(userList[idx]) = address(userList[userList.length])
                                stor1[address(stor2[idx])] = 0
                                if not userList.length:
                                    revert with 0, 49
                                address(userList[userList.length]) = 0
                                userList.length--
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 96
                            require cd[36] == address(cd[36])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if cd[68] <= userList.length:
                                idx = 0
                                s = 0
                                while idx < cd[68]:
                                    if idx >= userList.length:
                                        revert with 0, 50
                                    mem[0] = 2
                                    mem[mem[64] + 4] = address(userList[idx])
                                    staticcall setTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(userList[idx])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6400 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if idx >= mem[96]:
                                        revert with 0, 50
                                    mem[(32 * idx) + 128] = mem[_6400]
                                    if idx >= mem[96]:
                                        revert with 0, 50
                                    if s > !mem[(32 * idx) + 128]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + mem[(32 * idx) + 128]
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6387 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6413 = mem[_6387]
                                _6440 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = this.address
                                mem[mem[64] + 100] = cd[4]
                                _6454 = mem[64]
                                mem[mem[64]] = 100
                                mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
                                mem[64] = mem[64] + 196
                                mem[_6440 + 132] = 32
                                mem[_6440 + 164] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _6624 = mem[_6454]
                                mem[_6440 + 196 len ceil32(mem[_6454])] = mem[_6454 + 32 len ceil32(mem[_6454])]
                                if ceil32(_6624) <= _6624:
                                    call address(cd[36]) with:
                                         gas gas_remaining wei
                                        args mem[_6440 + 200 len _6624 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            mem[_6440 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27385 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27777 = mem[_27385]
                                                if mem[_27385] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27385]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29098 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27777 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29220 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29220 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29220 + 36 len 28]
                                                mem[64] = _29098 + 164
                                                mem[_29098 + 100] = 32
                                                mem[_29098 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31209 = mem[_29220]
                                                s = 0
                                                while s < _31209:
                                                    mem[s + _29098 + 164] = mem[s + _29220 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31209) > _31209:
                                                    mem[_31209 + _29098 + 164] = 0
                                                call address(cd[36]).mem[_29098 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29098 + 168 len _31209 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29098 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29098 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29098 + 232] = mem[idx + _29098 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29098 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29098 + ceil32(return_data.size) + 165
                                                    mem[_29098 + 164] = return_data.size
                                                    mem[_29098 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29098 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29098 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29098 + ceil32(return_data.size) + 233] = mem[idx + _29098 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29098 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29098 + 196] == bool(mem[_29098 + 196])
                                                        if not mem[_29098 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27289 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27571 = mem[_27289]
                                            _27817 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27571
                                            _27873 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27817 + 100] = 32
                                            mem[_27817 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29881 = mem[_27873]
                                            mem[_27817 + 164 len ceil32(mem[_27873])] = mem[_27873 + 32 len ceil32(mem[_27873])]
                                            if ceil32(_29881) > _29881:
                                                mem[_29881 + _27817 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27817 + 168 len _29881 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27817 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27817 + 196] == bool(mem[_27817 + 196])
                                                    if not mem[_27817 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6440 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27386 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27778 = mem[_27386]
                                                if mem[_27386] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27386]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29100 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27778 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29225 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29225 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29225 + 36 len 28]
                                                mem[64] = _29100 + 164
                                                mem[_29100 + 100] = 32
                                                mem[_29100 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31211 = mem[_29225]
                                                s = 0
                                                while s < _31211:
                                                    mem[s + _29100 + 164] = mem[s + _29225 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31211) > _31211:
                                                    mem[_31211 + _29100 + 164] = 0
                                                call address(cd[36]).mem[_29100 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29100 + 168 len _31211 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29100 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29100 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29100 + 232] = mem[idx + _29100 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29100 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29100 + ceil32(return_data.size) + 165
                                                    mem[_29100 + 164] = return_data.size
                                                    mem[_29100 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29100 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29100 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29100 + ceil32(return_data.size) + 233] = mem[idx + _29100 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29100 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29100 + 196] == bool(mem[_29100 + 196])
                                                        if not mem[_29100 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27293 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27572 = mem[_27293]
                                            _27818 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27572
                                            _27875 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27818 + 100] = 32
                                            mem[_27818 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29884 = mem[_27875]
                                            mem[_27818 + 164 len ceil32(mem[_27875])] = mem[_27875 + 32 len ceil32(mem[_27875])]
                                            var86001 = ceil32(_29884)
                                            if ceil32(_29884) > _29884:
                                                mem[_29884 + _27818 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27818 + 168 len _29884 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27818 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27818 + 196] == bool(mem[_27818 + 196])
                                                    if not mem[_27818 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_6440 + 196] = return_data.size
                                        mem[_6440 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[_6440 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27387 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27779 = mem[_27387]
                                                if mem[_27387] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27387]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29102 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27779 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29230 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29230 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29230 + 36 len 28]
                                                mem[64] = _29102 + 164
                                                mem[_29102 + 100] = 32
                                                mem[_29102 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31213 = mem[_29230]
                                                s = 0
                                                while s < _31213:
                                                    mem[s + _29102 + 164] = mem[s + _29230 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31213) > _31213:
                                                    mem[_31213 + _29102 + 164] = 0
                                                call address(cd[36]).mem[_29102 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29102 + 168 len _31213 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29102 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29102 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29102 + 232] = mem[idx + _29102 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29102 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29102 + ceil32(return_data.size) + 165
                                                    mem[_29102 + 164] = return_data.size
                                                    mem[_29102 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29102 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29102 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29102 + ceil32(return_data.size) + 233] = mem[idx + _29102 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29102 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29102 + 196] == bool(mem[_29102 + 196])
                                                        if not mem[_29102 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27297 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27575 = mem[_27297]
                                            _27819 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27575
                                            _27877 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27819 + 100] = 32
                                            mem[_27819 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29887 = mem[_27877]
                                            mem[_27819 + 164 len ceil32(mem[_27877])] = mem[_27877 + 32 len ceil32(mem[_27877])]
                                            if ceil32(_29887) > _29887:
                                                mem[_29887 + _27819 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27819 + 168 len _29887 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27819 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27819 + 196] == bool(mem[_27819 + 196])
                                                    if not mem[_27819 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[_6440 + 228] == bool(mem[_6440 + 228])
                                            if not mem[_6440 + 228]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6440 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27388 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27780 = mem[_27388]
                                                if mem[_27388] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27388]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29104 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27780 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29235 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29235 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29235 + 36 len 28]
                                                mem[64] = _29104 + 164
                                                mem[_29104 + 100] = 32
                                                mem[_29104 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31215 = mem[_29235]
                                                s = 0
                                                while s < _31215:
                                                    mem[s + _29104 + 164] = mem[s + _29235 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31215) > _31215:
                                                    mem[_31215 + _29104 + 164] = 0
                                                call address(cd[36]).mem[_29104 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29104 + 168 len _31215 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29104 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29104 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29104 + 232] = mem[idx + _29104 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29104 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29104 + ceil32(return_data.size) + 165
                                                    mem[_29104 + 164] = return_data.size
                                                    mem[_29104 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29104 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29104 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29104 + ceil32(return_data.size) + 233] = mem[idx + _29104 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29104 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29104 + 196] == bool(mem[_29104 + 196])
                                                        if not mem[_29104 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27301 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27576 = mem[_27301]
                                            _27820 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27576
                                            _27879 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27820 + 100] = 32
                                            mem[_27820 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29890 = mem[_27879]
                                            mem[_27820 + 164 len ceil32(mem[_27879])] = mem[_27879 + 32 len ceil32(mem[_27879])]
                                            var86001 = ceil32(_29890)
                                            if ceil32(_29890) > _29890:
                                                mem[_29890 + _27820 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27820 + 168 len _29890 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27820 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27820 + 196] == bool(mem[_27820 + 196])
                                                    if not mem[_27820 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6624 + _6440 + 196] = 0
                                    call address(cd[36]) with:
                                         gas gas_remaining wei
                                        args mem[_6440 + 200 len _6624 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            mem[_6440 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27389 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27781 = mem[_27389]
                                                if mem[_27389] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27389]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29106 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27781 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29240 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29240 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29240 + 36 len 28]
                                                mem[64] = _29106 + 164
                                                mem[_29106 + 100] = 32
                                                mem[_29106 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31217 = mem[_29240]
                                                s = 0
                                                while s < _31217:
                                                    mem[s + _29106 + 164] = mem[s + _29240 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31217) > _31217:
                                                    mem[_31217 + _29106 + 164] = 0
                                                call address(cd[36]).mem[_29106 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29106 + 168 len _31217 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29106 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29106 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29106 + 232] = mem[idx + _29106 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29106 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29106 + ceil32(return_data.size) + 165
                                                    mem[_29106 + 164] = return_data.size
                                                    mem[_29106 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29106 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29106 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29106 + ceil32(return_data.size) + 233] = mem[idx + _29106 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29106 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29106 + 196] == bool(mem[_29106 + 196])
                                                        if not mem[_29106 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27305 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27579 = mem[_27305]
                                            _27821 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27579
                                            _27881 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27821 + 100] = 32
                                            mem[_27821 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29893 = mem[_27881]
                                            mem[_27821 + 164 len ceil32(mem[_27881])] = mem[_27881 + 32 len ceil32(mem[_27881])]
                                            if ceil32(_29893) > _29893:
                                                mem[_29893 + _27821 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27821 + 168 len _29893 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27821 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27821 + 196] == bool(mem[_27821 + 196])
                                                    if not mem[_27821 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6440 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27390 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27782 = mem[_27390]
                                                if mem[_27390] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27390]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29108 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27782 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29245 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29245 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29245 + 36 len 28]
                                                mem[64] = _29108 + 164
                                                mem[_29108 + 100] = 32
                                                mem[_29108 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31219 = mem[_29245]
                                                s = 0
                                                while s < _31219:
                                                    mem[s + _29108 + 164] = mem[s + _29245 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31219) > _31219:
                                                    mem[_31219 + _29108 + 164] = 0
                                                call address(cd[36]).mem[_29108 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29108 + 168 len _31219 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29108 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29108 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29108 + 232] = mem[idx + _29108 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29108 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29108 + ceil32(return_data.size) + 165
                                                    mem[_29108 + 164] = return_data.size
                                                    mem[_29108 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29108 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29108 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29108 + ceil32(return_data.size) + 233] = mem[idx + _29108 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29108 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29108 + 196] == bool(mem[_29108 + 196])
                                                        if not mem[_29108 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27309 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27580 = mem[_27309]
                                            _27822 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27580
                                            _27883 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27822 + 100] = 32
                                            mem[_27822 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29896 = mem[_27883]
                                            mem[_27822 + 164 len ceil32(mem[_27883])] = mem[_27883 + 32 len ceil32(mem[_27883])]
                                            var86001 = ceil32(_29896)
                                            if ceil32(_29896) > _29896:
                                                mem[_29896 + _27822 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27822 + 168 len _29896 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27822 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27822 + 196] == bool(mem[_27822 + 196])
                                                    if not mem[_27822 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_6440 + 196] = return_data.size
                                        mem[_6440 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[_6440 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27391 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27783 = mem[_27391]
                                                if mem[_27391] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27391]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29110 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27783 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29250 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29250 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29250 + 36 len 28]
                                                mem[64] = _29110 + 164
                                                mem[_29110 + 100] = 32
                                                mem[_29110 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31221 = mem[_29250]
                                                s = 0
                                                while s < _31221:
                                                    mem[s + _29110 + 164] = mem[s + _29250 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31221) > _31221:
                                                    mem[_31221 + _29110 + 164] = 0
                                                call address(cd[36]).mem[_29110 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29110 + 168 len _31221 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29110 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29110 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29110 + 232] = mem[idx + _29110 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29110 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29110 + ceil32(return_data.size) + 165
                                                    mem[_29110 + 164] = return_data.size
                                                    mem[_29110 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29110 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29110 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29110 + ceil32(return_data.size) + 233] = mem[idx + _29110 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29110 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29110 + 196] == bool(mem[_29110 + 196])
                                                        if not mem[_29110 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27313 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27583 = mem[_27313]
                                            _27823 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27583
                                            _27885 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27823 + 100] = 32
                                            mem[_27823 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29899 = mem[_27885]
                                            mem[_27823 + 164 len ceil32(mem[_27885])] = mem[_27885 + 32 len ceil32(mem[_27885])]
                                            if ceil32(_29899) > _29899:
                                                mem[_29899 + _27823 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27823 + 168 len _29899 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27823 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27823 + 196] == bool(mem[_27823 + 196])
                                                    if not mem[_27823 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[_6440 + 228] == bool(mem[_6440 + 228])
                                            if not mem[_6440 + 228]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6440 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6440 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6440 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6413:
                                                revert with 0, 17
                                            if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27392 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27784 = mem[_27392]
                                                if mem[_27392] and ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27392]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29112 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27784 * ext_call.return_data[0] - _6413 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                                _29255 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29255 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29255 + 36 len 28]
                                                mem[64] = _29112 + 164
                                                mem[_29112 + 100] = 32
                                                mem[_29112 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31223 = mem[_29255]
                                                s = 0
                                                while s < _31223:
                                                    mem[s + _29112 + 164] = mem[s + _29255 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31223) > _31223:
                                                    mem[_31223 + _29112 + 164] = 0
                                                call address(cd[36]).mem[_29112 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29112 + 168 len _31223 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29112 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29112 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29112 + 232] = mem[idx + _29112 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29112 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29112 + ceil32(return_data.size) + 165
                                                    mem[_29112 + 164] = return_data.size
                                                    mem[_29112 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29112 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29112 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29112 + ceil32(return_data.size) + 233] = mem[idx + _29112 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29112 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29112 + 196] == bool(mem[_29112 + 196])
                                                        if not mem[_29112 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27317 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27584 = mem[_27317]
                                            _27824 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27584
                                            _27887 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27824 + 100] = 32
                                            mem[_27824 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29902 = mem[_27887]
                                            mem[_27824 + 164 len ceil32(mem[_27887])] = mem[_27887 + 32 len ceil32(mem[_27887])]
                                            var86001 = ceil32(_29902)
                                            if ceil32(_29902) > _29902:
                                                mem[_29902 + _27824 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27824 + 168 len _29902 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27824 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var99001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27824 + 196] == bool(mem[_27824 + 196])
                                                    if not mem[_27824 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                idx = 0
                                s = 0
                                while idx < userList.length:
                                    mem[0] = 2
                                    mem[mem[64] + 4] = address(userList[idx])
                                    staticcall setTokenAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(userList[idx])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6401 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if idx >= mem[96]:
                                        revert with 0, 50
                                    mem[(32 * idx) + 128] = mem[_6401]
                                    if idx >= mem[96]:
                                        revert with 0, 50
                                    if s > !mem[(32 * idx) + 128]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + mem[(32 * idx) + 128]
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6391 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6414 = mem[_6391]
                                _6442 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = this.address
                                mem[mem[64] + 100] = cd[4]
                                _6457 = mem[64]
                                mem[mem[64]] = 100
                                mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
                                mem[64] = mem[64] + 196
                                mem[_6442 + 132] = 32
                                mem[_6442 + 164] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _6626 = mem[_6457]
                                mem[_6442 + 196 len ceil32(mem[_6457])] = mem[_6457 + 32 len ceil32(mem[_6457])]
                                if ceil32(_6626) <= _6626:
                                    call address(cd[36]) with:
                                         gas gas_remaining wei
                                        args mem[_6442 + 200 len _6626 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            mem[_6442 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27393 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27785 = mem[_27393]
                                                if mem[_27393] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27393]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29114 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27785 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29260 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29260 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29260 + 36 len 28]
                                                mem[64] = _29114 + 164
                                                mem[_29114 + 100] = 32
                                                mem[_29114 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31225 = mem[_29260]
                                                s = 0
                                                while s < _31225:
                                                    mem[s + _29114 + 164] = mem[s + _29260 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31225) > _31225:
                                                    mem[_31225 + _29114 + 164] = 0
                                                call address(cd[36]).mem[_29114 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29114 + 168 len _31225 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29114 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29114 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29114 + 232] = mem[idx + _29114 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29114 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29114 + ceil32(return_data.size) + 165
                                                    mem[_29114 + 164] = return_data.size
                                                    mem[_29114 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29114 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29114 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29114 + ceil32(return_data.size) + 233] = mem[idx + _29114 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29114 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29114 + 196] == bool(mem[_29114 + 196])
                                                        if not mem[_29114 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27321 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27587 = mem[_27321]
                                            _27825 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27587
                                            _27889 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27825 + 100] = 32
                                            mem[_27825 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29905 = mem[_27889]
                                            mem[_27825 + 164 len ceil32(mem[_27889])] = mem[_27889 + 32 len ceil32(mem[_27889])]
                                            if ceil32(_29905) > _29905:
                                                mem[_29905 + _27825 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27825 + 168 len _29905 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27825 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27825 + 196] == bool(mem[_27825 + 196])
                                                    if not mem[_27825 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6442 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27394 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27786 = mem[_27394]
                                                if mem[_27394] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27394]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29116 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27786 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29265 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29265 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29265 + 36 len 28]
                                                mem[64] = _29116 + 164
                                                mem[_29116 + 100] = 32
                                                mem[_29116 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31227 = mem[_29265]
                                                s = 0
                                                while s < _31227:
                                                    mem[s + _29116 + 164] = mem[s + _29265 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31227) > _31227:
                                                    mem[_31227 + _29116 + 164] = 0
                                                call address(cd[36]).mem[_29116 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29116 + 168 len _31227 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29116 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29116 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29116 + 232] = mem[idx + _29116 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29116 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29116 + ceil32(return_data.size) + 165
                                                    mem[_29116 + 164] = return_data.size
                                                    mem[_29116 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29116 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29116 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29116 + ceil32(return_data.size) + 233] = mem[idx + _29116 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29116 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29116 + 196] == bool(mem[_29116 + 196])
                                                        if not mem[_29116 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27325 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27588 = mem[_27325]
                                            _27826 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27588
                                            _27891 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27826 + 100] = 32
                                            mem[_27826 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29908 = mem[_27891]
                                            mem[_27826 + 164 len ceil32(mem[_27891])] = mem[_27891 + 32 len ceil32(mem[_27891])]
                                            var87001 = ceil32(_29908)
                                            if ceil32(_29908) > _29908:
                                                mem[_29908 + _27826 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27826 + 168 len _29908 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27826 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27826 + 196] == bool(mem[_27826 + 196])
                                                    if not mem[_27826 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_6442 + 196] = return_data.size
                                        mem[_6442 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[_6442 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27395 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27787 = mem[_27395]
                                                if mem[_27395] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27395]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29118 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27787 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29270 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29270 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29270 + 36 len 28]
                                                mem[64] = _29118 + 164
                                                mem[_29118 + 100] = 32
                                                mem[_29118 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31229 = mem[_29270]
                                                s = 0
                                                while s < _31229:
                                                    mem[s + _29118 + 164] = mem[s + _29270 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31229) > _31229:
                                                    mem[_31229 + _29118 + 164] = 0
                                                call address(cd[36]).mem[_29118 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29118 + 168 len _31229 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29118 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29118 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29118 + 232] = mem[idx + _29118 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29118 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29118 + ceil32(return_data.size) + 165
                                                    mem[_29118 + 164] = return_data.size
                                                    mem[_29118 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29118 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29118 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29118 + ceil32(return_data.size) + 233] = mem[idx + _29118 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29118 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29118 + 196] == bool(mem[_29118 + 196])
                                                        if not mem[_29118 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27329 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27591 = mem[_27329]
                                            _27827 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27591
                                            _27893 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27827 + 100] = 32
                                            mem[_27827 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29911 = mem[_27893]
                                            mem[_27827 + 164 len ceil32(mem[_27893])] = mem[_27893 + 32 len ceil32(mem[_27893])]
                                            if ceil32(_29911) > _29911:
                                                mem[_29911 + _27827 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27827 + 168 len _29911 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27827 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27827 + 196] == bool(mem[_27827 + 196])
                                                    if not mem[_27827 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[_6442 + 228] == bool(mem[_6442 + 228])
                                            if not mem[_6442 + 228]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6442 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27396 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27788 = mem[_27396]
                                                if mem[_27396] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27396]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29120 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27788 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29275 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29275 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29275 + 36 len 28]
                                                mem[64] = _29120 + 164
                                                mem[_29120 + 100] = 32
                                                mem[_29120 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31231 = mem[_29275]
                                                s = 0
                                                while s < _31231:
                                                    mem[s + _29120 + 164] = mem[s + _29275 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31231) > _31231:
                                                    mem[_31231 + _29120 + 164] = 0
                                                call address(cd[36]).mem[_29120 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29120 + 168 len _31231 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29120 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29120 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29120 + 232] = mem[idx + _29120 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29120 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29120 + ceil32(return_data.size) + 165
                                                    mem[_29120 + 164] = return_data.size
                                                    mem[_29120 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29120 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29120 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29120 + ceil32(return_data.size) + 233] = mem[idx + _29120 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29120 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29120 + 196] == bool(mem[_29120 + 196])
                                                        if not mem[_29120 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27333 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27592 = mem[_27333]
                                            _27828 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27592
                                            _27895 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27828 + 100] = 32
                                            mem[_27828 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29914 = mem[_27895]
                                            mem[_27828 + 164 len ceil32(mem[_27895])] = mem[_27895 + 32 len ceil32(mem[_27895])]
                                            var87001 = ceil32(_29914)
                                            if ceil32(_29914) > _29914:
                                                mem[_29914 + _27828 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27828 + 168 len _29914 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27828 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27828 + 196] == bool(mem[_27828 + 196])
                                                    if not mem[_27828 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6626 + _6442 + 196] = 0
                                    call address(cd[36]) with:
                                         gas gas_remaining wei
                                        args mem[_6442 + 200 len _6626 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            mem[_6442 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27397 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27789 = mem[_27397]
                                                if mem[_27397] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27397]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29122 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27789 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29280 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29280 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29280 + 36 len 28]
                                                mem[64] = _29122 + 164
                                                mem[_29122 + 100] = 32
                                                mem[_29122 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31233 = mem[_29280]
                                                s = 0
                                                while s < _31233:
                                                    mem[s + _29122 + 164] = mem[s + _29280 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31233) > _31233:
                                                    mem[_31233 + _29122 + 164] = 0
                                                call address(cd[36]).mem[_29122 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29122 + 168 len _31233 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29122 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29122 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29122 + 232] = mem[idx + _29122 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29122 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29122 + ceil32(return_data.size) + 165
                                                    mem[_29122 + 164] = return_data.size
                                                    mem[_29122 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29122 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29122 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29122 + ceil32(return_data.size) + 233] = mem[idx + _29122 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29122 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29122 + 196] == bool(mem[_29122 + 196])
                                                        if not mem[_29122 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27337 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27595 = mem[_27337]
                                            _27829 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27595
                                            _27897 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27829 + 100] = 32
                                            mem[_27829 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29917 = mem[_27897]
                                            mem[_27829 + 164 len ceil32(mem[_27897])] = mem[_27897 + 32 len ceil32(mem[_27897])]
                                            if ceil32(_29917) > _29917:
                                                mem[_29917 + _27829 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27829 + 168 len _29917 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27829 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27829 + 196] == bool(mem[_27829 + 196])
                                                    if not mem[_27829 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6442 + 200] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + 196] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + 196
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27398 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27790 = mem[_27398]
                                                if mem[_27398] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27398]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29124 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27790 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29285 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29285 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29285 + 36 len 28]
                                                mem[64] = _29124 + 164
                                                mem[_29124 + 100] = 32
                                                mem[_29124 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31235 = mem[_29285]
                                                s = 0
                                                while s < _31235:
                                                    mem[s + _29124 + 164] = mem[s + _29285 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31235) > _31235:
                                                    mem[_31235 + _29124 + 164] = 0
                                                call address(cd[36]).mem[_29124 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29124 + 168 len _31235 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29124 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29124 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29124 + 232] = mem[idx + _29124 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29124 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29124 + ceil32(return_data.size) + 165
                                                    mem[_29124 + 164] = return_data.size
                                                    mem[_29124 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29124 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29124 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29124 + ceil32(return_data.size) + 233] = mem[idx + _29124 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29124 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29124 + 196] == bool(mem[_29124 + 196])
                                                        if not mem[_29124 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27341 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27596 = mem[_27341]
                                            _27830 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27596
                                            _27899 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27830 + 100] = 32
                                            mem[_27830 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29920 = mem[_27899]
                                            mem[_27830 + 164 len ceil32(mem[_27899])] = mem[_27899 + 32 len ceil32(mem[_27899])]
                                            var87001 = ceil32(_29920)
                                            if ceil32(_29920) > _29920:
                                                mem[_29920 + _27830 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27830 + 168 len _29920 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27830 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27830 + 196] == bool(mem[_27830 + 196])
                                                    if not mem[_27830 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_6442 + 196] = return_data.size
                                        mem[_6442 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[_6442 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27399 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27791 = mem[_27399]
                                                if mem[_27399] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27399]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29126 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27791 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29290 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29290 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29290 + 36 len 28]
                                                mem[64] = _29126 + 164
                                                mem[_29126 + 100] = 32
                                                mem[_29126 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31237 = mem[_29290]
                                                s = 0
                                                while s < _31237:
                                                    mem[s + _29126 + 164] = mem[s + _29290 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31237) > _31237:
                                                    mem[_31237 + _29126 + 164] = 0
                                                call address(cd[36]).mem[_29126 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29126 + 168 len _31237 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29126 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29126 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29126 + 232] = mem[idx + _29126 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29126 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29126 + ceil32(return_data.size) + 165
                                                    mem[_29126 + 164] = return_data.size
                                                    mem[_29126 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29126 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29126 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29126 + ceil32(return_data.size) + 233] = mem[idx + _29126 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29126 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29126 + 196] == bool(mem[_29126 + 196])
                                                        if not mem[_29126 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27345 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27599 = mem[_27345]
                                            _27831 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27599
                                            _27901 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27831 + 100] = 32
                                            mem[_27831 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29923 = mem[_27901]
                                            mem[_27831 + 164 len ceil32(mem[_27901])] = mem[_27901 + 32 len ceil32(mem[_27901])]
                                            if ceil32(_29923) > _29923:
                                                mem[_29923 + _27831 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27831 + 168 len _29923 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27831 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27831 + 196] == bool(mem[_27831 + 196])
                                                    if not mem[_27831 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[_6442 + 228] == bool(mem[_6442 + 228])
                                            if not mem[_6442 + 228]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            mem[_6442 + ceil32(return_data.size) + 201] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[_6442 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _6442 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < _6414:
                                                revert with 0, 17
                                            if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                mem[mem[64] + 4] = address(userList[idx])
                                                staticcall setTokenAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args address(userList[idx])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _27400 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _27792 = mem[_27400]
                                                if mem[_27400] and ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27400]:
                                                    revert with 0, 17
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _29128 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = _27792 * ext_call.return_data[0] - _6414 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                                _29295 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_29295 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29295 + 36 len 28]
                                                mem[64] = _29128 + 164
                                                mem[_29128 + 100] = 32
                                                mem[_29128 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _31239 = mem[_29295]
                                                s = 0
                                                while s < _31239:
                                                    mem[s + _29128 + 164] = mem[s + _29295 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_31239) > _31239:
                                                    mem[_31239 + _29128 + 164] = 0
                                                call address(cd[36]).mem[_29128 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_29128 + 168 len _31239 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_29128 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29128 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29128 + 232] = mem[idx + _29128 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29128 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _29128 + ceil32(return_data.size) + 165
                                                    mem[_29128 + 164] = return_data.size
                                                    mem[_29128 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_29128 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_29128 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _29128 + ceil32(return_data.size) + 233] = mem[idx + _29128 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_29128 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_29128 + 196] == bool(mem[_29128 + 196])
                                                        if not mem[_29128 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27349 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27600 = mem[_27349]
                                            _27832 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _27600
                                            _27903 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_27832 + 100] = 32
                                            mem[_27832 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _29926 = mem[_27903]
                                            mem[_27832 + 164 len ceil32(mem[_27903])] = mem[_27903 + 32 len ceil32(mem[_27903])]
                                            var87001 = ceil32(_29926)
                                            if ceil32(_29926) > _29926:
                                                mem[_29926 + _27832 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_27832 + 168 len _29926 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_27832 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    var100001 = 32
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_27832 + 196] == bool(mem[_27832 + 196])
                                                    if not mem[_27832 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if unknown_0x45a18b3c(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x22395f3d(?????) > uint32(call.func_hash) >> 224:
                    if uint32(call.func_hash) >> 224 != unknown_0x035175b7(?????):
                        if unknown_0x1370b5e9(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return userList.length
                        require unknown_0x1ab70811(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return sub_1ab70811
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    sub_64b958ca = cd[4]
                else:
                    if unknown_0x22395f3d(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        address(treasuryAddress) = address(cd[4])
                    else:
                        if unknown_0x25ebf7b1(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not stor1[address(cd[4])]:
                                revert with 0, 'Account: User is not in the List'
                            idx = 0
                            while idx < userList.length:
                                mem[0] = 2
                                if address(userList[idx]) != address(cd[4]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if userList.length < 1:
                                    revert with 0, 17
                                if userList.length - 1 >= userList.length:
                                    revert with 0, 50
                                if idx >= userList.length:
                                    revert with 0, 50
                                address(userList[idx]) = address(userList[userList.length])
                                stor1[address(cd[4])] = 0
                                if not userList.length:
                                    revert with 0, 49
                                address(userList[userList.length]) = 0
                                userList.length--
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x35324282(?????):
                                require unknown_0x421b2d8b(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require cd[4] == address(cd[4])
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                if stor1[address(cd[4])]:
                                    revert with 0, 'Account already listed'
                                stor1[address(cd[4])] = 1
                                userList.length++
                                address(userList[userList.length]) = address(cd[4])
                            else:
                                require calldata.size - 4 >= 96
                                require cd[36] == address(cd[36])
                                if msg.value < sub_eba431c1:
                                    revert with 0, 'Not paying enough for the Fee'
                                mem[132] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(return_data.size) + 164] = msg.sender
                                mem[ceil32(return_data.size) + 196] = this.address
                                mem[ceil32(return_data.size) + 228] = cd[4]
                                mem[ceil32(return_data.size) + 128] = 100
                                mem[ceil32(return_data.size) + 164 len 28] = Mask(224, 32, msg.sender) >> 32
                                mem[ceil32(return_data.size) + 160 len 4] = unknown_0x23b872dd(?????)
                                mem[ceil32(return_data.size) + 260] = 32
                                mem[ceil32(return_data.size) + 292] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                mem[ceil32(return_data.size) + 324 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0
                                mem[ceil32(return_data.size) + 424] = 0
                                call address(cd[36]) with:
                                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0) >> 224
                                     gas gas_remaining wei
                                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0) << 544)
                                if cd[68] <= userList.length:
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            if 1 > !cd[68]:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + 328] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + 324
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not cd[68] + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _17095 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / cd[68] + 1
                                                _17143 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17143 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17143 + 36 len 28]
                                                mem[64] = _17095 + 164
                                                mem[_17095 + 100] = 32
                                                mem[_17095 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17641 = mem[_17143]
                                                s = 0
                                                while s < _17641:
                                                    mem[s + _17095 + 164] = mem[s + _17143 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17641) > _17641:
                                                    mem[_17641 + _17095 + 164] = 0
                                                call address(cd[36]).mem[_17095 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17095 + 168 len _17641 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17095 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17095 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17095 + 232] = mem[idx + _17095 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17095 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17095 + ceil32(return_data.size) + 165
                                                    mem[_17095 + 164] = return_data.size
                                                    mem[_17095 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17095 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17095 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17095 + ceil32(return_data.size) + 233] = mem[idx + _17095 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17095 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17095 + 196] == bool(mem[_17095 + 196])
                                                        if not mem[_17095 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17142 = mem[_17033]
                                            _17321 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17142
                                            _17357 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17321 + 100] = 32
                                            mem[_17321 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17857 = mem[_17357]
                                            mem[_17321 + 164 len ceil32(mem[_17357])] = mem[_17357 + 32 len ceil32(mem[_17357])]
                                            if ceil32(_17857) > _17857:
                                                mem[_17857 + _17321 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17321 + 168 len _17857 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17321 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17321 + 196] == bool(mem[_17321 + 196])
                                                    if not mem[_17321 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if 1 > !cd[68]:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + 328] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + 324
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not cd[68] + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _17096 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / cd[68] + 1
                                                _17146 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17146 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17146 + 36 len 28]
                                                mem[64] = _17096 + 164
                                                mem[_17096 + 100] = 32
                                                mem[_17096 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17643 = mem[_17146]
                                                s = 0
                                                while s < _17643:
                                                    mem[s + _17096 + 164] = mem[s + _17146 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17643) > _17643:
                                                    mem[_17643 + _17096 + 164] = 0
                                                call address(cd[36]).mem[_17096 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17096 + 168 len _17643 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17096 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17096 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17096 + 232] = mem[idx + _17096 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17096 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17096 + ceil32(return_data.size) + 165
                                                    mem[_17096 + 164] = return_data.size
                                                    mem[_17096 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17096 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17096 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17096 + ceil32(return_data.size) + 233] = mem[idx + _17096 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17096 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17096 + 196] == bool(mem[_17096 + 196])
                                                        if not mem[_17096 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17035 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17145 = mem[_17035]
                                            _17322 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17145
                                            _17359 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17322 + 100] = 32
                                            mem[_17322 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17860 = mem[_17359]
                                            mem[_17322 + 164 len ceil32(mem[_17359])] = mem[_17359 + 32 len ceil32(mem[_17359])]
                                            if ceil32(_17860) > _17860:
                                                mem[_17860 + _17322 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17322 + 168 len _17860 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17322 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17322 + 196] == bool(mem[_17322 + 196])
                                                    if not mem[_17322 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[ceil32(return_data.size) + 324] = return_data.size
                                        mem[ceil32(return_data.size) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            if 1 > !cd[68]:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not cd[68] + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _17097 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / cd[68] + 1
                                                _17151 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17151 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17151 + 36 len 28]
                                                mem[64] = _17097 + 164
                                                mem[_17097 + 100] = 32
                                                mem[_17097 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17645 = mem[_17151]
                                                s = 0
                                                while s < _17645:
                                                    mem[s + _17097 + 164] = mem[s + _17151 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17645) > _17645:
                                                    mem[_17645 + _17097 + 164] = 0
                                                call address(cd[36]).mem[_17097 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17097 + 168 len _17645 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17097 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17097 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17097 + 232] = mem[idx + _17097 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17097 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17097 + ceil32(return_data.size) + 165
                                                    mem[_17097 + 164] = return_data.size
                                                    mem[_17097 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17097 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17097 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17097 + ceil32(return_data.size) + 233] = mem[idx + _17097 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17097 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17097 + 196] == bool(mem[_17097 + 196])
                                                        if not mem[_17097 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17150 = mem[_17037]
                                            _17323 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17150
                                            _17361 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17323 + 100] = 32
                                            mem[_17323 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17863 = mem[_17361]
                                            mem[_17323 + 164 len ceil32(mem[_17361])] = mem[_17361 + 32 len ceil32(mem[_17361])]
                                            if ceil32(_17863) > _17863:
                                                mem[_17863 + _17323 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17323 + 168 len _17863 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17323 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17323 + 196] == bool(mem[_17323 + 196])
                                                    if not mem[_17323 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[ceil32(return_data.size) + 356] == bool(mem[ceil32(return_data.size) + 356])
                                            if not mem[ceil32(return_data.size) + 356]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if 1 > !cd[68]:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not cd[68] + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < cd[68]:
                                                if idx >= userList.length:
                                                    revert with 0, 50
                                                mem[0] = 2
                                                _17098 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / cd[68] + 1
                                                _17154 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17154 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17154 + 36 len 28]
                                                mem[64] = _17098 + 164
                                                mem[_17098 + 100] = 32
                                                mem[_17098 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17647 = mem[_17154]
                                                s = 0
                                                while s < _17647:
                                                    mem[s + _17098 + 164] = mem[s + _17154 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17647) > _17647:
                                                    mem[_17647 + _17098 + 164] = 0
                                                call address(cd[36]).mem[_17098 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17098 + 168 len _17647 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17098 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17098 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17098 + 232] = mem[idx + _17098 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17098 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17098 + ceil32(return_data.size) + 165
                                                    mem[_17098 + 164] = return_data.size
                                                    mem[_17098 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17098 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17098 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17098 + ceil32(return_data.size) + 233] = mem[idx + _17098 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17098 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17098 + 196] == bool(mem[_17098 + 196])
                                                        if not mem[_17098 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17039 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17153 = mem[_17039]
                                            _17324 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17153
                                            _17363 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17324 + 100] = 32
                                            mem[_17324 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17866 = mem[_17363]
                                            mem[_17324 + 164 len ceil32(mem[_17363])] = mem[_17363 + 32 len ceil32(mem[_17363])]
                                            if ceil32(_17866) > _17866:
                                                mem[_17866 + _17324 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17324 + 168 len _17866 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17324 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17324 + 196] == bool(mem[_17324 + 196])
                                                    if not mem[_17324 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not mem[96]:
                                            if 1 > !userList.length:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + 328] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + 324
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not userList.length + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                _17103 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / userList.length + 1
                                                _17175 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17175 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17175 + 36 len 28]
                                                mem[64] = _17103 + 164
                                                mem[_17103 + 100] = 32
                                                mem[_17103 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17657 = mem[_17175]
                                                s = 0
                                                while s < _17657:
                                                    mem[s + _17103 + 164] = mem[s + _17175 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17657) > _17657:
                                                    mem[_17657 + _17103 + 164] = 0
                                                call address(cd[36]).mem[_17103 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17103 + 168 len _17657 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17103 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17103 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17103 + 232] = mem[idx + _17103 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17103 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17103 + ceil32(return_data.size) + 165
                                                    mem[_17103 + 164] = return_data.size
                                                    mem[_17103 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17103 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17103 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17103 + ceil32(return_data.size) + 233] = mem[idx + _17103 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17103 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17103 + 196] == bool(mem[_17103 + 196])
                                                        if not mem[_17103 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17049 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17174 = mem[_17049]
                                            _17329 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17174
                                            _17373 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17329 + 100] = 32
                                            mem[_17329 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17881 = mem[_17373]
                                            mem[_17329 + 164 len ceil32(mem[_17373])] = mem[_17373 + 32 len ceil32(mem[_17373])]
                                            if ceil32(_17881) > _17881:
                                                mem[_17881 + _17329 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17329 + 168 len _17881 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17329 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17329 + 196] == bool(mem[_17329 + 196])
                                                    if not mem[_17329 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require mem[96] >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if 1 > !userList.length:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + 328] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + 324
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not userList.length + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                _17104 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / userList.length + 1
                                                _17178 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17178 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17178 + 36 len 28]
                                                mem[64] = _17104 + 164
                                                mem[_17104 + 100] = 32
                                                mem[_17104 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17659 = mem[_17178]
                                                s = 0
                                                while s < _17659:
                                                    mem[s + _17104 + 164] = mem[s + _17178 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17659) > _17659:
                                                    mem[_17659 + _17104 + 164] = 0
                                                call address(cd[36]).mem[_17104 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17104 + 168 len _17659 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17104 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17104 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17104 + 232] = mem[idx + _17104 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17104 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17104 + ceil32(return_data.size) + 165
                                                    mem[_17104 + 164] = return_data.size
                                                    mem[_17104 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17104 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17104 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17104 + ceil32(return_data.size) + 233] = mem[idx + _17104 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17104 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17104 + 196] == bool(mem[_17104 + 196])
                                                        if not mem[_17104 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17051 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17177 = mem[_17051]
                                            _17330 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17177
                                            _17375 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17330 + 100] = 32
                                            mem[_17330 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17884 = mem[_17375]
                                            mem[_17330 + 164 len ceil32(mem[_17375])] = mem[_17375 + 32 len ceil32(mem[_17375])]
                                            if ceil32(_17884) > _17884:
                                                mem[_17884 + _17330 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17330 + 168 len _17884 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17330 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17330 + 196] == bool(mem[_17330 + 196])
                                                    if not mem[_17330 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[ceil32(return_data.size) + 324] = return_data.size
                                        mem[ceil32(return_data.size) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            if 1 > !userList.length:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not userList.length + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                _17105 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / userList.length + 1
                                                _17183 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17183 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17183 + 36 len 28]
                                                mem[64] = _17105 + 164
                                                mem[_17105 + 100] = 32
                                                mem[_17105 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17661 = mem[_17183]
                                                s = 0
                                                while s < _17661:
                                                    mem[s + _17105 + 164] = mem[s + _17183 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17661) > _17661:
                                                    mem[_17661 + _17105 + 164] = 0
                                                call address(cd[36]).mem[_17105 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17105 + 168 len _17661 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17105 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17105 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17105 + 232] = mem[idx + _17105 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17105 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17105 + ceil32(return_data.size) + 165
                                                    mem[_17105 + 164] = return_data.size
                                                    mem[_17105 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17105 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17105 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17105 + ceil32(return_data.size) + 233] = mem[idx + _17105 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17105 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17105 + 196] == bool(mem[_17105 + 196])
                                                        if not mem[_17105 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17182 = mem[_17053]
                                            _17331 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17182
                                            _17377 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17331 + 100] = 32
                                            mem[_17331 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17887 = mem[_17377]
                                            mem[_17331 + 164 len ceil32(mem[_17377])] = mem[_17377 + 32 len ceil32(mem[_17377])]
                                            if ceil32(_17887) > _17887:
                                                mem[_17887 + _17331 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17331 + 168 len _17887 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17331 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17331 + 196] == bool(mem[_17331 + 196])
                                                    if not mem[_17331 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            require return_data.size >= 32
                                            require mem[ceil32(return_data.size) + 356] == bool(mem[ceil32(return_data.size) + 356])
                                            if not mem[ceil32(return_data.size) + 356]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if 1 > !userList.length:
                                                revert with 0, 17
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not userList.length + 1:
                                                revert with 0, 18
                                            idx = 0
                                            while idx < userList.length:
                                                mem[0] = 2
                                                _17106 = mem[64]
                                                mem[mem[64] + 36] = address(userList[idx])
                                                mem[mem[64] + 68] = 0 / userList.length + 1
                                                _17186 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_17186 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17186 + 36 len 28]
                                                mem[64] = _17106 + 164
                                                mem[_17106 + 100] = 32
                                                mem[_17106 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[36])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _17663 = mem[_17186]
                                                s = 0
                                                while s < _17663:
                                                    mem[s + _17106 + 164] = mem[s + _17186 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_17663) > _17663:
                                                    mem[_17663 + _17106 + 164] = 0
                                                call address(cd[36]).mem[_17106 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_17106 + 168 len _17663 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_17106 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17106 + 168] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17106 + 232] = mem[idx + _17106 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17106 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _17106 + ceil32(return_data.size) + 165
                                                    mem[_17106 + 164] = return_data.size
                                                    mem[_17106 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_17106 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_17106 + ceil32(return_data.size) + 169] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _17106 + ceil32(return_data.size) + 233] = mem[idx + _17106 + 132]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_17106 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_17106 + 196] == bool(mem[_17106 + 196])
                                                        if not mem[_17106 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64] + 4] = this.address
                                            staticcall address(cd[36]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17055 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17185 = mem[_17055]
                                            _17332 = mem[64]
                                            mem[mem[64] + 36] = address(treasuryAddress)
                                            mem[mem[64] + 68] = _17185
                                            _17379 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                            mem[64] = mem[64] + 164
                                            mem[_17332 + 100] = 32
                                            mem[_17332 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _17890 = mem[_17379]
                                            mem[_17332 + 164 len ceil32(mem[_17379])] = mem[_17379 + 32 len ceil32(mem[_17379])]
                                            if ceil32(_17890) > _17890:
                                                mem[_17890 + _17332 + 164] = 0
                                            call address(cd[36]) with:
                                                 gas gas_remaining wei
                                                args mem[_17332 + 168 len _17890 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[_17332 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_17332 + 196] == bool(mem[_17332 + 196])
                                                    if not mem[_17332 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                if unknown_0x5a5e1851(?????) > uint32(call.func_hash) >> 224:
                    if uint32(call.func_hash) >> 224 != unknown_0x45a18b3c(?????):
                        if unknown_0x549ada6d(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            if not stor1[msg.sender]:
                                revert with 0, 'Account: You are not in the List'
                            idx = 0
                            while idx < userList.length:
                                mem[0] = 2
                                if address(userList[idx]) != msg.sender:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if userList.length < 1:
                                    revert with 0, 17
                                if userList.length - 1 >= userList.length:
                                    revert with 0, 50
                                if idx >= userList.length:
                                    revert with 0, 50
                                address(userList[idx]) = address(userList[userList.length])
                                stor1[msg.sender] = 0
                                if not userList.length:
                                    revert with 0, 49
                                address(userList[userList.length]) = 0
                                userList.length--
                        require unknown_0x588c5e21(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return bool(stor1[address(cd[4])])
                    require not msg.value
                    require calldata.size - 4 >= 96
                    require cd[36] == address(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    mem[132] = this.address
                    staticcall address(cd[36]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(return_data.size) + 164] = msg.sender
                    mem[ceil32(return_data.size) + 196] = this.address
                    mem[ceil32(return_data.size) + 228] = cd[4]
                    mem[ceil32(return_data.size) + 128] = 100
                    mem[ceil32(return_data.size) + 164 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[ceil32(return_data.size) + 160 len 4] = unknown_0x23b872dd(?????)
                    mem[ceil32(return_data.size) + 260] = 32
                    mem[ceil32(return_data.size) + 292] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(cd[36])):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 324 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0
                    mem[ceil32(return_data.size) + 424] = 0
                    call address(cd[36]) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[4], 0) << 544)
                    if cd[68] <= userList.length:
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                if 1 > !cd[68]:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + 328] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 324
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not cd[68] + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < cd[68]:
                                    if idx >= userList.length:
                                        revert with 0, 50
                                    mem[0] = 2
                                    _17111 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / cd[68] + 1
                                    _17207 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17207 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17207 + 36 len 28]
                                    mem[64] = _17111 + 164
                                    mem[_17111 + 100] = 32
                                    mem[_17111 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17673 = mem[_17207]
                                    s = 0
                                    while s < _17673:
                                        mem[s + _17111 + 164] = mem[s + _17207 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17673) > _17673:
                                        mem[_17673 + _17111 + 164] = 0
                                    call address(cd[36]).mem[_17111 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17111 + 168 len _17673 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17111 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17111 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17111 + 232] = mem[idx + _17111 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17111 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17111 + ceil32(return_data.size) + 165
                                        mem[_17111 + 164] = return_data.size
                                        mem[_17111 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17111 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17111 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17111 + ceil32(return_data.size) + 233] = mem[idx + _17111 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17111 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17111 + 196] == bool(mem[_17111 + 196])
                                            if not mem[_17111 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17065 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17206 = mem[_17065]
                                _17337 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17206
                                _17389 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17337 + 100] = 32
                                mem[_17337 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17905 = mem[_17389]
                                mem[_17337 + 164 len ceil32(mem[_17389])] = mem[_17389 + 32 len ceil32(mem[_17389])]
                                if ceil32(_17905) > _17905:
                                    mem[_17905 + _17337 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17337 + 168 len _17905 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17337 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17337 + 196] == bool(mem[_17337 + 196])
                                        if not mem[_17337 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                require mem[96] >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                if 1 > !cd[68]:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + 328] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 324
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not cd[68] + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < cd[68]:
                                    if idx >= userList.length:
                                        revert with 0, 50
                                    mem[0] = 2
                                    _17112 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / cd[68] + 1
                                    _17210 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17210 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17210 + 36 len 28]
                                    mem[64] = _17112 + 164
                                    mem[_17112 + 100] = 32
                                    mem[_17112 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17675 = mem[_17210]
                                    s = 0
                                    while s < _17675:
                                        mem[s + _17112 + 164] = mem[s + _17210 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17675) > _17675:
                                        mem[_17675 + _17112 + 164] = 0
                                    call address(cd[36]).mem[_17112 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17112 + 168 len _17675 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17112 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17112 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17112 + 232] = mem[idx + _17112 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17112 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17112 + ceil32(return_data.size) + 165
                                        mem[_17112 + 164] = return_data.size
                                        mem[_17112 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17112 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17112 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17112 + ceil32(return_data.size) + 233] = mem[idx + _17112 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17112 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17112 + 196] == bool(mem[_17112 + 196])
                                            if not mem[_17112 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17067 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17209 = mem[_17067]
                                _17338 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17209
                                _17391 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17338 + 100] = 32
                                mem[_17338 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17908 = mem[_17391]
                                mem[_17338 + 164 len ceil32(mem[_17391])] = mem[_17391 + 32 len ceil32(mem[_17391])]
                                if ceil32(_17908) > _17908:
                                    mem[_17908 + _17338 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17338 + 168 len _17908 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17338 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17338 + 196] == bool(mem[_17338 + 196])
                                        if not mem[_17338 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[ceil32(return_data.size) + 324] = return_data.size
                            mem[ceil32(return_data.size) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                if 1 > !cd[68]:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not cd[68] + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < cd[68]:
                                    if idx >= userList.length:
                                        revert with 0, 50
                                    mem[0] = 2
                                    _17113 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / cd[68] + 1
                                    _17215 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17215 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17215 + 36 len 28]
                                    mem[64] = _17113 + 164
                                    mem[_17113 + 100] = 32
                                    mem[_17113 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17677 = mem[_17215]
                                    s = 0
                                    while s < _17677:
                                        mem[s + _17113 + 164] = mem[s + _17215 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17677) > _17677:
                                        mem[_17677 + _17113 + 164] = 0
                                    call address(cd[36]).mem[_17113 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17113 + 168 len _17677 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17113 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17113 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17113 + 232] = mem[idx + _17113 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17113 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17113 + ceil32(return_data.size) + 165
                                        mem[_17113 + 164] = return_data.size
                                        mem[_17113 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17113 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17113 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17113 + ceil32(return_data.size) + 233] = mem[idx + _17113 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17113 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17113 + 196] == bool(mem[_17113 + 196])
                                            if not mem[_17113 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17069 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17214 = mem[_17069]
                                _17339 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17214
                                _17393 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17339 + 100] = 32
                                mem[_17339 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17911 = mem[_17393]
                                mem[_17339 + 164 len ceil32(mem[_17393])] = mem[_17393 + 32 len ceil32(mem[_17393])]
                                if ceil32(_17911) > _17911:
                                    mem[_17911 + _17339 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17339 + 168 len _17911 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17339 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17339 + 196] == bool(mem[_17339 + 196])
                                        if not mem[_17339 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                require return_data.size >= 32
                                require mem[ceil32(return_data.size) + 356] == bool(mem[ceil32(return_data.size) + 356])
                                if not mem[ceil32(return_data.size) + 356]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                if 1 > !cd[68]:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not cd[68] + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < cd[68]:
                                    if idx >= userList.length:
                                        revert with 0, 50
                                    mem[0] = 2
                                    _17114 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / cd[68] + 1
                                    _17218 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17218 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17218 + 36 len 28]
                                    mem[64] = _17114 + 164
                                    mem[_17114 + 100] = 32
                                    mem[_17114 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17679 = mem[_17218]
                                    s = 0
                                    while s < _17679:
                                        mem[s + _17114 + 164] = mem[s + _17218 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17679) > _17679:
                                        mem[_17679 + _17114 + 164] = 0
                                    call address(cd[36]).mem[_17114 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17114 + 168 len _17679 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17114 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17114 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17114 + 232] = mem[idx + _17114 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17114 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17114 + ceil32(return_data.size) + 165
                                        mem[_17114 + 164] = return_data.size
                                        mem[_17114 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17114 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17114 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17114 + ceil32(return_data.size) + 233] = mem[idx + _17114 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17114 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17114 + 196] == bool(mem[_17114 + 196])
                                            if not mem[_17114 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17071 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17217 = mem[_17071]
                                _17340 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17217
                                _17395 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17340 + 100] = 32
                                mem[_17340 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17914 = mem[_17395]
                                mem[_17340 + 164 len ceil32(mem[_17395])] = mem[_17395 + 32 len ceil32(mem[_17395])]
                                if ceil32(_17914) > _17914:
                                    mem[_17914 + _17340 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17340 + 168 len _17914 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17340 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17340 + 196] == bool(mem[_17340 + 196])
                                        if not mem[_17340 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                if 1 > !userList.length:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + 328] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 324
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not userList.length + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < userList.length:
                                    mem[0] = 2
                                    _17119 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / userList.length + 1
                                    _17239 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17239 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17239 + 36 len 28]
                                    mem[64] = _17119 + 164
                                    mem[_17119 + 100] = 32
                                    mem[_17119 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17689 = mem[_17239]
                                    s = 0
                                    while s < _17689:
                                        mem[s + _17119 + 164] = mem[s + _17239 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17689) > _17689:
                                        mem[_17689 + _17119 + 164] = 0
                                    call address(cd[36]).mem[_17119 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17119 + 168 len _17689 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17119 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17119 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17119 + 232] = mem[idx + _17119 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17119 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17119 + ceil32(return_data.size) + 165
                                        mem[_17119 + 164] = return_data.size
                                        mem[_17119 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17119 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17119 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17119 + ceil32(return_data.size) + 233] = mem[idx + _17119 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17119 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17119 + 196] == bool(mem[_17119 + 196])
                                            if not mem[_17119 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17081 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17238 = mem[_17081]
                                _17345 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17238
                                _17405 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17345 + 100] = 32
                                mem[_17345 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17929 = mem[_17405]
                                mem[_17345 + 164 len ceil32(mem[_17405])] = mem[_17405 + 32 len ceil32(mem[_17405])]
                                if ceil32(_17929) > _17929:
                                    mem[_17929 + _17345 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17345 + 168 len _17929 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17345 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17345 + 196] == bool(mem[_17345 + 196])
                                        if not mem[_17345 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                require mem[96] >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                if 1 > !userList.length:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + 328] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + 324] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 324
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not userList.length + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < userList.length:
                                    mem[0] = 2
                                    _17120 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / userList.length + 1
                                    _17242 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17242 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17242 + 36 len 28]
                                    mem[64] = _17120 + 164
                                    mem[_17120 + 100] = 32
                                    mem[_17120 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17691 = mem[_17242]
                                    s = 0
                                    while s < _17691:
                                        mem[s + _17120 + 164] = mem[s + _17242 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17691) > _17691:
                                        mem[_17691 + _17120 + 164] = 0
                                    call address(cd[36]).mem[_17120 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17120 + 168 len _17691 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17120 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17120 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17120 + 232] = mem[idx + _17120 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17120 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17120 + ceil32(return_data.size) + 165
                                        mem[_17120 + 164] = return_data.size
                                        mem[_17120 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17120 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17120 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17120 + ceil32(return_data.size) + 233] = mem[idx + _17120 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17120 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17120 + 196] == bool(mem[_17120 + 196])
                                            if not mem[_17120 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17083 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17241 = mem[_17083]
                                _17346 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17241
                                _17407 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17346 + 100] = 32
                                mem[_17346 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17932 = mem[_17407]
                                mem[_17346 + 164 len ceil32(mem[_17407])] = mem[_17407 + 32 len ceil32(mem[_17407])]
                                if ceil32(_17932) > _17932:
                                    mem[_17932 + _17346 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17346 + 168 len _17932 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17346 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17346 + 196] == bool(mem[_17346 + 196])
                                        if not mem[_17346 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[ceil32(return_data.size) + 324] = return_data.size
                            mem[ceil32(return_data.size) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                if 1 > !userList.length:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not userList.length + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < userList.length:
                                    mem[0] = 2
                                    _17121 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / userList.length + 1
                                    _17247 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17247 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17247 + 36 len 28]
                                    mem[64] = _17121 + 164
                                    mem[_17121 + 100] = 32
                                    mem[_17121 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17693 = mem[_17247]
                                    s = 0
                                    while s < _17693:
                                        mem[s + _17121 + 164] = mem[s + _17247 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17693) > _17693:
                                        mem[_17693 + _17121 + 164] = 0
                                    call address(cd[36]).mem[_17121 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17121 + 168 len _17693 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17121 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17121 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17121 + 232] = mem[idx + _17121 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17121 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17121 + ceil32(return_data.size) + 165
                                        mem[_17121 + 164] = return_data.size
                                        mem[_17121 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17121 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17121 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17121 + ceil32(return_data.size) + 233] = mem[idx + _17121 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17121 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17121 + 196] == bool(mem[_17121 + 196])
                                            if not mem[_17121 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17085 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17246 = mem[_17085]
                                _17347 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17246
                                _17409 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17347 + 100] = 32
                                mem[_17347 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17935 = mem[_17409]
                                mem[_17347 + 164 len ceil32(mem[_17409])] = mem[_17409 + 32 len ceil32(mem[_17409])]
                                if ceil32(_17935) > _17935:
                                    mem[_17935 + _17347 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17347 + 168 len _17935 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17347 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17347 + 196] == bool(mem[_17347 + 196])
                                        if not mem[_17347 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                require return_data.size >= 32
                                require mem[ceil32(return_data.size) + 356] == bool(mem[ceil32(return_data.size) + 356])
                                if not mem[ceil32(return_data.size) + 356]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                if 1 > !userList.length:
                                    revert with 0, 17
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 325] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 325
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if not userList.length + 1:
                                    revert with 0, 18
                                idx = 0
                                while idx < userList.length:
                                    mem[0] = 2
                                    _17122 = mem[64]
                                    mem[mem[64] + 36] = address(userList[idx])
                                    mem[mem[64] + 68] = 0 / userList.length + 1
                                    _17250 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_17250 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_17250 + 36 len 28]
                                    mem[64] = _17122 + 164
                                    mem[_17122 + 100] = 32
                                    mem[_17122 + 132] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 'Address: insufficient balance for call'
                                    if not ext_code.size(address(cd[36])):
                                        revert with 0, 'Address: call to non-contract'
                                    _17695 = mem[_17250]
                                    s = 0
                                    while s < _17695:
                                        mem[s + _17122 + 164] = mem[s + _17250 + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_17695) > _17695:
                                        mem[_17695 + _17122 + 164] = 0
                                    call address(cd[36]).mem[_17122 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_17122 + 168 len _17695 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_17122 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17122 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17122 + 232] = mem[idx + _17122 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17122 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _17122 + ceil32(return_data.size) + 165
                                        mem[_17122 + 164] = return_data.size
                                        mem[_17122 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_17122 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_17122 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _17122 + ceil32(return_data.size) + 233] = mem[idx + _17122 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_17122 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_17122 + 196] == bool(mem[_17122 + 196])
                                            if not mem[_17122 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[mem[64] + 4] = this.address
                                staticcall address(cd[36]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17087 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _17249 = mem[_17087]
                                _17348 = mem[64]
                                mem[mem[64] + 36] = address(treasuryAddress)
                                mem[mem[64] + 68] = _17249
                                _17411 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_17348 + 100] = 32
                                mem[_17348 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 'Address: insufficient balance for call'
                                if not ext_code.size(address(cd[36])):
                                    revert with 0, 'Address: call to non-contract'
                                _17938 = mem[_17411]
                                mem[_17348 + 164 len ceil32(mem[_17411])] = mem[_17411 + 32 len ceil32(mem[_17411])]
                                if ceil32(_17938) > _17938:
                                    mem[_17938 + _17348 + 164] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_17348 + 168 len _17938 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_17348 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_17348 + 196] == bool(mem[_17348 + 196])
                                        if not mem[_17348 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    if unknown_0x5a5e1851(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        sub_eba431c1 = cd[4]
                    else:
                        if unknown_0x61d027b3(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return address(treasuryAddress)
                        if unknown_0x64b958ca(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return sub_64b958ca
                        require unknown_0x6e207eb0(?????) == uint32(call.func_hash) >> 224
                        require calldata.size - 4 >= 96
                        require cd[36] == address(cd[36])
                        if msg.value < sub_eba431c1:
                            revert with 0, 'Not paying enough for the Fee'
                        if cd[68] <= userList.length:
                            idx = 0
                            s = 0
                            while idx < cd[68]:
                                if idx >= userList.length:
                                    revert with 0, 50
                                mem[0] = 2
                                mem[mem[64] + 4] = address(userList[idx])
                                staticcall setTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(userList[idx])
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6398 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = mem[_6398]
                                if idx >= mem[96]:
                                    revert with 0, 50
                                if s > !mem[(32 * idx) + 128]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + mem[(32 * idx) + 128]
                                continue 
                            mem[mem[64] + 4] = this.address
                            staticcall address(cd[36]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6379 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6411 = mem[_6379]
                            _6436 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = cd[4]
                            _6448 = mem[64]
                            mem[mem[64]] = 100
                            mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
                            mem[64] = mem[64] + 196
                            mem[_6436 + 132] = 32
                            mem[_6436 + 164] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 'Address: insufficient balance for call'
                            if not ext_code.size(address(cd[36])):
                                revert with 0, 'Address: call to non-contract'
                            _6620 = mem[_6448]
                            mem[_6436 + 196 len ceil32(mem[_6448])] = mem[_6448 + 32 len ceil32(mem[_6448])]
                            if ceil32(_6620) <= _6620:
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_6436 + 200 len _6620 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        mem[_6436 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27369 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27761 = mem[_27369]
                                            if mem[_27369] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27369]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29066 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27761 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29140 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29140 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29140 + 36 len 28]
                                            mem[64] = _29066 + 164
                                            mem[_29066 + 100] = 32
                                            mem[_29066 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31177 = mem[_29140]
                                            s = 0
                                            while s < _31177:
                                                mem[s + _29066 + 164] = mem[s + _29140 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31177) > _31177:
                                                mem[_31177 + _29066 + 164] = 0
                                            call address(cd[36]).mem[_29066 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29066 + 168 len _31177 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29066 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29066 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29066 + 232] = mem[idx + _29066 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29066 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29066 + ceil32(return_data.size) + 165
                                                mem[_29066 + 164] = return_data.size
                                                mem[_29066 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29066 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29066 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29066 + ceil32(return_data.size) + 233] = mem[idx + _29066 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29066 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29066 + 196] == bool(mem[_29066 + 196])
                                                    if not mem[_29066 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27225 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27539 = mem[_27225]
                                        _27801 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27539
                                        _27841 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27801 + 100] = 32
                                        mem[_27801 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29833 = mem[_27841]
                                        mem[_27801 + 164 len ceil32(mem[_27841])] = mem[_27841 + 32 len ceil32(mem[_27841])]
                                        if ceil32(_29833) > _29833:
                                            mem[_29833 + _27801 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27801 + 168 len _29833 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27801 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27801 + 196] == bool(mem[_27801 + 196])
                                                if not mem[_27801 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6436 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27370 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27762 = mem[_27370]
                                            if mem[_27370] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27370]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29068 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27762 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29145 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29145 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29145 + 36 len 28]
                                            mem[64] = _29068 + 164
                                            mem[_29068 + 100] = 32
                                            mem[_29068 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31179 = mem[_29145]
                                            s = 0
                                            while s < _31179:
                                                mem[s + _29068 + 164] = mem[s + _29145 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31179) > _31179:
                                                mem[_31179 + _29068 + 164] = 0
                                            call address(cd[36]).mem[_29068 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29068 + 168 len _31179 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29068 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29068 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29068 + 232] = mem[idx + _29068 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29068 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29068 + ceil32(return_data.size) + 165
                                                mem[_29068 + 164] = return_data.size
                                                mem[_29068 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29068 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29068 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29068 + ceil32(return_data.size) + 233] = mem[idx + _29068 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29068 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29068 + 196] == bool(mem[_29068 + 196])
                                                    if not mem[_29068 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27229 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27540 = mem[_27229]
                                        _27802 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27540
                                        _27843 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27802 + 100] = 32
                                        mem[_27802 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29836 = mem[_27843]
                                        mem[_27802 + 164 len ceil32(mem[_27843])] = mem[_27843 + 32 len ceil32(mem[_27843])]
                                        var87001 = ceil32(_29836)
                                        if ceil32(_29836) > _29836:
                                            mem[_29836 + _27802 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27802 + 168 len _29836 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27802 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27802 + 196] == bool(mem[_27802 + 196])
                                                if not mem[_27802 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6436 + 196] = return_data.size
                                    mem[_6436 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[_6436 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27371 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27763 = mem[_27371]
                                            if mem[_27371] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27371]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29070 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27763 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29150 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29150 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29150 + 36 len 28]
                                            mem[64] = _29070 + 164
                                            mem[_29070 + 100] = 32
                                            mem[_29070 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31181 = mem[_29150]
                                            s = 0
                                            while s < _31181:
                                                mem[s + _29070 + 164] = mem[s + _29150 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31181) > _31181:
                                                mem[_31181 + _29070 + 164] = 0
                                            call address(cd[36]).mem[_29070 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29070 + 168 len _31181 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29070 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29070 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29070 + 232] = mem[idx + _29070 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29070 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29070 + ceil32(return_data.size) + 165
                                                mem[_29070 + 164] = return_data.size
                                                mem[_29070 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29070 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29070 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29070 + ceil32(return_data.size) + 233] = mem[idx + _29070 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29070 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29070 + 196] == bool(mem[_29070 + 196])
                                                    if not mem[_29070 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27233 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27543 = mem[_27233]
                                        _27803 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27543
                                        _27845 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27803 + 100] = 32
                                        mem[_27803 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29839 = mem[_27845]
                                        mem[_27803 + 164 len ceil32(mem[_27845])] = mem[_27845 + 32 len ceil32(mem[_27845])]
                                        if ceil32(_29839) > _29839:
                                            mem[_29839 + _27803 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27803 + 168 len _29839 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27803 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27803 + 196] == bool(mem[_27803 + 196])
                                                if not mem[_27803 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require return_data.size >= 32
                                        require mem[_6436 + 228] == bool(mem[_6436 + 228])
                                        if not mem[_6436 + 228]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6436 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27372 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27764 = mem[_27372]
                                            if mem[_27372] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27372]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29072 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27764 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29155 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29155 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29155 + 36 len 28]
                                            mem[64] = _29072 + 164
                                            mem[_29072 + 100] = 32
                                            mem[_29072 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31183 = mem[_29155]
                                            s = 0
                                            while s < _31183:
                                                mem[s + _29072 + 164] = mem[s + _29155 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31183) > _31183:
                                                mem[_31183 + _29072 + 164] = 0
                                            call address(cd[36]).mem[_29072 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29072 + 168 len _31183 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29072 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29072 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29072 + 232] = mem[idx + _29072 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29072 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29072 + ceil32(return_data.size) + 165
                                                mem[_29072 + 164] = return_data.size
                                                mem[_29072 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29072 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29072 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29072 + ceil32(return_data.size) + 233] = mem[idx + _29072 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29072 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29072 + 196] == bool(mem[_29072 + 196])
                                                    if not mem[_29072 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27237 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27544 = mem[_27237]
                                        _27804 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27544
                                        _27847 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27804 + 100] = 32
                                        mem[_27804 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29842 = mem[_27847]
                                        mem[_27804 + 164 len ceil32(mem[_27847])] = mem[_27847 + 32 len ceil32(mem[_27847])]
                                        var87001 = ceil32(_29842)
                                        if ceil32(_29842) > _29842:
                                            mem[_29842 + _27804 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27804 + 168 len _29842 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27804 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27804 + 196] == bool(mem[_27804 + 196])
                                                if not mem[_27804 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_6620 + _6436 + 196] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_6436 + 200 len _6620 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        mem[_6436 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27373 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27765 = mem[_27373]
                                            if mem[_27373] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27373]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29074 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27765 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29160 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29160 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29160 + 36 len 28]
                                            mem[64] = _29074 + 164
                                            mem[_29074 + 100] = 32
                                            mem[_29074 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31185 = mem[_29160]
                                            s = 0
                                            while s < _31185:
                                                mem[s + _29074 + 164] = mem[s + _29160 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31185) > _31185:
                                                mem[_31185 + _29074 + 164] = 0
                                            call address(cd[36]).mem[_29074 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29074 + 168 len _31185 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29074 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29074 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29074 + 232] = mem[idx + _29074 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29074 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29074 + ceil32(return_data.size) + 165
                                                mem[_29074 + 164] = return_data.size
                                                mem[_29074 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29074 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29074 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29074 + ceil32(return_data.size) + 233] = mem[idx + _29074 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29074 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29074 + 196] == bool(mem[_29074 + 196])
                                                    if not mem[_29074 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27241 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27547 = mem[_27241]
                                        _27805 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27547
                                        _27849 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27805 + 100] = 32
                                        mem[_27805 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29845 = mem[_27849]
                                        mem[_27805 + 164 len ceil32(mem[_27849])] = mem[_27849 + 32 len ceil32(mem[_27849])]
                                        if ceil32(_29845) > _29845:
                                            mem[_29845 + _27805 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27805 + 168 len _29845 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27805 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27805 + 196] == bool(mem[_27805 + 196])
                                                if not mem[_27805 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6436 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27374 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27766 = mem[_27374]
                                            if mem[_27374] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27374]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29076 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27766 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29165 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29165 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29165 + 36 len 28]
                                            mem[64] = _29076 + 164
                                            mem[_29076 + 100] = 32
                                            mem[_29076 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31187 = mem[_29165]
                                            s = 0
                                            while s < _31187:
                                                mem[s + _29076 + 164] = mem[s + _29165 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31187) > _31187:
                                                mem[_31187 + _29076 + 164] = 0
                                            call address(cd[36]).mem[_29076 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29076 + 168 len _31187 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29076 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29076 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29076 + 232] = mem[idx + _29076 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29076 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29076 + ceil32(return_data.size) + 165
                                                mem[_29076 + 164] = return_data.size
                                                mem[_29076 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29076 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29076 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29076 + ceil32(return_data.size) + 233] = mem[idx + _29076 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29076 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29076 + 196] == bool(mem[_29076 + 196])
                                                    if not mem[_29076 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27245 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27548 = mem[_27245]
                                        _27806 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27548
                                        _27851 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27806 + 100] = 32
                                        mem[_27806 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29848 = mem[_27851]
                                        mem[_27806 + 164 len ceil32(mem[_27851])] = mem[_27851 + 32 len ceil32(mem[_27851])]
                                        var87001 = ceil32(_29848)
                                        if ceil32(_29848) > _29848:
                                            mem[_29848 + _27806 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27806 + 168 len _29848 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27806 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27806 + 196] == bool(mem[_27806 + 196])
                                                if not mem[_27806 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6436 + 196] = return_data.size
                                    mem[_6436 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[_6436 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27375 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27767 = mem[_27375]
                                            if mem[_27375] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27375]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29078 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27767 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29170 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29170 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29170 + 36 len 28]
                                            mem[64] = _29078 + 164
                                            mem[_29078 + 100] = 32
                                            mem[_29078 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31189 = mem[_29170]
                                            s = 0
                                            while s < _31189:
                                                mem[s + _29078 + 164] = mem[s + _29170 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31189) > _31189:
                                                mem[_31189 + _29078 + 164] = 0
                                            call address(cd[36]).mem[_29078 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29078 + 168 len _31189 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29078 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29078 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29078 + 232] = mem[idx + _29078 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29078 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29078 + ceil32(return_data.size) + 165
                                                mem[_29078 + 164] = return_data.size
                                                mem[_29078 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29078 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29078 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29078 + ceil32(return_data.size) + 233] = mem[idx + _29078 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29078 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29078 + 196] == bool(mem[_29078 + 196])
                                                    if not mem[_29078 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27249 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27551 = mem[_27249]
                                        _27807 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27551
                                        _27853 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27807 + 100] = 32
                                        mem[_27807 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29851 = mem[_27853]
                                        mem[_27807 + 164 len ceil32(mem[_27853])] = mem[_27853 + 32 len ceil32(mem[_27853])]
                                        if ceil32(_29851) > _29851:
                                            mem[_29851 + _27807 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27807 + 168 len _29851 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27807 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27807 + 196] == bool(mem[_27807 + 196])
                                                if not mem[_27807 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require return_data.size >= 32
                                        require mem[_6436 + 228] == bool(mem[_6436 + 228])
                                        if not mem[_6436 + 228]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6436 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6436 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6436 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6411:
                                            revert with 0, 17
                                        if not s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < cd[68]:
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27376 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27768 = mem[_27376]
                                            if mem[_27376] and ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] > -1 / mem[_27376]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29080 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27768 * ext_call.return_data[0] - _6411 / s * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68] * cd[68]
                                            _29175 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29175 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29175 + 36 len 28]
                                            mem[64] = _29080 + 164
                                            mem[_29080 + 100] = 32
                                            mem[_29080 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31191 = mem[_29175]
                                            s = 0
                                            while s < _31191:
                                                mem[s + _29080 + 164] = mem[s + _29175 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31191) > _31191:
                                                mem[_31191 + _29080 + 164] = 0
                                            call address(cd[36]).mem[_29080 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29080 + 168 len _31191 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29080 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29080 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29080 + 232] = mem[idx + _29080 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29080 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29080 + ceil32(return_data.size) + 165
                                                mem[_29080 + 164] = return_data.size
                                                mem[_29080 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29080 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29080 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29080 + ceil32(return_data.size) + 233] = mem[idx + _29080 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29080 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29080 + 196] == bool(mem[_29080 + 196])
                                                    if not mem[_29080 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27253 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27552 = mem[_27253]
                                        _27808 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27552
                                        _27855 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27808 + 100] = 32
                                        mem[_27808 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29854 = mem[_27855]
                                        mem[_27808 + 164 len ceil32(mem[_27855])] = mem[_27855 + 32 len ceil32(mem[_27855])]
                                        var87001 = ceil32(_29854)
                                        if ceil32(_29854) > _29854:
                                            mem[_29854 + _27808 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27808 + 168 len _29854 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27808 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var100001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27808 + 196] == bool(mem[_27808 + 196])
                                                if not mem[_27808 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            idx = 0
                            s = 0
                            while idx < userList.length:
                                mem[0] = 2
                                mem[mem[64] + 4] = address(userList[idx])
                                staticcall setTokenAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(userList[idx])
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6399 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = mem[_6399]
                                if idx >= mem[96]:
                                    revert with 0, 50
                                if s > !mem[(32 * idx) + 128]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + mem[(32 * idx) + 128]
                                continue 
                            mem[mem[64] + 4] = this.address
                            staticcall address(cd[36]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6383 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6412 = mem[_6383]
                            _6438 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = cd[4]
                            _6451 = mem[64]
                            mem[mem[64]] = 100
                            mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
                            mem[64] = mem[64] + 196
                            mem[_6438 + 132] = 32
                            mem[_6438 + 164] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 'Address: insufficient balance for call'
                            if not ext_code.size(address(cd[36])):
                                revert with 0, 'Address: call to non-contract'
                            _6622 = mem[_6451]
                            mem[_6438 + 196 len ceil32(mem[_6451])] = mem[_6451 + 32 len ceil32(mem[_6451])]
                            if ceil32(_6622) <= _6622:
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_6438 + 200 len _6622 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        mem[_6438 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27377 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27769 = mem[_27377]
                                            if mem[_27377] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27377]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29082 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27769 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29180 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29180 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29180 + 36 len 28]
                                            mem[64] = _29082 + 164
                                            mem[_29082 + 100] = 32
                                            mem[_29082 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31193 = mem[_29180]
                                            s = 0
                                            while s < _31193:
                                                mem[s + _29082 + 164] = mem[s + _29180 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31193) > _31193:
                                                mem[_31193 + _29082 + 164] = 0
                                            call address(cd[36]).mem[_29082 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29082 + 168 len _31193 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29082 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29082 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29082 + 232] = mem[idx + _29082 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29082 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29082 + ceil32(return_data.size) + 165
                                                mem[_29082 + 164] = return_data.size
                                                mem[_29082 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29082 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29082 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29082 + ceil32(return_data.size) + 233] = mem[idx + _29082 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29082 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29082 + 196] == bool(mem[_29082 + 196])
                                                    if not mem[_29082 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27257 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27555 = mem[_27257]
                                        _27809 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27555
                                        _27857 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27809 + 100] = 32
                                        mem[_27809 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29857 = mem[_27857]
                                        mem[_27809 + 164 len ceil32(mem[_27857])] = mem[_27857 + 32 len ceil32(mem[_27857])]
                                        if ceil32(_29857) > _29857:
                                            mem[_29857 + _27809 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27809 + 168 len _29857 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27809 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27809 + 196] == bool(mem[_27809 + 196])
                                                if not mem[_27809 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6438 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27378 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27770 = mem[_27378]
                                            if mem[_27378] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27378]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29084 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27770 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29185 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29185 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29185 + 36 len 28]
                                            mem[64] = _29084 + 164
                                            mem[_29084 + 100] = 32
                                            mem[_29084 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31195 = mem[_29185]
                                            s = 0
                                            while s < _31195:
                                                mem[s + _29084 + 164] = mem[s + _29185 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31195) > _31195:
                                                mem[_31195 + _29084 + 164] = 0
                                            call address(cd[36]).mem[_29084 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29084 + 168 len _31195 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29084 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29084 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29084 + 232] = mem[idx + _29084 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29084 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29084 + ceil32(return_data.size) + 165
                                                mem[_29084 + 164] = return_data.size
                                                mem[_29084 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29084 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29084 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29084 + ceil32(return_data.size) + 233] = mem[idx + _29084 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29084 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29084 + 196] == bool(mem[_29084 + 196])
                                                    if not mem[_29084 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27261 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27556 = mem[_27261]
                                        _27810 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27556
                                        _27859 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27810 + 100] = 32
                                        mem[_27810 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29860 = mem[_27859]
                                        mem[_27810 + 164 len ceil32(mem[_27859])] = mem[_27859 + 32 len ceil32(mem[_27859])]
                                        var88001 = ceil32(_29860)
                                        if ceil32(_29860) > _29860:
                                            mem[_29860 + _27810 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27810 + 168 len _29860 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27810 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27810 + 196] == bool(mem[_27810 + 196])
                                                if not mem[_27810 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6438 + 196] = return_data.size
                                    mem[_6438 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[_6438 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27379 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27771 = mem[_27379]
                                            if mem[_27379] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27379]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29086 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27771 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29190 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29190 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29190 + 36 len 28]
                                            mem[64] = _29086 + 164
                                            mem[_29086 + 100] = 32
                                            mem[_29086 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31197 = mem[_29190]
                                            s = 0
                                            while s < _31197:
                                                mem[s + _29086 + 164] = mem[s + _29190 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31197) > _31197:
                                                mem[_31197 + _29086 + 164] = 0
                                            call address(cd[36]).mem[_29086 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29086 + 168 len _31197 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29086 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29086 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29086 + 232] = mem[idx + _29086 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29086 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29086 + ceil32(return_data.size) + 165
                                                mem[_29086 + 164] = return_data.size
                                                mem[_29086 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29086 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29086 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29086 + ceil32(return_data.size) + 233] = mem[idx + _29086 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29086 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29086 + 196] == bool(mem[_29086 + 196])
                                                    if not mem[_29086 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27265 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27559 = mem[_27265]
                                        _27811 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27559
                                        _27861 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27811 + 100] = 32
                                        mem[_27811 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29863 = mem[_27861]
                                        mem[_27811 + 164 len ceil32(mem[_27861])] = mem[_27861 + 32 len ceil32(mem[_27861])]
                                        if ceil32(_29863) > _29863:
                                            mem[_29863 + _27811 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27811 + 168 len _29863 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27811 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27811 + 196] == bool(mem[_27811 + 196])
                                                if not mem[_27811 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require return_data.size >= 32
                                        require mem[_6438 + 228] == bool(mem[_6438 + 228])
                                        if not mem[_6438 + 228]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6438 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27380 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27772 = mem[_27380]
                                            if mem[_27380] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27380]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29088 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27772 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29195 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29195 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29195 + 36 len 28]
                                            mem[64] = _29088 + 164
                                            mem[_29088 + 100] = 32
                                            mem[_29088 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31199 = mem[_29195]
                                            s = 0
                                            while s < _31199:
                                                mem[s + _29088 + 164] = mem[s + _29195 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31199) > _31199:
                                                mem[_31199 + _29088 + 164] = 0
                                            call address(cd[36]).mem[_29088 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29088 + 168 len _31199 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29088 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29088 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29088 + 232] = mem[idx + _29088 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29088 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29088 + ceil32(return_data.size) + 165
                                                mem[_29088 + 164] = return_data.size
                                                mem[_29088 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29088 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29088 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29088 + ceil32(return_data.size) + 233] = mem[idx + _29088 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29088 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29088 + 196] == bool(mem[_29088 + 196])
                                                    if not mem[_29088 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27269 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27560 = mem[_27269]
                                        _27812 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27560
                                        _27863 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27812 + 100] = 32
                                        mem[_27812 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29866 = mem[_27863]
                                        mem[_27812 + 164 len ceil32(mem[_27863])] = mem[_27863 + 32 len ceil32(mem[_27863])]
                                        var88001 = ceil32(_29866)
                                        if ceil32(_29866) > _29866:
                                            mem[_29866 + _27812 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27812 + 168 len _29866 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27812 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27812 + 196] == bool(mem[_27812 + 196])
                                                if not mem[_27812 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_6622 + _6438 + 196] = 0
                                call address(cd[36]) with:
                                     gas gas_remaining wei
                                    args mem[_6438 + 200 len _6622 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        mem[_6438 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27381 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27773 = mem[_27381]
                                            if mem[_27381] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27381]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29090 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27773 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29200 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29200 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29200 + 36 len 28]
                                            mem[64] = _29090 + 164
                                            mem[_29090 + 100] = 32
                                            mem[_29090 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31201 = mem[_29200]
                                            s = 0
                                            while s < _31201:
                                                mem[s + _29090 + 164] = mem[s + _29200 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31201) > _31201:
                                                mem[_31201 + _29090 + 164] = 0
                                            call address(cd[36]).mem[_29090 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29090 + 168 len _31201 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29090 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29090 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29090 + 232] = mem[idx + _29090 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29090 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29090 + ceil32(return_data.size) + 165
                                                mem[_29090 + 164] = return_data.size
                                                mem[_29090 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29090 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29090 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29090 + ceil32(return_data.size) + 233] = mem[idx + _29090 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29090 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29090 + 196] == bool(mem[_29090 + 196])
                                                    if not mem[_29090 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27273 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27563 = mem[_27273]
                                        _27813 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27563
                                        _27865 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27813 + 100] = 32
                                        mem[_27813 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29869 = mem[_27865]
                                        mem[_27813 + 164 len ceil32(mem[_27865])] = mem[_27865 + 32 len ceil32(mem[_27865])]
                                        if ceil32(_29869) > _29869:
                                            mem[_29869 + _27813 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27813 + 168 len _29869 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27813 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27813 + 196] == bool(mem[_27813 + 196])
                                                if not mem[_27813 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6438 + 200] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + 196] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + 196
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27382 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27774 = mem[_27382]
                                            if mem[_27382] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27382]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29092 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27774 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29205 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29205 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29205 + 36 len 28]
                                            mem[64] = _29092 + 164
                                            mem[_29092 + 100] = 32
                                            mem[_29092 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31203 = mem[_29205]
                                            s = 0
                                            while s < _31203:
                                                mem[s + _29092 + 164] = mem[s + _29205 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31203) > _31203:
                                                mem[_31203 + _29092 + 164] = 0
                                            call address(cd[36]).mem[_29092 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29092 + 168 len _31203 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29092 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29092 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29092 + 232] = mem[idx + _29092 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29092 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29092 + ceil32(return_data.size) + 165
                                                mem[_29092 + 164] = return_data.size
                                                mem[_29092 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29092 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29092 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29092 + ceil32(return_data.size) + 233] = mem[idx + _29092 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29092 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29092 + 196] == bool(mem[_29092 + 196])
                                                    if not mem[_29092 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27277 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27564 = mem[_27277]
                                        _27814 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27564
                                        _27867 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27814 + 100] = 32
                                        mem[_27814 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29872 = mem[_27867]
                                        mem[_27814 + 164 len ceil32(mem[_27867])] = mem[_27867 + 32 len ceil32(mem[_27867])]
                                        var88001 = ceil32(_29872)
                                        if ceil32(_29872) > _29872:
                                            mem[_29872 + _27814 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27814 + 168 len _29872 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27814 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27814 + 196] == bool(mem[_27814 + 196])
                                                if not mem[_27814 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_6438 + 196] = return_data.size
                                    mem[_6438 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[_6438 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27383 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27775 = mem[_27383]
                                            if mem[_27383] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27383]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29094 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27775 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29210 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29210 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29210 + 36 len 28]
                                            mem[64] = _29094 + 164
                                            mem[_29094 + 100] = 32
                                            mem[_29094 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31205 = mem[_29210]
                                            s = 0
                                            while s < _31205:
                                                mem[s + _29094 + 164] = mem[s + _29210 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31205) > _31205:
                                                mem[_31205 + _29094 + 164] = 0
                                            call address(cd[36]).mem[_29094 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29094 + 168 len _31205 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29094 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29094 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29094 + 232] = mem[idx + _29094 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29094 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29094 + ceil32(return_data.size) + 165
                                                mem[_29094 + 164] = return_data.size
                                                mem[_29094 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29094 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29094 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29094 + ceil32(return_data.size) + 233] = mem[idx + _29094 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29094 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29094 + 196] == bool(mem[_29094 + 196])
                                                    if not mem[_29094 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27281 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27567 = mem[_27281]
                                        _27815 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27567
                                        _27869 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27815 + 100] = 32
                                        mem[_27815 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29875 = mem[_27869]
                                        mem[_27815 + 164 len ceil32(mem[_27869])] = mem[_27869 + 32 len ceil32(mem[_27869])]
                                        if ceil32(_29875) > _29875:
                                            mem[_29875 + _27815 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27815 + 168 len _29875 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27815 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27815 + 196] == bool(mem[_27815 + 196])
                                                if not mem[_27815 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        require return_data.size >= 32
                                        require mem[_6438 + 228] == bool(mem[_6438 + 228])
                                        if not mem[_6438 + 228]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        mem[_6438 + ceil32(return_data.size) + 201] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[_6438 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6438 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] < _6412:
                                            revert with 0, 17
                                        if not s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length:
                                            revert with 0, 18
                                        idx = 0
                                        while idx < userList.length:
                                            mem[0] = 2
                                            mem[mem[64] + 4] = address(userList[idx])
                                            staticcall setTokenAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(userList[idx])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27384 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _27776 = mem[_27384]
                                            if mem[_27384] and ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length > -1 / mem[_27384]:
                                                revert with 0, 17
                                            if idx >= userList.length:
                                                revert with 0, 50
                                            mem[0] = 2
                                            _29096 = mem[64]
                                            mem[mem[64] + 36] = address(userList[idx])
                                            mem[mem[64] + 68] = _27776 * ext_call.return_data[0] - _6412 / s * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length * userList.length
                                            _29215 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_29215 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_29215 + 36 len 28]
                                            mem[64] = _29096 + 164
                                            mem[_29096 + 100] = 32
                                            mem[_29096 + 132] = 'SafeERC20: low-level call failed'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 'Address: insufficient balance for call'
                                            if not ext_code.size(address(cd[36])):
                                                revert with 0, 'Address: call to non-contract'
                                            _31207 = mem[_29215]
                                            s = 0
                                            while s < _31207:
                                                mem[s + _29096 + 164] = mem[s + _29215 + 32]
                                                s = s + 32
                                                continue 
                                            if ceil32(_31207) > _31207:
                                                mem[_31207 + _29096 + 164] = 0
                                            call address(cd[36]).mem[_29096 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_29096 + 168 len _31207 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_29096 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29096 + 168] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29096 + 232] = mem[idx + _29096 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29096 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _29096 + ceil32(return_data.size) + 165
                                                mem[_29096 + 164] = return_data.size
                                                mem[_29096 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_29096 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_29096 + ceil32(return_data.size) + 169] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _29096 + ceil32(return_data.size) + 233] = mem[idx + _29096 + 132]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_29096 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_29096 + 196] == bool(mem[_29096 + 196])
                                                    if not mem[_29096 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64] + 4] = this.address
                                        staticcall address(cd[36]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27285 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _27568 = mem[_27285]
                                        _27816 = mem[64]
                                        mem[mem[64] + 36] = address(treasuryAddress)
                                        mem[mem[64] + 68] = _27568
                                        _27871 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                        mem[64] = mem[64] + 164
                                        mem[_27816 + 100] = 32
                                        mem[_27816 + 132] = 'SafeERC20: low-level call failed'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 'Address: insufficient balance for call'
                                        if not ext_code.size(address(cd[36])):
                                            revert with 0, 'Address: call to non-contract'
                                        _29878 = mem[_27871]
                                        mem[_27816 + 164 len ceil32(mem[_27871])] = mem[_27871 + 32 len ceil32(mem[_27871])]
                                        var88001 = ceil32(_29878)
                                        if ceil32(_29878) > _29878:
                                            mem[_29878 + _27816 + 164] = 0
                                        call address(cd[36]) with:
                                             gas gas_remaining wei
                                            args mem[_27816 + 168 len _29878 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[_27816 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                var101001 = 32
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_27816 + 196] == bool(mem[_27816 + 196])
                                                if not mem[_27816 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}



}

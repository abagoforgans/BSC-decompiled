contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#  - _fallback()
#
address _owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
mapping of uint8 stor6;
array of address stor7;
array of struct stor8;
array of struct stor9;
uint8 decimals;
address stor11;
uint256 stor14;
uint256 totalSupply;
uint256 stor16;
uint256 totalFees;
uint256 totalBurn;
uint256 totalLiquidityPool;
uint256 _TAX_FEE;
uint256 _BURN_FEE;
uint256 sub_a55d4d5c;
uint256 stor23;
uint256 stor24;
uint256 stor25;
uint256 stor26;
mapping of uint8 stor27;
mapping of uint8 stor28;
mapping of uint8 stor29;
mapping of uint8 stor30;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;

function totalFees() {
    return totalFees
}

function sub_17289346(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor29[address(arg1)])
}

function totalSupply() {
    return totalSupply
}

function totalLiquidityPool() {
    return totalLiquidityPool
}

function decimals() {
    return decimals
}

function totalBurn() {
    return totalBurn
}

function sub_5e8a6142(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    return bool(stor27[address(arg1)])
}

function _BURN_FEE() {
    return _BURN_FEE
}

function owner() {
    return _owner
}

function sub_a55d4d5c(?) {
    return sub_a55d4d5c
}

function _owner() {
    return _owner
}

function _TAX_FEE() {
    return _TAX_FEE
}

function isExcludedSender(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor6[address(arg1)])
}

function sub_c5bafd3e(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    return bool(stor28[address(arg1)])
}

function isExcluded(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function sub_e8466975(?) {
    require calldata.size - 4 >= 32
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    stor26 = arg1
}

function renounceOwnership() {
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(_owner, 0);
    _owner = 0
}

function setAsLiquidityPoolAccount(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    stor11 = arg1
}

function sub_03d47d22(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not arg2:
        stor28[address(arg1)] = 0
    else:
        stor28[address(arg1)] = uint8(bool(arg2))
}

function sub_3ed74db2(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not arg2:
        stor27[address(arg1)] = 0
    else:
        stor27[address(arg1)] = uint8(bool(arg2))
}

function sub_bc4e3fb8(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not arg2:
        stor29[address(arg1)] = 0
    else:
        stor29[address(arg1)] = uint8(bool(arg2))
}

function sub_cdc74829(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not arg2:
        stor30[address(arg1)] = 0
    else:
        stor30[address(arg1)] = uint8(bool(arg2))
}

function sub_c7b7b1f0(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if stor6[address(arg1)]:
        revert with 0, 'Account is already excluded'
    stor6[address(arg1)] = 1
    stor7.length++
    stor7[stor7.length] = address(arg1)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(_owner, arg1);
    _owner = arg1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function sub_9c7a0552(?) {
    require calldata.size - 4 >= 96
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    require arg1 < 100
    require arg2 < 100
    require arg3 < 100
    if arg1 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _TAX_FEE = 100 * arg1
    if arg2 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _BURN_FEE = 100 * arg2
    if arg3 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    sub_a55d4d5c = 100 * arg3
    stor23 = _TAX_FEE
    stor24 = _BURN_FEE
    stor25 = 100 * arg3
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 39, 0xfe544f4b454e32303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[167 len 25] >> 56, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function sub_b1a23d9a(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == address(arg3)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not address(arg1):
        call address(arg3) with:
           value arg2 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        call address(arg1).0xa9059cbb with:
             gas gas_remaining wei
            args address(arg3), arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function sub_de6490d9(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not stor6[address(arg1)]:
        revert with 0, 'Account is already included'
    idx = 0
    while idx < stor7.length:
        mem[0] = 7
        if stor7[idx] != address(arg1):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor7.length < 1:
            revert with 0, 17
        if stor7.length - 1 >= stor7.length:
            revert with 0, 50
        if idx >= stor7.length:
            revert with 0, 50
        stor7[idx] = stor7[stor7.length]
        stor6[address(arg1)] = 0
        if not stor7.length:
            revert with 0, 49
        stor7[stor7.length] = 0
        stor7.length--
}

function sub_3eb1117f(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already included'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != address(arg1):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor5.length < 1:
            revert with 0, 17
        if stor5.length - 1 >= stor5.length:
            revert with 0, 50
        if idx >= stor5.length:
            revert with 0, 50
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor5.length:
            revert with 0, 49
        stor5[stor5.length] = 0
        stor5.length--
}

function name() {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function symbol() {
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor9.length):
                if 31 < uint255(stor9.length) * 0.5:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor9.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        else:
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 0, 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        mem[ceil32(uint255(stor9.length) * 0.5) + 192 len ceil32(uint255(stor9.length) * 0.5)] = mem[128 len ceil32(uint255(stor9.length) * 0.5)]
        if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
            mem[ceil32(uint255(stor9.length) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
    if bool(stor9.length) == stor9.length.field_1 < 32:
        revert with 0, 34
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor9.length):
            if 31 < uint255(stor9.length) * 0.5:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while (uint255(stor9.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    else:
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 0, 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
    if ceil32(stor9.length.field_1) > stor9.length.field_1:
        mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if arg1 > stor16:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (arg1 / stor16 / totalSupply)
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _117 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (arg1 / stor16 / totalSupply)
            _133 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _133 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_133 + 94] = 0
            revert with memory
              from mem[64]
               len _133 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _97 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _127 = mem[64]
        mem[64] = mem[64] + 64
        mem[_127] = 30
        mem[_127 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _132 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _132 + 68] = mem[idx + _127 + 32]
            idx = idx + 32
            continue 
        mem[_132 + 98] = 0
        revert with memory
          from mem[64]
           len _132 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor16 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor16 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor16:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_122] = 26
            mem[_122 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (stor1[address(arg1)] / stor16 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (stor1[address(arg1)] / stor16 / totalSupply)
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _138 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 94] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _102 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _132 = mem[64]
        mem[64] = mem[64] + 64
        mem[_132] = 30
        mem[_132 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _137 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _137 + 68] = mem[idx + _132 + 32]
            idx = idx + 32
            continue 
        mem[_137 + 98] = 0
        revert with memory
          from mem[64]
           len _137 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor16 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor16 / totalSupply)
}

function sub_85a92242(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor11 != msg.sender:
        revert with 0, 'Caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = address(arg1)
        mem[32] = 1
        if stor1[address(arg1)] > stor16:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor16
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor16 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor16 / totalSupply
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = address(arg1)
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _134 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _111 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor16 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor16 / totalSupply
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = address(arg1)
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _105 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _135 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor16 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor16 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor16 / totalSupply
    stor4[address(arg1)] = 1
    stor5.length++
    stor36B6[stor5.length] = address(arg1)
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not stor14:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0 / stor14 / 100:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (0 / stor14 / 100) < 0 / stor14 / 100:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 > arg1 - (2 * 0 / stor14 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (2 * 0 / stor14 / 100) < 0 / stor14 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _19034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19034] = 26
                            mem[_19034 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _19112 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19112 + 68] = mem[idx + _19034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19112 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _19112 + -mem[64] + 100
                            if not arg1:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20230] = 30
                                    mem[_20230 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20480 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20480 + 68] = mem[idx + _20230 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20480 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20480 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21484 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21484] = 30
                                    mem[_21484 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _21999 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21999 + 68] = mem[idx + _21484 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21999 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21999 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24447] = 30
                                    mem[_24447 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                    _25493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25493 + 68] = mem[idx + _24447 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25493 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25493 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20992 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20992] = 30
                                    mem[_20992 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _21483 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21483 + 68] = mem[idx + _20992 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21483 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21483 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _23517 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23517] = 30
                                    mem[_23517 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _24446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24446 + 68] = mem[idx + _23517 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24446 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24446 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _27795 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27795] = 30
                                    mem[_27795 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                        if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                            revert with 0, 17
                                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                    _29026 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29026 + 68] = mem[idx + _27795 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29026 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29026 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _22696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22696] = 30
                                mem[_22696 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _23516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23516 + 68] = mem[idx + _22696 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23516 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23516 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _26558 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26558] = 30
                                mem[_26558 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _27794 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27794 + 68] = mem[idx + _26558 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27794 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27794 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _31394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31394] = 30
                                mem[_31394 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _32570 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32570 + 68] = mem[idx + _31394 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32570 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32570 + -mem[64] + 100
                            if arg1 and stor16 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20228 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20228] = 30
                                mem[_20228 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20479 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20479 + 68] = mem[idx + _20228 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20479 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20479 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21481] = 30
                                mem[_21481 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21997 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21997 + 68] = mem[idx + _21481 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21997 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21997 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24444] = 30
                                mem[_24444 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25492 + 68] = mem[idx + _24444 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25492 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25492 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20991 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20991] = 30
                                mem[_20991 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21480 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21480 + 68] = mem[idx + _20991 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21480 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21480 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23514] = 30
                                mem[_23514 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24443 + 68] = mem[idx + _23514 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24443 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24443 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27792 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27792] = 30
                                mem[_27792 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _29024 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29024 + 68] = mem[idx + _27792 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29024 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29024 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _22695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22695] = 30
                                mem[_22695 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _23513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23513 + 68] = mem[idx + _22695 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23513 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23513 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _26556 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26556] = 30
                                mem[_26556 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _27791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27791 + 68] = mem[idx + _26556 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27791 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _31391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31391] = 30
                                mem[_31391 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _32568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32568 + 68] = mem[idx + _31391 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32568 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32568 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25491] = 30
                            mem[_25491 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _26555 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26555 + 68] = mem[idx + _25491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26555 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26555 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _30161 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30161] = 30
                            mem[_30161 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _31390 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31390 + 68] = mem[idx + _30161 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31390 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _31390 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _34391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34391] = 30
                            mem[_34391 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _35256 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35256 + 68] = mem[idx + _34391 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35256 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _35256 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _19113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19113] = 30
                            mem[_19113 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _19193 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19193 + 68] = mem[idx + _19113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19193 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19193 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _19546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19546] = 30
                            mem[_19546 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _19594 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19594 + 68] = mem[idx + _19546 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19594 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19594 + -mem[64] + 100
                        _19114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19114] = 26
                        mem[_19114 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19194 + 68] = mem[idx + _19114 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19194 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19194 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20484] = 30
                                mem[_20484 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20663 + 68] = mem[idx + _20484 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20663 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20663 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22005 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22005] = 30
                                mem[_22005 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22699 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22699 + 68] = mem[idx + _22005 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22699 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22699 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25499] = 30
                                mem[_25499 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _26562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26562 + 68] = mem[idx + _25499 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26562 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26562 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21488 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21488] = 30
                                mem[_21488 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22004 + 68] = mem[idx + _21488 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22004 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22004 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _24453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24453] = 30
                                mem[_24453 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _25498 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25498 + 68] = mem[idx + _24453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25498 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25498 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _29032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29032] = 30
                                mem[_29032 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _30165 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30165 + 68] = mem[idx + _29032 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30165 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _30165 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23520] = 30
                            mem[_23520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _24452 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24452 + 68] = mem[idx + _23520 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24452 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24452 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27801] = 30
                            mem[_27801 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _29031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29031 + 68] = mem[idx + _27801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29031 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29031 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _32576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32576] = 30
                            mem[_32576 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _33445 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33445 + 68] = mem[idx + _32576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33445 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33445 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20482] = 30
                            mem[_20482 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20662 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20662 + 68] = mem[idx + _20482 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20662 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20662 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _22002 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22002] = 30
                            mem[_22002 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22697 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22697 + 68] = mem[idx + _22002 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22697 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22697 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25496 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25496] = 30
                            mem[_25496 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26561 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26561 + 68] = mem[idx + _25496 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26561 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26561 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21487] = 30
                            mem[_21487 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22001 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22001 + 68] = mem[idx + _21487 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22001 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22001 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24450] = 30
                            mem[_24450 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25495 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25495 + 68] = mem[idx + _24450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25495 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25495 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29029 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29029] = 30
                            mem[_29029 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30163 + 68] = mem[idx + _29029 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30163 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30163 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _23519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23519] = 30
                            mem[_23519 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _24449 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24449 + 68] = mem[idx + _23519 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24449 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24449 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27799] = 30
                            mem[_27799 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _29028 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29028 + 68] = mem[idx + _27799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29028 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29028 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _32573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32573] = 30
                            mem[_32573 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _33443 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33443 + 68] = mem[idx + _32573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33443 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33443 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _26560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26560] = 30
                        mem[_26560 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _27798 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27798 + 68] = mem[idx + _26560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27798 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27798 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31397] = 30
                        mem[_31397 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _32572 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32572 + 68] = mem[idx + _31397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32572 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32572 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _35259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35259] = 30
                        mem[_35259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _35740 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35740 + 68] = mem[idx + _35259 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35740 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35740 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * t / s)
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            return 0
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 and sub_a55d4d5c > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (2 * 0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19033] = 26
                        mem[_19033 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19109 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19109 + 68] = mem[idx + _19033 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19109 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19109 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20222 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20222] = 30
                                mem[_20222 + 32] = 'SafeMath: subtraction overflow'
                                _21468 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21468] = 30
                                mem[_21468 + 32] = 'SafeMath: subtraction overflow'
                                _24422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24422] = 30
                                mem[_24422 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                                _25476 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25476 + 68] = mem[idx + _24422 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25476 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25476 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20221 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20221] = 30
                                    mem[_20221 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20473 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20473 + 68] = mem[idx + _20221 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20473 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20473 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21466] = 30
                                    mem[_21466 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _21986 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21986 + 68] = mem[idx + _21466 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21986 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21986 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24420] = 30
                                    mem[_24420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                    _25475 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25475 + 68] = mem[idx + _24420 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25475 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25475 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20981] = 30
                                mem[_20981 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21465 + 68] = mem[idx + _20981 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21465 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21465 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23496] = 30
                                mem[_23496 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24419 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24419 + 68] = mem[idx + _23496 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24419 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24419 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27767 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27767] = 30
                                mem[_27767 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                                _29003 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29003 + 68] = mem[idx + _27767 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29003 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29003 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20980 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20980] = 30
                                mem[_20980 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21464 + 68] = mem[idx + _20980 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21464 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21464 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23494] = 30
                                mem[_23494 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24418 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24418 + 68] = mem[idx + _23494 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24418 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24418 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27765] = 30
                                mem[_27765 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _29002 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29002 + 68] = mem[idx + _27765 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29002 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29002 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22683] = 30
                            mem[_22683 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23493 + 68] = mem[idx + _22683 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23493 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23493 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26537 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26537] = 30
                            mem[_26537 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _27764 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27764 + 68] = mem[idx + _26537 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27764 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27764 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31370 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31370] = 30
                            mem[_31370 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _32547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32547 + 68] = mem[idx + _31370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32547 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20219 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20219] = 30
                                mem[_20219 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20472 + 68] = mem[idx + _20219 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20472 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21462 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21462] = 30
                                mem[_21462 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21984 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21984 + 68] = mem[idx + _21462 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21984 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21984 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24416] = 30
                                mem[_24416 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25474 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25474 + 68] = mem[idx + _24416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25474 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25474 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20979 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20979] = 30
                            mem[_20979 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21461 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21461 + 68] = mem[idx + _20979 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21461 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21461 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23491] = 30
                            mem[_23491 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _24415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24415 + 68] = mem[idx + _23491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24415 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24415 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27762] = 30
                            mem[_27762 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _29000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29000 + 68] = mem[idx + _27762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29000 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29000 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20978] = 30
                                mem[_20978 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21460 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21460 + 68] = mem[idx + _20978 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21460 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21460 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23489] = 30
                                mem[_23489 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24414 + 68] = mem[idx + _23489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24414 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24414 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27760] = 30
                                mem[_27760 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28999 + 68] = mem[idx + _27760 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28999 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28999 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22682] = 30
                            mem[_22682 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23488 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23488 + 68] = mem[idx + _22682 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23488 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23488 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26535 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26535] = 30
                            mem[_26535 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _27759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27759 + 68] = mem[idx + _26535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27759 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27759 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31367] = 30
                            mem[_31367 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _32544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32544 + 68] = mem[idx + _31367 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32544 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _22681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22681] = 30
                            mem[_22681 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23487 + 68] = mem[idx + _22681 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23487 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23487 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26533] = 30
                            mem[_26533 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _27758 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27758 + 68] = mem[idx + _26533 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27758 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27758 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31365 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31365] = 30
                            mem[_31365 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32543 + 68] = mem[idx + _31365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32543 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25473] = 30
                        mem[_25473 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26532 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26532 + 68] = mem[idx + _25473 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26532 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26532 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30142] = 30
                        mem[_30142 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31364 + 68] = mem[idx + _30142 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31364 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34371 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34371] = 30
                        mem[_34371 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _35238 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35238 + 68] = mem[idx + _34371 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35238 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35238 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19110] = 30
                        mem[_19110 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19190 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19190 + 68] = mem[idx + _19110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19190 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19190 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19543 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19543] = 30
                        mem[_19543 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19591 + 68] = mem[idx + _19543 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19591 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19591 + -mem[64] + 100
                    _19111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19111] = 26
                    mem[_19111 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19191 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19191 + 68] = mem[idx + _19111 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19191 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19191 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20478 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20478] = 30
                            mem[_20478 + 32] = 'SafeMath: subtraction overflow'
                            _21996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21996] = 30
                            mem[_21996 + 32] = 'SafeMath: subtraction overflow'
                            _25486 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25486] = 30
                            mem[_25486 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                            _26542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26542 + 68] = mem[idx + _25486 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26542 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26542 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20477] = 30
                                mem[_20477 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20660 + 68] = mem[idx + _20477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20660 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20660 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21994] = 30
                                mem[_21994 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22687 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22687 + 68] = mem[idx + _21994 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22687 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22687 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25484] = 30
                                mem[_25484 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _26541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26541 + 68] = mem[idx + _25484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26541 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26541 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21473 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21473] = 30
                            mem[_21473 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21993 + 68] = mem[idx + _21473 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21993 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21993 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24432] = 30
                            mem[_24432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25483 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25483 + 68] = mem[idx + _24432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25483 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25483 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29015 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29015] = 30
                            mem[_29015 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _30148 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30148 + 68] = mem[idx + _29015 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30148 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30148 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21472 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21472] = 30
                            mem[_21472 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21992 + 68] = mem[idx + _21472 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21992 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21992 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24430 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24430] = 30
                            mem[_24430 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25482 + 68] = mem[idx + _24430 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25482 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25482 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29013 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29013] = 30
                            mem[_29013 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30147 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30147 + 68] = mem[idx + _29013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30147 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30147 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23500] = 30
                        mem[_23500 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24429 + 68] = mem[idx + _23500 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24429 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24429 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27775] = 30
                        mem[_27775 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _29012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29012 + 68] = mem[idx + _27775 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29012 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29012 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32556] = 30
                        mem[_32556 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _33436 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33436 + 68] = mem[idx + _32556 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33436 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33436 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20475] = 30
                            mem[_20475 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20659 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20659 + 68] = mem[idx + _20475 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20659 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20659 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21990] = 30
                            mem[_21990 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22685 + 68] = mem[idx + _21990 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22685 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22685 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25480] = 30
                            mem[_25480 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26540 + 68] = mem[idx + _25480 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26540 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21471] = 30
                        mem[_21471 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21989 + 68] = mem[idx + _21471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21989 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21989 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24427 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24427] = 30
                        mem[_24427 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _25479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25479 + 68] = mem[idx + _24427 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25479 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _29010 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29010] = 30
                        mem[_29010 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30145 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30145 + 68] = mem[idx + _29010 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30145 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30145 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21470 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21470] = 30
                            mem[_21470 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21988 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21988 + 68] = mem[idx + _21470 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21988 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21988 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24425 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24425] = 30
                            mem[_24425 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25478 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25478 + 68] = mem[idx + _24425 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25478 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25478 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29008] = 30
                            mem[_29008 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30144 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30144 + 68] = mem[idx + _29008 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30144 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30144 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23499] = 30
                        mem[_23499 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24424 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24424 + 68] = mem[idx + _23499 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24424 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24424 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27773] = 30
                        mem[_27773 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29007 + 68] = mem[idx + _27773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29007 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29007 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32553] = 30
                        mem[_32553 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _33433 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33433 + 68] = mem[idx + _32553 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33433 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33433 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _23498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23498] = 30
                        mem[_23498 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24423 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24423 + 68] = mem[idx + _23498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24423 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24423 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27771] = 30
                        mem[_27771 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29006 + 68] = mem[idx + _27771 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29006 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29006 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32551 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32551] = 30
                        mem[_32551 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33432 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33432 + 68] = mem[idx + _32551 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33432 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33432 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26539 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26539] = 30
                    mem[_26539 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27770 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27770 + 68] = mem[idx + _26539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27770 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27770 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31374 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31374] = 30
                    mem[_31374 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32550 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32550 + 68] = mem[idx + _31374 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32550 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32550 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35242 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35242] = 30
                    mem[_35242 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _35736 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35736 + 68] = mem[idx + _35242 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35736 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35736 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * t / s)
                            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            return 0
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19032 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19032] = 26
                        mem[_19032 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19106 + 68] = mem[idx + _19032 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19106 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19106 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    if not 0 / stor14 / 100:
                                        return 0
                                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20213] = 30
                                    mem[_20213 + 32] = 'SafeMath: subtraction overflow'
                                    _21446 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21446] = 30
                                    mem[_21446 + 32] = 'SafeMath: subtraction overflow'
                                    _24387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24387] = 30
                                    mem[_24387 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                    _25452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25452 + 68] = mem[idx + _24387 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25452 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25452 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20212 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20212] = 30
                                    mem[_20212 + 32] = 'SafeMath: subtraction overflow'
                                    _21445 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21445] = 30
                                    mem[_21445 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _21966 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21966 + 68] = mem[idx + _21445 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21966 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21966 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24385 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24385] = 30
                                    mem[_24385 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                                    _25451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25451 + 68] = mem[idx + _24385 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25451 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25451 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20965 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20965] = 30
                                mem[_20965 + 32] = 'SafeMath: subtraction overflow'
                                _23464 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23464] = 30
                                mem[_23464 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24384 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24384 + 68] = mem[idx + _23464 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24384 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24384 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27726 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27726] = 30
                                mem[_27726 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28971 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28971 + 68] = mem[idx + _27726 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28971 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28971 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20211] = 30
                                    mem[_20211 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20464 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20464 + 68] = mem[idx + _20211 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20464 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20464 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21443] = 30
                                    mem[_21443 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _21965 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21965 + 68] = mem[idx + _21443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21965 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21965 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24382] = 30
                                    mem[_24382 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                    _25450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25450 + 68] = mem[idx + _24382 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25450 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25450 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20964 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20964] = 30
                                mem[_20964 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21442 + 68] = mem[idx + _20964 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21442 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21442 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23462 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23462] = 30
                                mem[_23462 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24381 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24381 + 68] = mem[idx + _23462 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24381 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24381 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27724] = 30
                                mem[_27724 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28969 + 68] = mem[idx + _27724 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28969 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28969 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20963 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20963] = 30
                                mem[_20963 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21441 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21441 + 68] = mem[idx + _20963 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21441 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21441 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23460] = 30
                                mem[_23460 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24380 + 68] = mem[idx + _23460 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24380 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24380 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27722] = 30
                                mem[_27722 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                                _28968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28968 + 68] = mem[idx + _27722 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28968 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22663] = 30
                            mem[_22663 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23459 + 68] = mem[idx + _22663 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23459 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26503] = 30
                            mem[_26503 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _27721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27721 + 68] = mem[idx + _26503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27721 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31333] = 30
                            mem[_31333 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32512 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32512 + 68] = mem[idx + _31333 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32512 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32512 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20209] = 30
                                    mem[_20209 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20463 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20463 + 68] = mem[idx + _20209 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20463 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20463 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21439] = 30
                                    mem[_21439 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _21963 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21963 + 68] = mem[idx + _21439 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21963 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21963 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24378] = 30
                                    mem[_24378 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25449 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25449 + 68] = mem[idx + _24378 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25449 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25449 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20962 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20962] = 30
                                mem[_20962 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21438 + 68] = mem[idx + _20962 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21438 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21438 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23457] = 30
                                mem[_23457 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24377 + 68] = mem[idx + _23457 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24377 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24377 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27719 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27719] = 30
                                mem[_27719 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28966 + 68] = mem[idx + _27719 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28966 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28966 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20961 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20961] = 30
                                mem[_20961 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21437 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21437 + 68] = mem[idx + _20961 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21437 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21437 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23455 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23455] = 30
                                mem[_23455 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24376 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24376 + 68] = mem[idx + _23455 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24376 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24376 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27717 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27717] = 30
                                mem[_27717 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                                _28965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28965 + 68] = mem[idx + _27717 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28965 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28965 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22662] = 30
                            mem[_22662 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23454 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23454 + 68] = mem[idx + _22662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23454 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23454 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26501] = 30
                            mem[_26501 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27716 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27716 + 68] = mem[idx + _26501 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27716 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27716 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31330] = 30
                            mem[_31330 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32509 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32509 + 68] = mem[idx + _31330 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32509 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32509 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20960 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20960] = 30
                                mem[_20960 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21436 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21436 + 68] = mem[idx + _20960 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21436 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21436 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23452 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23452] = 30
                                mem[_23452 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24375 + 68] = mem[idx + _23452 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24375 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24375 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27714 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27714] = 30
                                mem[_27714 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28964 + 68] = mem[idx + _27714 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28964 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28964 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22661] = 30
                            mem[_22661 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23451 + 68] = mem[idx + _22661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23451 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26499 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26499] = 30
                            mem[_26499 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _27713 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27713 + 68] = mem[idx + _26499 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27713 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27713 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31328] = 30
                            mem[_31328 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32507 + 68] = mem[idx + _31328 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32507 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32507 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22660] = 30
                            mem[_22660 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23450 + 68] = mem[idx + _22660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23450 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23450 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26497 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26497] = 30
                            mem[_26497 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _27712 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27712 + 68] = mem[idx + _26497 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27712 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27712 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31326] = 30
                            mem[_31326 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _32506 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32506 + 68] = mem[idx + _31326 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32506 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32506 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25448] = 30
                        mem[_25448 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26496 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26496 + 68] = mem[idx + _25448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26496 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26496 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30116] = 30
                        mem[_30116 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31325 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31325 + 68] = mem[idx + _30116 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31325 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31325 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34343] = 30
                        mem[_34343 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _35211 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35211 + 68] = mem[idx + _34343 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35211 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35211 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19107] = 30
                        mem[_19107 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19187 + 68] = mem[idx + _19107 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19187 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19540 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19540] = 30
                        mem[_19540 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19588 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19588 + 68] = mem[idx + _19540 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19588 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19588 + -mem[64] + 100
                    _19108 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19108] = 26
                    mem[_19108 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19188 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19188 + 68] = mem[idx + _19108 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19188 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19188 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20471] = 30
                                mem[_20471 + 32] = 'SafeMath: subtraction overflow'
                                _21978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21978] = 30
                                mem[_21978 + 32] = 'SafeMath: subtraction overflow'
                                _25466 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25466] = 30
                                mem[_25466 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _26509 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26509 + 68] = mem[idx + _25466 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26509 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26509 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20470 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20470] = 30
                                mem[_20470 + 32] = 'SafeMath: subtraction overflow'
                                _21977 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21977] = 30
                                mem[_21977 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22669 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22669 + 68] = mem[idx + _21977 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22669 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22669 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25464 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25464] = 30
                                mem[_25464 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                                _26508 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26508 + 68] = mem[idx + _25464 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26508 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26508 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21453] = 30
                            mem[_21453 + 32] = 'SafeMath: subtraction overflow'
                            _24402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24402] = 30
                            mem[_24402 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _25463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25463 + 68] = mem[idx + _24402 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25463 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28988] = 30
                            mem[_28988 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30125 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30125 + 68] = mem[idx + _28988 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30125 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30125 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20469] = 30
                                mem[_20469 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20653 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20653 + 68] = mem[idx + _20469 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20653 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20653 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21975] = 30
                                mem[_21975 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22668 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22668 + 68] = mem[idx + _21975 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22668 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22668 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25461 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25461] = 30
                                mem[_25461 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _26507 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26507 + 68] = mem[idx + _25461 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26507 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26507 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21452] = 30
                            mem[_21452 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21974 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21974 + 68] = mem[idx + _21452 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21974 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21974 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24400 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24400] = 30
                            mem[_24400 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25460 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25460 + 68] = mem[idx + _24400 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25460 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25460 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _28986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28986] = 30
                            mem[_28986 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30123 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30123 + 68] = mem[idx + _28986 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30123 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30123 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21451] = 30
                            mem[_21451 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21973 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21973 + 68] = mem[idx + _21451 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21973 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21973 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24398 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24398] = 30
                            mem[_24398 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25459 + 68] = mem[idx + _24398 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25459 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28984] = 30
                            mem[_28984 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _30122 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30122 + 68] = mem[idx + _28984 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30122 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30122 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23468 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23468] = 30
                        mem[_23468 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24397 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24397 + 68] = mem[idx + _23468 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24397 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24397 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27736] = 30
                        mem[_27736 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _28983 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28983 + 68] = mem[idx + _27736 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28983 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28983 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32524] = 30
                        mem[_32524 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33424 + 68] = mem[idx + _32524 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33424 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33424 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20467 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20467] = 30
                                mem[_20467 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20652 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20652 + 68] = mem[idx + _20467 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20652 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20652 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21971 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21971] = 30
                                mem[_21971 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22666 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22666 + 68] = mem[idx + _21971 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22666 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22666 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25457] = 30
                                mem[_25457 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26506 + 68] = mem[idx + _25457 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26506 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26506 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21450] = 30
                            mem[_21450 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21970 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21970 + 68] = mem[idx + _21450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21970 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21970 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24395 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24395] = 30
                            mem[_24395 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25456 + 68] = mem[idx + _24395 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25456 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _28981 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28981] = 30
                            mem[_28981 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30120 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30120 + 68] = mem[idx + _28981 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30120 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30120 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21449] = 30
                            mem[_21449 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21969 + 68] = mem[idx + _21449 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21969 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21969 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24393 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24393] = 30
                            mem[_24393 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25455 + 68] = mem[idx + _24393 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25455 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28979 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28979] = 30
                            mem[_28979 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _30119 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30119 + 68] = mem[idx + _28979 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30119 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30119 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23467 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23467] = 30
                        mem[_23467 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24392 + 68] = mem[idx + _23467 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24392 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24392 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27734] = 30
                        mem[_27734 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _28978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28978 + 68] = mem[idx + _27734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28978 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28978 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32521 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32521] = 30
                        mem[_32521 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33421 + 68] = mem[idx + _32521 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33421 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _21448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21448] = 30
                            mem[_21448 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21968 + 68] = mem[idx + _21448 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21968 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24390] = 30
                            mem[_24390 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25454 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25454 + 68] = mem[idx + _24390 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25454 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25454 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _28976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28976] = 30
                            mem[_28976 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30118 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30118 + 68] = mem[idx + _28976 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30118 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30118 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23466 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23466] = 30
                        mem[_23466 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24389 + 68] = mem[idx + _23466 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24389 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27732 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27732] = 30
                        mem[_27732 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _28975 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28975 + 68] = mem[idx + _27732 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28975 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28975 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32519 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32519] = 30
                        mem[_32519 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33419 + 68] = mem[idx + _32519 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33419 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33419 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23465] = 30
                        mem[_23465 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24388 + 68] = mem[idx + _23465 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24388 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27730] = 30
                        mem[_27730 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _28974 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28974 + 68] = mem[idx + _27730 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28974 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28974 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32517 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32517] = 30
                        mem[_32517 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _33418 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33418 + 68] = mem[idx + _32517 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33418 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33418 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26505 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26505] = 30
                    mem[_26505 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27729 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27729 + 68] = mem[idx + _26505 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27729 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27729 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31338 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31338] = 30
                    mem[_31338 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32516 + 68] = mem[idx + _31338 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32516 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32516 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35216 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35216] = 30
                    mem[_35216 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _35731 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35731 + 68] = mem[idx + _35216 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35731 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35731 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * t / s)
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s)
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * t / s)
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                return (arg1 * t / s)
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 and sub_a55d4d5c > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 / stor14 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0 / stor14 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (0 / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor16
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19031 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19031] = 26
                    mem[_19031 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19103 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19103 + 68] = mem[idx + _19031 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19103 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19103 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20200] = 30
                                mem[_20200 + 32] = 'SafeMath: subtraction overflow'
                                _21422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21422] = 30
                                mem[_21422 + 32] = 'SafeMath: subtraction overflow'
                                _24344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24344] = 30
                                mem[_24344 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                                _25425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25425 + 68] = mem[idx + _24344 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25425 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25425 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20199] = 30
                                mem[_20199 + 32] = 'SafeMath: subtraction overflow'
                                _21421 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21421] = 30
                                mem[_21421 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21942 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21942 + 68] = mem[idx + _21421 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21942 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21942 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _24342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24342] = 30
                                mem[_24342 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                                _25424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25424 + 68] = mem[idx + _24342 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25424 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25424 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20943 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20943] = 30
                            mem[_20943 + 32] = 'SafeMath: subtraction overflow'
                            _23423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23423] = 30
                            mem[_23423 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _24341 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24341 + 68] = mem[idx + _23423 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24341 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24341 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27672 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27672] = 30
                            mem[_27672 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28934 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28934 + 68] = mem[idx + _27672 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28934 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28934 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20198 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20198] = 30
                                mem[_20198 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20455 + 68] = mem[idx + _20198 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20455 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20455 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21419] = 30
                                mem[_21419 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _21941 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21941 + 68] = mem[idx + _21419 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21941 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21941 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24339] = 30
                                mem[_24339 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _25423 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25423 + 68] = mem[idx + _24339 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25423 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25423 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20942] = 30
                            mem[_20942 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21418 + 68] = mem[idx + _20942 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21418 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21418 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23421] = 30
                            mem[_23421 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _24338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24338 + 68] = mem[idx + _23421 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24338 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24338 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27670] = 30
                            mem[_27670 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28932 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28932 + 68] = mem[idx + _27670 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28932 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28932 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20941 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20941] = 30
                            mem[_20941 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _21417 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21417 + 68] = mem[idx + _20941 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21417 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21417 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23419] = 30
                            mem[_23419 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _24337 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24337 + 68] = mem[idx + _23419 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24337 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24337 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27668] = 30
                            mem[_27668 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28931 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28931 + 68] = mem[idx + _27668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28931 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28931 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22638] = 30
                        mem[_22638 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _23418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23418 + 68] = mem[idx + _22638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23418 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23418 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26459] = 30
                        mem[_26459 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _27667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27667 + 68] = mem[idx + _26459 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27667 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27667 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31284 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31284] = 30
                        mem[_31284 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32469 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32469 + 68] = mem[idx + _31284 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32469 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32469 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20196 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20196] = 30
                                mem[_20196 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20454 + 68] = mem[idx + _20196 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20454 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20454 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21415 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21415] = 30
                                mem[_21415 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21939 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21939 + 68] = mem[idx + _21415 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21939 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21939 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24335] = 30
                                mem[_24335 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25422 + 68] = mem[idx + _24335 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25422 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25422 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20940 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20940] = 30
                            mem[_20940 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21414 + 68] = mem[idx + _20940 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21414 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21414 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23416] = 30
                            mem[_23416 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _24334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24334 + 68] = mem[idx + _23416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24334 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27665] = 30
                            mem[_27665 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28929 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28929 + 68] = mem[idx + _27665 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28929 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28929 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20939 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20939] = 30
                            mem[_20939 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21413 + 68] = mem[idx + _20939 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21413 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21413 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23414] = 30
                            mem[_23414 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _24333 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24333 + 68] = mem[idx + _23414 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24333 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24333 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27663] = 30
                            mem[_27663 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28928 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28928 + 68] = mem[idx + _27663 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28928 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28928 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22637 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22637] = 30
                        mem[_22637 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _23413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23413 + 68] = mem[idx + _22637 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23413 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23413 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _26457 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26457] = 30
                        mem[_26457 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _27662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27662 + 68] = mem[idx + _26457 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27662 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27662 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31281] = 30
                        mem[_31281 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32466 + 68] = mem[idx + _31281 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32466 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32466 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20938] = 30
                            mem[_20938 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21412 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21412 + 68] = mem[idx + _20938 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21412 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21412 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23411] = 30
                            mem[_23411 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _24332 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24332 + 68] = mem[idx + _23411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24332 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24332 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _27660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27660] = 30
                            mem[_27660 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28927 + 68] = mem[idx + _27660 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28927 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28927 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22636] = 30
                        mem[_22636 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23410 + 68] = mem[idx + _22636 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23410 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23410 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26455] = 30
                        mem[_26455 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _27659 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27659 + 68] = mem[idx + _26455 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27659 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27659 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _31279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31279] = 30
                        mem[_31279 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32464 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32464 + 68] = mem[idx + _31279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32464 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32464 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _22635 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22635] = 30
                        mem[_22635 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23409 + 68] = mem[idx + _22635 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23409 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26453] = 30
                        mem[_26453 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _27658 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27658 + 68] = mem[idx + _26453 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27658 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27658 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31277] = 30
                        mem[_31277 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _32463 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32463 + 68] = mem[idx + _31277 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32463 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32463 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25421 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25421] = 30
                    mem[_25421 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _26452 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26452 + 68] = mem[idx + _25421 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26452 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26452 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _30086 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30086] = 30
                    mem[_30086 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _31276 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31276 + 68] = mem[idx + _30086 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31276 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31276 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _34309 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34309] = 30
                    mem[_34309 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _35178 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35178 + 68] = mem[idx + _34309 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35178 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35178 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19104] = 30
                    mem[_19104 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19184 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19184 + 68] = mem[idx + _19104 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19184 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19184 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19537 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19537] = 30
                    mem[_19537 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19585 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19585 + 68] = mem[idx + _19537 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19585 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19585 + -mem[64] + 100
                _19105 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19105] = 26
                mem[_19105 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19185 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19185 + 68] = mem[idx + _19105 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19185 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19185 + -mem[64] + 100
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20462 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20462] = 30
                            mem[_20462 + 32] = 'SafeMath: subtraction overflow'
                            _21954 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21954] = 30
                            mem[_21954 + 32] = 'SafeMath: subtraction overflow'
                            _25439 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25439] = 30
                            mem[_25439 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                            _26465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26465 + 68] = mem[idx + _25439 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26465 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26465 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20461] = 30
                            mem[_20461 + 32] = 'SafeMath: subtraction overflow'
                            _21953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21953] = 30
                            mem[_21953 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22644 + 68] = mem[idx + _21953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22644 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22644 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _25437 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25437] = 30
                            mem[_25437 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                            _26464 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26464 + 68] = mem[idx + _25437 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26464 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26464 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21429] = 30
                        mem[_21429 + 32] = 'SafeMath: subtraction overflow'
                        _24359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24359] = 30
                        mem[_24359 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _25436 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25436 + 68] = mem[idx + _24359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25436 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25436 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28951] = 30
                        mem[_28951 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30095 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30095 + 68] = mem[idx + _28951 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30095 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30095 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20460 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20460] = 30
                            mem[_20460 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _20645 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20645 + 68] = mem[idx + _20460 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20645 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20645 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _21951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21951] = 30
                            mem[_21951 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _22643 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22643 + 68] = mem[idx + _21951 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22643 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22643 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25434] = 30
                            mem[_25434 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                            _26463 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26463 + 68] = mem[idx + _25434 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26463 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26463 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21428] = 30
                        mem[_21428 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _21950 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21950 + 68] = mem[idx + _21428 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21950 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21950 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24357] = 30
                        mem[_24357 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _25433 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25433 + 68] = mem[idx + _24357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25433 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25433 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28949] = 30
                        mem[_28949 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30093 + 68] = mem[idx + _28949 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30093 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21427 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21427] = 30
                        mem[_21427 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _21949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21949 + 68] = mem[idx + _21427 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21949 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21949 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24355 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24355] = 30
                        mem[_24355 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _25432 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25432 + 68] = mem[idx + _24355 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25432 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25432 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28947 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28947] = 30
                        mem[_28947 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30092 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30092 + 68] = mem[idx + _28947 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30092 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30092 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23427] = 30
                    mem[_23427 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        _24354 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24354 + 68] = mem[idx + _23427 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24354 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24354 + -mem[64] + 100
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27682 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27682] = 30
                    mem[_27682 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        _28946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28946 + 68] = mem[idx + _27682 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28946 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28946 + -mem[64] + 100
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32481 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32481] = 30
                    mem[_32481 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33410 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33410 + 68] = mem[idx + _32481 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33410 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33410 + -mem[64] + 100
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20458] = 30
                            mem[_20458 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20644 + 68] = mem[idx + _20458 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20644 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20644 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21947] = 30
                            mem[_21947 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22641 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22641 + 68] = mem[idx + _21947 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22641 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22641 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25430 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25430] = 30
                            mem[_25430 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26462 + 68] = mem[idx + _25430 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26462 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26462 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21426] = 30
                        mem[_21426 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21946 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21946 + 68] = mem[idx + _21426 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21946 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21946 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24352] = 30
                        mem[_24352 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _25429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25429 + 68] = mem[idx + _24352 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25429 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25429 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28944 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28944] = 30
                        mem[_28944 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30090 + 68] = mem[idx + _28944 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30090 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30090 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21425] = 30
                        mem[_21425 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21945 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21945 + 68] = mem[idx + _21425 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21945 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21945 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24350 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24350] = 30
                        mem[_24350 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _25428 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25428 + 68] = mem[idx + _24350 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25428 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25428 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28942] = 30
                        mem[_28942 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30089 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30089 + 68] = mem[idx + _28942 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30089 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30089 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23426 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23426] = 30
                    mem[_23426 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _24349 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24349 + 68] = mem[idx + _23426 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24349 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24349 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _27680 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27680] = 30
                    mem[_27680 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28941 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28941 + 68] = mem[idx + _27680 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28941 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28941 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32478] = 30
                    mem[_32478 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33407 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33407 + 68] = mem[idx + _32478 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33407 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33407 + -mem[64] + 100
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21424] = 30
                        mem[_21424 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _21944 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21944 + 68] = mem[idx + _21424 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21944 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21944 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24347 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24347] = 30
                        mem[_24347 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _25427 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25427 + 68] = mem[idx + _24347 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25427 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25427 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _28939 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28939] = 30
                        mem[_28939 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30088 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30088 + 68] = mem[idx + _28939 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30088 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30088 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23425 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23425] = 30
                    mem[_23425 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24346 + 68] = mem[idx + _23425 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24346 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24346 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27678] = 30
                    mem[_27678 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _28938 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28938 + 68] = mem[idx + _27678 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28938 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28938 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    _32476 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32476] = 30
                    mem[_32476 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33405 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33405 + 68] = mem[idx + _32476 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33405 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33405 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _23424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23424] = 30
                    mem[_23424 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24345 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24345 + 68] = mem[idx + _23424 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24345 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24345 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27676 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27676] = 30
                    mem[_27676 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _28937 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28937 + 68] = mem[idx + _27676 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28937 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28937 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32474] = 30
                    mem[_32474 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    _33404 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33404 + 68] = mem[idx + _32474 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33404 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33404 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26461 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26461] = 30
                mem[_26461 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _27675 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27675 + 68] = mem[idx + _26461 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27675 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27675 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _31289 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31289] = 30
                mem[_31289 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    _32473 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32473 + 68] = mem[idx + _31289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32473 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32473 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _35183 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35183] = 30
                mem[_35183 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _35726 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35726 + 68] = mem[idx + _35183 + 32]
                    idx = idx + 32
                    continue 
                mem[_35726 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35726 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor16 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            return 0
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor14 / 100:
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                revert with 0, 17
            if not 0 / stor14 / 100:
                revert with 0, 18
            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor14:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19030] = 26
                        mem[_19030 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19100 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19100 + 68] = mem[idx + _19030 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19100 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19100 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20188] = 30
                                    mem[_20188 + 32] = 'SafeMath: subtraction overflow'
                                    _21400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21400] = 30
                                    mem[_21400 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _21921 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21921 + 68] = mem[idx + _21400 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21921 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21921 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24305] = 30
                                    mem[_24305 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                    _25401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25401 + 68] = mem[idx + _24305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25401 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25401 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20923] = 30
                                mem[_20923 + 32] = 'SafeMath: subtraction overflow'
                                _23383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23383] = 30
                                mem[_23383 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24304 + 68] = mem[idx + _23383 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24304 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24304 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27620] = 30
                                mem[_27620 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28903 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28903 + 68] = mem[idx + _27620 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28903 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28903 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20187 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20187] = 30
                                mem[_20187 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20447 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20447 + 68] = mem[idx + _20187 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20447 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20447 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21398] = 30
                                mem[_21398 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _21920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21920 + 68] = mem[idx + _21398 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21920 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21920 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24302] = 30
                                mem[_24302 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                                _25400 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25400 + 68] = mem[idx + _24302 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25400 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25400 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20922 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20922] = 30
                                mem[_20922 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21397 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21397 + 68] = mem[idx + _20922 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21397 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21397 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23381] = 30
                                mem[_23381 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24301 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24301 + 68] = mem[idx + _23381 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24301 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24301 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27618] = 30
                                mem[_27618 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28901 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28901 + 68] = mem[idx + _27618 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28901 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28901 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22614] = 30
                            mem[_22614 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _23380 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23380 + 68] = mem[idx + _22614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23380 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23380 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26416] = 30
                            mem[_26416 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _27617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27617 + 68] = mem[idx + _26416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27617 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31236] = 30
                            mem[_31236 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32430 + 68] = mem[idx + _31236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32430 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32430 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20185] = 30
                                mem[_20185 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20446 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20446 + 68] = mem[idx + _20185 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20446 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20446 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21395] = 30
                                mem[_21395 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21918 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21918 + 68] = mem[idx + _21395 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21918 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21918 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24299 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24299] = 30
                                mem[_24299 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25399 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25399 + 68] = mem[idx + _24299 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25399 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25399 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20921 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20921] = 30
                                mem[_20921 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21394 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21394 + 68] = mem[idx + _20921 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21394 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21394 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23378] = 30
                                mem[_23378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24298 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24298 + 68] = mem[idx + _23378 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24298 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24298 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27615] = 30
                                mem[_27615 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                                _28899 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28899 + 68] = mem[idx + _27615 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28899 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28899 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22613] = 30
                            mem[_22613 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23377 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23377 + 68] = mem[idx + _22613 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23377 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23377 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26414] = 30
                            mem[_26414 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27614 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27614 + 68] = mem[idx + _26414 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27614 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27614 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31233 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31233] = 30
                            mem[_31233 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32428 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32428 + 68] = mem[idx + _31233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32428 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32428 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20920 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20920] = 30
                            mem[_20920 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21393 + 68] = mem[idx + _20920 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21393 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21393 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23375] = 30
                            mem[_23375 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _24297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24297 + 68] = mem[idx + _23375 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24297 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24297 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _27612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27612] = 30
                            mem[_27612 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28898 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28898 + 68] = mem[idx + _27612 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28898 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28898 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22612] = 30
                            mem[_22612 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23374 + 68] = mem[idx + _22612 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23374 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26412] = 30
                            mem[_26412 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27611 + 68] = mem[idx + _26412 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27611 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27611 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31231] = 30
                            mem[_31231 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _32426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32426 + 68] = mem[idx + _31231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32426 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32426 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25398 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25398] = 30
                        mem[_25398 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26411 + 68] = mem[idx + _25398 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26411 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26411 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30059] = 30
                        mem[_30059 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _31230 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31230 + 68] = mem[idx + _30059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31230 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31230 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34277] = 30
                        mem[_34277 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _35148 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35148 + 68] = mem[idx + _34277 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35148 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35148 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19101 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19101] = 30
                        mem[_19101 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19181 + 68] = mem[idx + _19101 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19181 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19181 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19534] = 30
                        mem[_19534 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19582 + 68] = mem[idx + _19534 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19582 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19582 + -mem[64] + 100
                    _19102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19102] = 26
                    mem[_19102 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19182 + 68] = mem[idx + _19102 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19182 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19182 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20453] = 30
                                mem[_20453 + 32] = 'SafeMath: subtraction overflow'
                                _21930 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21930] = 30
                                mem[_21930 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22619 + 68] = mem[idx + _21930 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22619 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22619 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25411] = 30
                                mem[_25411 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _26421 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26421 + 68] = mem[idx + _25411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26421 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26421 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21405] = 30
                            mem[_21405 + 32] = 'SafeMath: subtraction overflow'
                            _24316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24316] = 30
                            mem[_24316 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _25410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25410 + 68] = mem[idx + _24316 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25410 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25410 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28914] = 30
                            mem[_28914 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30066 + 68] = mem[idx + _28914 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30066 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30066 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20452] = 30
                            mem[_20452 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _20637 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20637 + 68] = mem[idx + _20452 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20637 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20637 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _21928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21928] = 30
                            mem[_21928 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _22618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22618 + 68] = mem[idx + _21928 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22618 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22618 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25408] = 30
                            mem[_25408 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                            _26420 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26420 + 68] = mem[idx + _25408 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26420 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26420 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21404 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21404] = 30
                            mem[_21404 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21927 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21927 + 68] = mem[idx + _21404 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21927 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21927 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24314] = 30
                            mem[_24314 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25407 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25407 + 68] = mem[idx + _24314 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25407 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25407 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28912 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28912] = 30
                            mem[_28912 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30064 + 68] = mem[idx + _28912 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30064 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30064 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23386] = 30
                        mem[_23386 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24313 + 68] = mem[idx + _23386 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24313 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24313 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27628 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27628] = 30
                        mem[_27628 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _28911 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28911 + 68] = mem[idx + _27628 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28911 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28911 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32439] = 30
                        mem[_32439 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33397 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33397 + 68] = mem[idx + _32439 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33397 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33397 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _20450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20450] = 30
                            mem[_20450 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20636 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20636 + 68] = mem[idx + _20450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20636 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20636 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21925 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21925] = 30
                            mem[_21925 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22616 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22616 + 68] = mem[idx + _21925 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22616 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22616 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25405] = 30
                            mem[_25405 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26419 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26419 + 68] = mem[idx + _25405 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26419 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26419 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21403] = 30
                            mem[_21403 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21924 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21924 + 68] = mem[idx + _21403 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21924 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21924 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24311] = 30
                            mem[_24311 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25404 + 68] = mem[idx + _24311 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25404 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25404 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _28909 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28909] = 30
                            mem[_28909 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _30062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30062 + 68] = mem[idx + _28909 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30062 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30062 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23385] = 30
                        mem[_23385 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24310 + 68] = mem[idx + _23385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24310 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27626 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27626] = 30
                        mem[_27626 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _28908 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28908 + 68] = mem[idx + _27626 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28908 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28908 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32436] = 30
                        mem[_32436 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33395 + 68] = mem[idx + _32436 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33395 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33395 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _21402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21402] = 30
                        mem[_21402 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _21923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21923 + 68] = mem[idx + _21402 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21923 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24308] = 30
                        mem[_24308 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _25403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25403 + 68] = mem[idx + _24308 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25403 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25403 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _28906 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28906] = 30
                        mem[_28906 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30061 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30061 + 68] = mem[idx + _28906 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30061 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30061 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23384] = 30
                        mem[_23384 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24307 + 68] = mem[idx + _23384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24307 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24307 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27624 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27624] = 30
                        mem[_27624 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _28905 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28905 + 68] = mem[idx + _27624 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28905 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28905 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32434 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32434] = 30
                        mem[_32434 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _33393 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33393 + 68] = mem[idx + _32434 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33393 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33393 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26418] = 30
                    mem[_26418 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27623 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27623 + 68] = mem[idx + _26418 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27623 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27623 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31240 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31240] = 30
                    mem[_31240 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _32433 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32433 + 68] = mem[idx + _31240 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32433 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32433 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35152 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35152] = 30
                    mem[_35152 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _35722 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35722 + 68] = mem[idx + _35152 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35722 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35722 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * t / s)
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            return 0
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 and sub_a55d4d5c > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < 0 / stor14 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor16
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19029] = 26
                    mem[_19029 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19097 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19097 + 68] = mem[idx + _19029 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19097 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19097 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20176 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20176] = 30
                                mem[_20176 + 32] = 'SafeMath: subtraction overflow'
                                _21379 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21379] = 30
                                mem[_21379 + 32] = 'SafeMath: subtraction overflow'
                                _24268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24268] = 30
                                mem[_24268 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                                _25377 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25377 + 68] = mem[idx + _24268 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25377 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25377 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20175] = 30
                                mem[_20175 + 32] = 'SafeMath: subtraction overflow'
                                _21378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21378] = 30
                                mem[_21378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21902 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21902 + 68] = mem[idx + _21378 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21902 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21902 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _24266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24266] = 30
                                mem[_24266 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _25376 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25376 + 68] = mem[idx + _24266 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25376 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25376 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20905] = 30
                            mem[_20905 + 32] = 'SafeMath: subtraction overflow'
                            _23353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23353] = 30
                            mem[_23353 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _24265 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24265 + 68] = mem[idx + _23353 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24265 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24265 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27577] = 30
                            mem[_27577 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28870 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28870 + 68] = mem[idx + _27577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28870 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28870 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20174] = 30
                                mem[_20174 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20438 + 68] = mem[idx + _20174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20438 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20438 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21376] = 30
                                mem[_21376 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _21901 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21901 + 68] = mem[idx + _21376 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21901 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21901 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24263] = 30
                                mem[_24263 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                                _25375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25375 + 68] = mem[idx + _24263 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25375 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25375 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20904] = 30
                            mem[_20904 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21375 + 68] = mem[idx + _20904 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21375 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21375 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23351] = 30
                            mem[_23351 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _24262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24262 + 68] = mem[idx + _23351 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24262 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24262 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27575] = 30
                            mem[_27575 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28868 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28868 + 68] = mem[idx + _27575 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28868 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28868 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20903 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20903] = 30
                            mem[_20903 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21374 + 68] = mem[idx + _20903 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21374 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23349] = 30
                            mem[_23349 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _24261 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24261 + 68] = mem[idx + _23349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24261 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24261 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27573] = 30
                            mem[_27573 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28867 + 68] = mem[idx + _27573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28867 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28867 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22594] = 30
                        mem[_22594 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _23348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23348 + 68] = mem[idx + _22594 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23348 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23348 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26384] = 30
                        mem[_26384 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _27572 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27572 + 68] = mem[idx + _26384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27572 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27572 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31199 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31199] = 30
                        mem[_31199 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32395 + 68] = mem[idx + _31199 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32395 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32395 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20172] = 30
                                mem[_20172 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20437 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20437 + 68] = mem[idx + _20172 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20437 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20437 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21372] = 30
                                mem[_21372 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21899 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21899 + 68] = mem[idx + _21372 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21899 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21899 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24259] = 30
                                mem[_24259 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25374 + 68] = mem[idx + _24259 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25374 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20902] = 30
                            mem[_20902 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21371 + 68] = mem[idx + _20902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21371 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21371 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23346 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23346] = 30
                            mem[_23346 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _24258 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24258 + 68] = mem[idx + _23346 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24258 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24258 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27570] = 30
                            mem[_27570 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                            _28865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28865 + 68] = mem[idx + _27570 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28865 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28865 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20901] = 30
                            mem[_20901 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21370 + 68] = mem[idx + _20901 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21370 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23344 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23344] = 30
                            mem[_23344 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _24257 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24257 + 68] = mem[idx + _23344 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24257 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24257 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27568] = 30
                            mem[_27568 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28864 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28864 + 68] = mem[idx + _27568 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28864 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28864 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22593] = 30
                        mem[_22593 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _23343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23343 + 68] = mem[idx + _22593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23343 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23343 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _26382 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26382] = 30
                        mem[_26382 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _27567 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27567 + 68] = mem[idx + _26382 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27567 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27567 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31196 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31196] = 30
                        mem[_31196 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32392 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32392 + 68] = mem[idx + _31196 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32392 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32392 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20900] = 30
                            mem[_20900 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21369 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21369 + 68] = mem[idx + _20900 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21369 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21369 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23341] = 30
                            mem[_23341 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _24256 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24256 + 68] = mem[idx + _23341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24256 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24256 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _27565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27565] = 30
                            mem[_27565 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28863 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28863 + 68] = mem[idx + _27565 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28863 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28863 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22592] = 30
                        mem[_22592 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23340 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23340 + 68] = mem[idx + _22592 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23340 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23340 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26380] = 30
                        mem[_26380 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _27564 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27564 + 68] = mem[idx + _26380 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27564 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27564 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _31194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31194] = 30
                        mem[_31194 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _32390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32390 + 68] = mem[idx + _31194 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32390 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32390 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _22591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22591] = 30
                        mem[_22591 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23339 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23339 + 68] = mem[idx + _22591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23339 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23339 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26378 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26378] = 30
                        mem[_26378 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _27563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27563 + 68] = mem[idx + _26378 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27563 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27563 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31192] = 30
                        mem[_31192 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _32389 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32389 + 68] = mem[idx + _31192 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32389 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32389 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25373 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25373] = 30
                    mem[_25373 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _26377 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26377 + 68] = mem[idx + _25373 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26377 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26377 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _30033 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30033] = 30
                    mem[_30033 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _31191 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31191 + 68] = mem[idx + _30033 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31191 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31191 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _34249 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34249] = 30
                    mem[_34249 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _35121 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35121 + 68] = mem[idx + _34249 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35121 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35121 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19098 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19098] = 30
                    mem[_19098 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19178 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19178 + 68] = mem[idx + _19098 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19178 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19178 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19531 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19531] = 30
                    mem[_19531 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19579 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19579 + 68] = mem[idx + _19531 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19579 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19579 + -mem[64] + 100
                _19099 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19099] = 26
                mem[_19099 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19179 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19179 + 68] = mem[idx + _19099 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19179 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19179 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20445] = 30
                            mem[_20445 + 32] = 'SafeMath: subtraction overflow'
                            _21914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21914] = 30
                            mem[_21914 + 32] = 'SafeMath: subtraction overflow'
                            _25391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25391] = 30
                            mem[_25391 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                            _26390 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26390 + 68] = mem[idx + _25391 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26390 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26390 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20444 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20444] = 30
                            mem[_20444 + 32] = 'SafeMath: subtraction overflow'
                            _21913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21913] = 30
                            mem[_21913 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22600 + 68] = mem[idx + _21913 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22600 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _25389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25389] = 30
                            mem[_25389 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                            _26389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26389 + 68] = mem[idx + _25389 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26389 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21386] = 30
                        mem[_21386 + 32] = 'SafeMath: subtraction overflow'
                        _24283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24283] = 30
                        mem[_24283 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _25388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25388 + 68] = mem[idx + _24283 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25388 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28887 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28887] = 30
                        mem[_28887 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30042 + 68] = mem[idx + _28887 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30042 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30042 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20443] = 30
                            mem[_20443 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _20633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20633 + 68] = mem[idx + _20443 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20633 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20633 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _21911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21911] = 30
                            mem[_21911 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _22599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22599 + 68] = mem[idx + _21911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22599 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25386] = 30
                            mem[_25386 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                            _26388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26388 + 68] = mem[idx + _25386 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26388 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21385] = 30
                        mem[_21385 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21910 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21910 + 68] = mem[idx + _21385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21910 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21910 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24281] = 30
                        mem[_24281 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _25385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25385 + 68] = mem[idx + _24281 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25385 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25385 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28885 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28885] = 30
                        mem[_28885 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30040 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30040 + 68] = mem[idx + _28885 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30040 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30040 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21384] = 30
                        mem[_21384 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21909 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21909 + 68] = mem[idx + _21384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21909 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21909 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24279] = 30
                        mem[_24279 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _25384 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25384 + 68] = mem[idx + _24279 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25384 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25384 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28883 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28883] = 30
                        mem[_28883 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30039 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30039 + 68] = mem[idx + _28883 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30039 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30039 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23357 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23357] = 30
                    mem[_23357 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _24278 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24278 + 68] = mem[idx + _23357 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24278 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24278 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27587] = 30
                    mem[_27587 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        _28882 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28882 + 68] = mem[idx + _27587 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28882 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28882 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32407 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32407] = 30
                    mem[_32407 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33385 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33385 + 68] = mem[idx + _32407 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33385 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33385 + -mem[64] + 100
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20441 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20441] = 30
                            mem[_20441 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20632 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20632 + 68] = mem[idx + _20441 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20632 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20632 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21907] = 30
                            mem[_21907 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22597 + 68] = mem[idx + _21907 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22597 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22597 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25382 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25382] = 30
                            mem[_25382 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26387 + 68] = mem[idx + _25382 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26387 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26387 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21383] = 30
                        mem[_21383 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21906 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21906 + 68] = mem[idx + _21383 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21906 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21906 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24276 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24276] = 30
                        mem[_24276 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _25381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25381 + 68] = mem[idx + _24276 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25381 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28880 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28880] = 30
                        mem[_28880 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _30037 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30037 + 68] = mem[idx + _28880 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30037 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30037 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21382 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21382] = 30
                        mem[_21382 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21905 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21905 + 68] = mem[idx + _21382 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21905 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21905 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24274] = 30
                        mem[_24274 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _25380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25380 + 68] = mem[idx + _24274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25380 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25380 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28878 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28878] = 30
                        mem[_28878 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30036 + 68] = mem[idx + _28878 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30036 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30036 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23356 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23356] = 30
                    mem[_23356 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _24273 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24273 + 68] = mem[idx + _23356 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24273 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24273 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _27585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27585] = 30
                    mem[_27585 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28877 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28877 + 68] = mem[idx + _27585 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28877 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28877 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32404] = 30
                    mem[_32404 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33382 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33382 + 68] = mem[idx + _32404 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33382 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33382 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _21381 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21381] = 30
                        mem[_21381 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _21904 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21904 + 68] = mem[idx + _21381 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21904 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21904 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24271] = 30
                        mem[_24271 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _25379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25379 + 68] = mem[idx + _24271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25379 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _28875 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28875] = 30
                        mem[_28875 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30035 + 68] = mem[idx + _28875 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30035 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23355 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23355] = 30
                    mem[_23355 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24270 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24270 + 68] = mem[idx + _23355 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24270 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24270 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27583] = 30
                    mem[_27583 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _28874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28874 + 68] = mem[idx + _27583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28874 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28874 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    _32402 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32402] = 30
                    mem[_32402 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _33380 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33380 + 68] = mem[idx + _32402 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33380 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33380 + -mem[64] + 100
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _23354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23354] = 30
                    mem[_23354 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24269 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24269 + 68] = mem[idx + _23354 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24269 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24269 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27581 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27581] = 30
                    mem[_27581 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _28873 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28873 + 68] = mem[idx + _27581 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28873 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28873 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32400] = 30
                    mem[_32400 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _33379 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33379 + 68] = mem[idx + _32400 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33379 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33379 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26386 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26386] = 30
                mem[_26386 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _27580 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27580 + 68] = mem[idx + _26386 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27580 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27580 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _31204 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31204] = 30
                mem[_31204 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    _32399 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32399 + 68] = mem[idx + _31204 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32399 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32399 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _35126 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35126] = 30
                mem[_35126 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _35717 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35717 + 68] = mem[idx + _35126 + 32]
                    idx = idx + 32
                    continue 
                mem[_35717 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35717 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor16 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s))
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            return 0
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor14 / 100:
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                revert with 0, 17
            if not 0 / stor14 / 100:
                revert with 0, 18
            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
        if arg1 and _BURN_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        if not stor14:
            revert with 0, 'SafeMath: division by zero', 0
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < 0 / stor14 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor16
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19028 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19028] = 26
                    mem[_19028 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19094 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19094 + 68] = mem[idx + _19028 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19094 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19094 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20163] = 30
                                mem[_20163 + 32] = 'SafeMath: subtraction overflow'
                                _21355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21355] = 30
                                mem[_21355 + 32] = 'SafeMath: subtraction overflow'
                                _24225 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24225] = 30
                                mem[_24225 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                                _25350 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25350 + 68] = mem[idx + _24225 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25350 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25350 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20162] = 30
                                mem[_20162 + 32] = 'SafeMath: subtraction overflow'
                                _21354 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21354] = 30
                                mem[_21354 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21878 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21878 + 68] = mem[idx + _21354 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21878 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21878 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _24223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24223] = 30
                                mem[_24223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                                _25349 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25349 + 68] = mem[idx + _24223 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25349 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25349 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20883 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20883] = 30
                            mem[_20883 + 32] = 'SafeMath: subtraction overflow'
                            _23312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23312] = 30
                            mem[_23312 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _24222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24222 + 68] = mem[idx + _23312 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24222 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27523] = 30
                            mem[_27523 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28833 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28833 + 68] = mem[idx + _27523 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28833 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28833 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20161] = 30
                                mem[_20161 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20429 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20429 + 68] = mem[idx + _20161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20429 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20429 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21352] = 30
                                mem[_21352 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _21877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21877 + 68] = mem[idx + _21352 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21877 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24220 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24220] = 30
                                mem[_24220 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                                _25348 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25348 + 68] = mem[idx + _24220 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25348 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25348 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20882] = 30
                            mem[_20882 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21351 + 68] = mem[idx + _20882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21351 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21351 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23310 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23310] = 30
                            mem[_23310 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _24219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24219 + 68] = mem[idx + _23310 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24219 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24219 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27521] = 30
                            mem[_27521 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28831 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28831 + 68] = mem[idx + _27521 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28831 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28831 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20881 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20881] = 30
                            mem[_20881 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21350 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21350 + 68] = mem[idx + _20881 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21350 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21350 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23308] = 30
                            mem[_23308 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _24218 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24218 + 68] = mem[idx + _23308 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24218 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24218 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27519] = 30
                            mem[_27519 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28830 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28830 + 68] = mem[idx + _27519 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28830 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28830 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22569 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22569] = 30
                        mem[_22569 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _23307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23307 + 68] = mem[idx + _22569 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23307 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23307 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26340 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26340] = 30
                        mem[_26340 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _27518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27518 + 68] = mem[idx + _26340 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27518 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27518 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31150] = 30
                        mem[_31150 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _32352 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32352 + 68] = mem[idx + _31150 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32352 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32352 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20159] = 30
                                mem[_20159 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20428 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20428 + 68] = mem[idx + _20159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20428 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20428 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21348] = 30
                                mem[_21348 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21875 + 68] = mem[idx + _21348 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21875 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24216 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24216] = 30
                                mem[_24216 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25347 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25347 + 68] = mem[idx + _24216 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25347 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25347 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20880 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20880] = 30
                            mem[_20880 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21347 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21347 + 68] = mem[idx + _20880 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21347 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21347 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23305] = 30
                            mem[_23305 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _24215 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24215 + 68] = mem[idx + _23305 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24215 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24215 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _27516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27516] = 30
                            mem[_27516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                            _28828 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28828 + 68] = mem[idx + _27516 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28828 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28828 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20879] = 30
                            mem[_20879 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21346 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21346 + 68] = mem[idx + _20879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21346 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21346 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23303 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23303] = 30
                            mem[_23303 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _24214 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24214 + 68] = mem[idx + _23303 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24214 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24214 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _27514 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27514] = 30
                            mem[_27514 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28827 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28827 + 68] = mem[idx + _27514 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28827 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28827 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22568 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22568] = 30
                        mem[_22568 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _23302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23302 + 68] = mem[idx + _22568 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23302 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23302 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _26338 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26338] = 30
                        mem[_26338 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _27513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27513 + 68] = mem[idx + _26338 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27513 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27513 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31147] = 30
                        mem[_31147 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _32349 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32349 + 68] = mem[idx + _31147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32349 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32349 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _20878 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20878] = 30
                            mem[_20878 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21345 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21345 + 68] = mem[idx + _20878 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21345 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21345 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23300] = 30
                            mem[_23300 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _24213 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24213 + 68] = mem[idx + _23300 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24213 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24213 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _27511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27511] = 30
                            mem[_27511 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                            _28826 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28826 + 68] = mem[idx + _27511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28826 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28826 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22567] = 30
                        mem[_22567 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23299 + 68] = mem[idx + _22567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23299 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23299 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26336 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26336] = 30
                        mem[_26336 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _27510 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27510 + 68] = mem[idx + _26336 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27510 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27510 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _31145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31145] = 30
                        mem[_31145 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _32347 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32347 + 68] = mem[idx + _31145 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32347 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32347 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _22566 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22566] = 30
                        mem[_22566 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _23298 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23298 + 68] = mem[idx + _22566 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23298 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23298 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _26334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26334] = 30
                        mem[_26334 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _27509 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27509 + 68] = mem[idx + _26334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27509 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27509 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _31143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31143] = 30
                        mem[_31143 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _32346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32346 + 68] = mem[idx + _31143 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32346 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32346 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25346 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25346] = 30
                    mem[_25346 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _26333 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26333 + 68] = mem[idx + _25346 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26333 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26333 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _30003 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30003] = 30
                    mem[_30003 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _31142 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31142 + 68] = mem[idx + _30003 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31142 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31142 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _34215 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34215] = 30
                    mem[_34215 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _35088 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35088 + 68] = mem[idx + _34215 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35088 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35088 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19095] = 30
                    mem[_19095 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19175 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19175 + 68] = mem[idx + _19095 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19175 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19175 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19528] = 30
                    mem[_19528 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19576 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19576 + 68] = mem[idx + _19528 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19576 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19576 + -mem[64] + 100
                _19096 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19096] = 26
                mem[_19096 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19176 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19176 + 68] = mem[idx + _19096 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19176 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19176 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20436] = 30
                            mem[_20436 + 32] = 'SafeMath: subtraction overflow'
                            _21890 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21890] = 30
                            mem[_21890 + 32] = 'SafeMath: subtraction overflow'
                            _25364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25364] = 30
                            mem[_25364 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                            _26346 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26346 + 68] = mem[idx + _25364 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26346 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26346 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20435] = 30
                            mem[_20435 + 32] = 'SafeMath: subtraction overflow'
                            _21889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21889] = 30
                            mem[_21889 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22575 + 68] = mem[idx + _21889 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22575 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _25362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25362] = 30
                            mem[_25362 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                            _26345 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26345 + 68] = mem[idx + _25362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26345 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26345 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21362] = 30
                        mem[_21362 + 32] = 'SafeMath: subtraction overflow'
                        _24240 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24240] = 30
                        mem[_24240 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _25361 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25361 + 68] = mem[idx + _24240 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25361 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25361 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28850 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28850] = 30
                        mem[_28850 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30012 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30012 + 68] = mem[idx + _28850 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30012 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30012 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _20434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20434] = 30
                            mem[_20434 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _20625 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20625 + 68] = mem[idx + _20434 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20625 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20625 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _21887 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21887] = 30
                            mem[_21887 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _22574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22574 + 68] = mem[idx + _21887 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22574 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25359] = 30
                            mem[_25359 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                            _26344 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26344 + 68] = mem[idx + _25359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26344 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26344 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21361] = 30
                        mem[_21361 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21886 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21886 + 68] = mem[idx + _21361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21886 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21886 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24238] = 30
                        mem[_24238 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _25358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25358 + 68] = mem[idx + _24238 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25358 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28848 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28848] = 30
                        mem[_28848 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30010 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30010 + 68] = mem[idx + _28848 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30010 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30010 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _21360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21360] = 30
                        mem[_21360 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21885 + 68] = mem[idx + _21360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21885 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21885 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24236] = 30
                        mem[_24236 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _25357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25357 + 68] = mem[idx + _24236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25357 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25357 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28846] = 30
                        mem[_28846 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30009 + 68] = mem[idx + _28846 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30009 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30009 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23316 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23316] = 30
                    mem[_23316 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _24235 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24235 + 68] = mem[idx + _23316 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24235 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24235 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27533 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27533] = 30
                    mem[_27533 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        _28845 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28845 + 68] = mem[idx + _27533 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28845 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28845 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32364 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32364] = 30
                    mem[_32364 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _33371 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33371 + 68] = mem[idx + _32364 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33371 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33371 + -mem[64] + 100
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _20432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20432] = 30
                            mem[_20432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20624 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20624 + 68] = mem[idx + _20432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20624 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20624 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21883 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21883] = 30
                            mem[_21883 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22572 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22572 + 68] = mem[idx + _21883 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22572 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22572 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25355] = 30
                            mem[_25355 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26343 + 68] = mem[idx + _25355 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26343 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26343 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21359] = 30
                        mem[_21359 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21882 + 68] = mem[idx + _21359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21882 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21882 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24233] = 30
                        mem[_24233 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _25354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25354 + 68] = mem[idx + _24233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25354 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28843] = 30
                        mem[_28843 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                        _30007 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30007 + 68] = mem[idx + _28843 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30007 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30007 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _21358 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21358] = 30
                        mem[_21358 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21881 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21881 + 68] = mem[idx + _21358 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21881 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21881 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24231] = 30
                        mem[_24231 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _25353 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25353 + 68] = mem[idx + _24231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25353 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25353 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28841 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28841] = 30
                        mem[_28841 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30006 + 68] = mem[idx + _28841 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30006 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30006 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23315] = 30
                    mem[_23315 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _24230 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24230 + 68] = mem[idx + _23315 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24230 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24230 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _27531 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27531] = 30
                    mem[_27531 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28840 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28840 + 68] = mem[idx + _27531 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28840 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28840 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32361 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32361] = 30
                    mem[_32361 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _33368 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33368 + 68] = mem[idx + _32361 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33368 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33368 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        _21357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21357] = 30
                        mem[_21357 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _21880 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21880 + 68] = mem[idx + _21357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21880 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21880 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24228] = 30
                        mem[_24228 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _25352 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25352 + 68] = mem[idx + _24228 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25352 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25352 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _28838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28838] = 30
                        mem[_28838 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                        _30005 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30005 + 68] = mem[idx + _28838 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30005 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30005 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23314 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23314] = 30
                    mem[_23314 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24227 + 68] = mem[idx + _23314 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24227 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24227 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27529] = 30
                    mem[_27529 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _28837 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28837 + 68] = mem[idx + _27529 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28837 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28837 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    _32359 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32359] = 30
                    mem[_32359 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                    _33366 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33366 + 68] = mem[idx + _32359 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33366 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33366 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    _23313 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23313] = 30
                    mem[_23313 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _24226 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24226 + 68] = mem[idx + _23313 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24226 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24226 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _27527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27527] = 30
                    mem[_27527 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _28836 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28836 + 68] = mem[idx + _27527 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28836 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28836 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _32357 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32357] = 30
                    mem[_32357 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    _33365 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33365 + 68] = mem[idx + _32357 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33365 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33365 + -mem[64] + 100
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26342 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26342] = 30
                mem[_26342 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _27526 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27526 + 68] = mem[idx + _26342 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27526 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27526 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _31155 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31155] = 30
                mem[_31155 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    _32356 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32356 + 68] = mem[idx + _31155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32356 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32356 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _35093 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35093] = 30
                mem[_35093 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                _35712 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35712 + 68] = mem[idx + _35093 + 32]
                    idx = idx + 32
                    continue 
                mem[_35712 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35712 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor16 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * 0 / stor14 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor14 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor14 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s))
                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            return 0
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (-1 * 0 / stor14 / 100 * stor16 / totalSupply)
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor14 / 100:
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not 0 / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                    revert with 0, 17
                if not 0 / stor14 / 100:
                    revert with 0, 18
                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor14 / 100:
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                revert with 0, 17
            if not 0 / stor14 / 100:
                revert with 0, 18
            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply))
        if arg1 and sub_a55d4d5c > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        if not stor14:
            revert with 0, 'SafeMath: division by zero', 0
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * _TAX_FEE / stor14 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _TAX_FEE / stor14 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor16
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _19027 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19027] = 26
                mem[_19027 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19091 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19091 + 68] = mem[idx + _19027 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19091 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19091 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20150] = 30
                            mem[_20150 + 32] = 'SafeMath: subtraction overflow'
                            _21331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21331] = 30
                            mem[_21331 + 32] = 'SafeMath: subtraction overflow'
                            _24182 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24182] = 30
                            mem[_24182 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                            _25323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25323 + 68] = mem[idx + _24182 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25323 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25323 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20149] = 30
                            mem[_20149 + 32] = 'SafeMath: subtraction overflow'
                            _21330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21330] = 30
                            mem[_21330 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _21854 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21854 + 68] = mem[idx + _21330 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21854 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21854 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24180] = 30
                            mem[_24180 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                            _25322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25322 + 68] = mem[idx + _24180 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25322 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25322 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20861] = 30
                        mem[_20861 + 32] = 'SafeMath: subtraction overflow'
                        _23271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23271] = 30
                        mem[_23271 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24179 + 68] = mem[idx + _23271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24179 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27469 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27469] = 30
                        mem[_27469 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _28796 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28796 + 68] = mem[idx + _27469 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28796 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28796 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20148 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20148] = 30
                            mem[_20148 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _20420 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20420 + 68] = mem[idx + _20148 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20420 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20420 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _21328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21328] = 30
                            mem[_21328 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _21853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21853 + 68] = mem[idx + _21328 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21853 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24177] = 30
                            mem[_24177 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                            _25321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25321 + 68] = mem[idx + _24177 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25321 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25321 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20860 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20860] = 30
                        mem[_20860 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21327 + 68] = mem[idx + _20860 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21327 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21327 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _23269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23269] = 30
                        mem[_23269 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _24176 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24176 + 68] = mem[idx + _23269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24176 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24176 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27467 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27467] = 30
                        mem[_27467 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _28794 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28794 + 68] = mem[idx + _27467 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28794 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28794 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20859 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20859] = 30
                        mem[_20859 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _21326 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21326 + 68] = mem[idx + _20859 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21326 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21326 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _23267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23267] = 30
                        mem[_23267 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _24175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24175 + 68] = mem[idx + _23267 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24175 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24175 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27465] = 30
                        mem[_27465 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _28793 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28793 + 68] = mem[idx + _27465 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28793 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28793 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22544 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22544] = 30
                    mem[_22544 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _23266 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23266 + 68] = mem[idx + _22544 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23266 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23266 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _26296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26296] = 30
                    mem[_26296 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        _27464 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27464 + 68] = mem[idx + _26296 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27464 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27464 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31101 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31101] = 30
                    mem[_31101 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _32309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32309 + 68] = mem[idx + _31101 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32309 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32309 + -mem[64] + 100
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20146 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20146] = 30
                            mem[_20146 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20419 + 68] = mem[idx + _20146 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20419 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20419 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21324] = 30
                            mem[_21324 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21851 + 68] = mem[idx + _21324 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21851 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21851 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24173] = 30
                            mem[_24173 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _25320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25320 + 68] = mem[idx + _24173 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25320 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25320 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20858 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20858] = 30
                        mem[_20858 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21323 + 68] = mem[idx + _20858 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21323 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21323 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _23264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23264] = 30
                        mem[_23264 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24172 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24172 + 68] = mem[idx + _23264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24172 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24172 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27462] = 30
                        mem[_27462 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                        _28791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28791 + 68] = mem[idx + _27462 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28791 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28791 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20857 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20857] = 30
                        mem[_20857 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _21322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21322 + 68] = mem[idx + _20857 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21322 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21322 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _23262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23262] = 30
                        mem[_23262 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24171 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24171 + 68] = mem[idx + _23262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24171 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24171 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27460 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27460] = 30
                        mem[_27460 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                        _28790 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28790 + 68] = mem[idx + _27460 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28790 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28790 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22543 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22543] = 30
                    mem[_22543 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _23261 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23261 + 68] = mem[idx + _22543 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23261 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23261 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _26294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26294] = 30
                    mem[_26294 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27459 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27459 + 68] = mem[idx + _26294 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27459 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27459 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31098 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31098] = 30
                    mem[_31098 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _32306 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32306 + 68] = mem[idx + _31098 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32306 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32306 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20856 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20856] = 30
                        mem[_20856 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _21321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21321 + 68] = mem[idx + _20856 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21321 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21321 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _23259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23259] = 30
                        mem[_23259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _24170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24170 + 68] = mem[idx + _23259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24170 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24170 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _27457 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27457] = 30
                        mem[_27457 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                        _28789 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28789 + 68] = mem[idx + _27457 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28789 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28789 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22542 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22542] = 30
                    mem[_22542 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _23258 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23258 + 68] = mem[idx + _22542 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23258 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23258 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _26292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26292] = 30
                    mem[_26292 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _27456 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27456 + 68] = mem[idx + _26292 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27456 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27456 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    _31096 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31096] = 30
                    mem[_31096 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _32304 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32304 + 68] = mem[idx + _31096 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32304 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32304 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _22541 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22541] = 30
                    mem[_22541 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _23257 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23257 + 68] = mem[idx + _22541 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23257 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23257 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _26290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26290] = 30
                    mem[_26290 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _27455 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27455 + 68] = mem[idx + _26290 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27455 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27455 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31094 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31094] = 30
                    mem[_31094 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    _32303 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32303 + 68] = mem[idx + _31094 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32303 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32303 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _25319 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25319] = 30
                mem[_25319 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _26289 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _26289 + 68] = mem[idx + _25319 + 32]
                        idx = idx + 32
                        continue 
                    mem[_26289 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _26289 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _29973 = mem[64]
                mem[64] = mem[64] + 64
                mem[_29973] = 30
                mem[_29973 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    _31093 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _31093 + 68] = mem[idx + _29973 + 32]
                        idx = idx + 32
                        continue 
                    mem[_31093 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _31093 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _34181 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34181] = 30
                mem[_34181 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _35055 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35055 + 68] = mem[idx + _34181 + 32]
                    idx = idx + 32
                    continue 
                mem[_35055 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35055 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _19092 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19092] = 30
                mem[_19092 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _19172 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19172 + 68] = mem[idx + _19092 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19172 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19172 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _19525 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19525] = 30
                mem[_19525 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _19573 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _19573 + 68] = mem[idx + _19525 + 32]
                    idx = idx + 32
                    continue 
                mem[_19573 + 98] = 0
                revert with memory
                  from mem[64]
                   len _19573 + -mem[64] + 100
            _19093 = mem[64]
            mem[64] = mem[64] + 64
            mem[_19093] = 26
            mem[_19093 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _19173 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _19173 + 68] = mem[idx + _19093 + 32]
                    idx = idx + 32
                    continue 
                mem[_19173 + 94] = 0
                revert with memory
                  from mem[64]
                   len _19173 + -mem[64] + 100
            if not arg1:
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            return 0
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20427 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20427] = 30
                        mem[_20427 + 32] = 'SafeMath: subtraction overflow'
                        _21866 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21866] = 30
                        mem[_21866 + 32] = 'SafeMath: subtraction overflow'
                        _25337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25337] = 30
                        mem[_25337 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                            if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                        _26302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26302 + 68] = mem[idx + _25337 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26302 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26302 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20426] = 30
                        mem[_20426 + 32] = 'SafeMath: subtraction overflow'
                        _21865 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21865] = 30
                        mem[_21865 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _22550 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22550 + 68] = mem[idx + _21865 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22550 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22550 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _25335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25335] = 30
                        mem[_25335 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                        _26301 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26301 + 68] = mem[idx + _25335 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26301 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26301 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21338 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21338] = 30
                    mem[_21338 + 32] = 'SafeMath: subtraction overflow'
                    _24197 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24197] = 30
                    mem[_24197 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _25334 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25334 + 68] = mem[idx + _24197 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25334 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25334 + -mem[64] + 100
                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _28813 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28813] = 30
                    mem[_28813 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _29982 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29982 + 68] = mem[idx + _28813 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29982 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29982 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20425] = 30
                        mem[_20425 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _20617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20617 + 68] = mem[idx + _20425 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20617 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _21863 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21863] = 30
                        mem[_21863 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _22549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22549 + 68] = mem[idx + _21863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22549 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22549 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _25332 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25332] = 30
                        mem[_25332 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                        _26300 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26300 + 68] = mem[idx + _25332 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26300 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26300 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21337 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21337] = 30
                    mem[_21337 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _21862 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21862 + 68] = mem[idx + _21337 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21862 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21862 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _24195 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24195] = 30
                    mem[_24195 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        _25331 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25331 + 68] = mem[idx + _24195 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25331 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25331 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _28811 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28811] = 30
                    mem[_28811 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _29980 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29980 + 68] = mem[idx + _28811 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29980 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29980 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _21336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21336] = 30
                    mem[_21336 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        _21861 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21861 + 68] = mem[idx + _21336 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21861 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21861 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _24193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24193] = 30
                    mem[_24193 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        _25330 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25330 + 68] = mem[idx + _24193 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25330 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25330 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _28809 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28809] = 30
                    mem[_28809 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    _29979 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29979 + 68] = mem[idx + _28809 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29979 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29979 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23275 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23275] = 30
                mem[_23275 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    _24192 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24192 + 68] = mem[idx + _23275 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24192 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24192 + -mem[64] + 100
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _27479 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27479] = 30
                mem[_27479 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    _28808 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28808 + 68] = mem[idx + _27479 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28808 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28808 + -mem[64] + 100
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _32321 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32321] = 30
                mem[_32321 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _33357 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33357 + 68] = mem[idx + _32321 + 32]
                    idx = idx + 32
                    continue 
                mem[_33357 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33357 + -mem[64] + 100
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor14 / 100:
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _20423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20423] = 30
                        mem[_20423 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _20616 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20616 + 68] = mem[idx + _20423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20616 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20616 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _21859 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21859] = 30
                        mem[_21859 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _22547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22547 + 68] = mem[idx + _21859 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22547 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _25328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25328] = 30
                        mem[_25328 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _26299 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26299 + 68] = mem[idx + _25328 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26299 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26299 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21335 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21335] = 30
                    mem[_21335 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _21858 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21858 + 68] = mem[idx + _21335 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21858 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21858 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _24190 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24190] = 30
                    mem[_24190 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _25327 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25327 + 68] = mem[idx + _24190 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25327 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25327 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _28806 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28806] = 30
                    mem[_28806 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                        if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                    _29977 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29977 + 68] = mem[idx + _28806 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29977 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29977 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _21334 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21334] = 30
                    mem[_21334 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor16 / totalSupply:
                        _21857 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21857 + 68] = mem[idx + _21334 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21857 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21857 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    _24188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24188] = 30
                    mem[_24188 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _25326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25326 + 68] = mem[idx + _24188 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25326 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _28804 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28804] = 30
                    mem[_28804 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                    _29976 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29976 + 68] = mem[idx + _28804 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29976 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29976 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23274 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23274] = 30
                mem[_23274 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor16 / totalSupply:
                    _24187 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24187 + 68] = mem[idx + _23274 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24187 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24187 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                _27477 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27477] = 30
                mem[_27477 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _28803 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28803 + 68] = mem[idx + _27477 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28803 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28803 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _32318 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32318] = 30
                mem[_32318 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _33354 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33354 + 68] = mem[idx + _32318 + 32]
                    idx = idx + 32
                    continue 
                mem[_33354 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33354 + -mem[64] + 100
            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    _21333 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21333] = 30
                    mem[_21333 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _21856 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21856 + 68] = mem[idx + _21333 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21856 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21856 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _24185 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24185] = 30
                    mem[_24185 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _25325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25325 + 68] = mem[idx + _24185 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25325 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    _28801 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28801] = 30
                    mem[_28801 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
                    _29975 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29975 + 68] = mem[idx + _28801 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29975 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29975 + -mem[64] + 100
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23273 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23273] = 30
                mem[_23273 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _24184 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24184 + 68] = mem[idx + _23273 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24184 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24184 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _27475 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27475] = 30
                mem[_27475 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    _28800 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28800 + 68] = mem[idx + _27475 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28800 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28800 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                _32316 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32316] = 30
                mem[_32316 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
                _33352 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33352 + 68] = mem[idx + _32316 + 32]
                    idx = idx + 32
                    continue 
                mem[_33352 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33352 + -mem[64] + 100
            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                _23272 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23272] = 30
                mem[_23272 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    _24183 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24183 + 68] = mem[idx + _23272 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24183 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24183 + -mem[64] + 100
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _27473 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27473] = 30
                mem[_27473 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    _28799 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28799 + 68] = mem[idx + _27473 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28799 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28799 + -mem[64] + 100
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                _32314 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32314] = 30
                mem[_32314 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
                _33351 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33351 + 68] = mem[idx + _32314 + 32]
                    idx = idx + 32
                    continue 
                mem[_33351 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33351 + -mem[64] + 100
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _26298 = mem[64]
            mem[64] = mem[64] + 64
            mem[_26298] = 30
            mem[_26298 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                _27472 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _27472 + 68] = mem[idx + _26298 + 32]
                    idx = idx + 32
                    continue 
                mem[_27472 + 98] = 0
                revert with memory
                  from mem[64]
                   len _27472 + -mem[64] + 100
            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            _31106 = mem[64]
            mem[64] = mem[64] + 64
            mem[_31106] = 30
            mem[_31106 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                _32313 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _32313 + 68] = mem[idx + _31106 + 32]
                    idx = idx + 32
                    continue 
                mem[_32313 + 98] = 0
                revert with memory
                  from mem[64]
                   len _32313 + -mem[64] + 100
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            _35060 = mem[64]
            mem[64] = mem[64] + 64
            mem[_35060] = 30
            mem[_35060 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            _35707 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _35707 + 68] = mem[idx + _35060 + 32]
                idx = idx + 32
                continue 
            mem[_35707 + 98] = 0
            revert with memory
              from mem[64]
               len _35707 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor16 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            return 0
                        if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * t / s)
                    if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor14 / 100:
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
            if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s))
                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s))
            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) - (arg1 * sub_a55d4d5c / stor14 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * _TAX_FEE / stor14 / 100:
                if not arg1 * _BURN_FEE / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        return 0
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply)
                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply)
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply)
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
        if arg1 and stor16 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _TAX_FEE / stor14 / 100:
            if not arg1 * _BURN_FEE / stor14 / 100:
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor16 / totalSupply)
                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                if not arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor14 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if 0 > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
            revert with 0, 17
        if not arg1 * _TAX_FEE / stor14 / 100:
            revert with 0, 18
        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _BURN_FEE / stor14 / 100:
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply))
            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 17
            if not arg1 * sub_a55d4d5c / stor14 / 100:
                revert with 0, 18
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
            revert with 0, 17
        if not arg1 * _BURN_FEE / stor14 / 100:
            revert with 0, 18
        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * sub_a55d4d5c / stor14 / 100:
            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply))
        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
            revert with 0, 17
        if not arg1 * sub_a55d4d5c / stor14 / 100:
            revert with 0, 18
        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
            revert with 0, 17
        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
            revert with 0, 17
        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor14:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (2 * 0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19042] = 26
                        mem[_19042 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19136 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19136 + 68] = mem[idx + _19042 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19136 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19136 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20322] = 30
                                mem[_20322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20546 + 68] = mem[idx + _20322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20546 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20546 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21658 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21658] = 30
                                mem[_21658 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22163 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22163 + 68] = mem[idx + _21658 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22163 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22163 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24747 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24747] = 30
                                mem[_24747 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25683 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25683 + 68] = mem[idx + _24747 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25683 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25683 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21142] = 30
                                mem[_21142 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21657 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21657 + 68] = mem[idx + _21142 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21657 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21657 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23803 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23803] = 30
                                mem[_23803 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24746 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24746 + 68] = mem[idx + _23803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24746 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24746 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28171] = 30
                                mem[_28171 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29282 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29282 + 68] = mem[idx + _28171 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29282 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29282 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22870] = 30
                            mem[_22870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23802 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23802 + 68] = mem[idx + _22870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23802 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23802 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26862] = 30
                            mem[_26862 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _28170 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28170 + 68] = mem[idx + _26862 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28170 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28170 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31734] = 30
                            mem[_31734 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32866 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32866 + 68] = mem[idx + _31734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32866 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32866 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20320] = 30
                            mem[_20320 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20545 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20545 + 68] = mem[idx + _20320 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20545 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20545 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _21655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21655] = 30
                            mem[_21655 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22161 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22161 + 68] = mem[idx + _21655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22161 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22161 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24744] = 30
                            mem[_24744 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _25682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25682 + 68] = mem[idx + _24744 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25682 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21141] = 30
                            mem[_21141 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21654 + 68] = mem[idx + _21141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21654 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21654 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23800 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23800] = 30
                            mem[_23800 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _24743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24743 + 68] = mem[idx + _23800 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24743 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _28168 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28168] = 30
                            mem[_28168 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _29280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29280 + 68] = mem[idx + _28168 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29280 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29280 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22869 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22869] = 30
                            mem[_22869 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23799 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23799 + 68] = mem[idx + _22869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23799 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23799 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26860 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26860] = 30
                            mem[_26860 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28167 + 68] = mem[idx + _26860 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28167 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28167 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31731] = 30
                            mem[_31731 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32864 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32864 + 68] = mem[idx + _31731 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32864 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32864 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25681 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25681] = 30
                        mem[_25681 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26859 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26859 + 68] = mem[idx + _25681 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26859 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26859 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30373 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30373] = 30
                        mem[_30373 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31730 + 68] = mem[idx + _30373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31730 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31730 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34631] = 30
                        mem[_34631 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35484 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35484 + 68] = mem[idx + _34631 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35484 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35484 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19137] = 30
                        mem[_19137 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19217 + 68] = mem[idx + _19137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19217 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19570] = 30
                        mem[_19570 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19618 + 68] = mem[idx + _19570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19618 + -mem[64] + 100
                    _19138 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19138] = 26
                    mem[_19138 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19218 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19218 + 68] = mem[idx + _19138 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19218 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19218 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            return 0
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20550] = 30
                            mem[_20550 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _20717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20717 + 68] = mem[idx + _20550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20717 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20717 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _22169 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22169] = 30
                            mem[_22169 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _22873 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22873 + 68] = mem[idx + _22169 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22873 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22873 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25689 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25689] = 30
                            mem[_25689 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26866 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26866 + 68] = mem[idx + _25689 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26866 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26866 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21662] = 30
                            mem[_21662 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22168 + 68] = mem[idx + _21662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22168 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22168 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24753 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24753] = 30
                            mem[_24753 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25688 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25688 + 68] = mem[idx + _24753 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25688 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25688 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29288] = 30
                            mem[_29288 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30377 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30377 + 68] = mem[idx + _29288 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30377 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30377 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23806 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23806] = 30
                        mem[_23806 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24752 + 68] = mem[idx + _23806 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24752 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28177] = 30
                        mem[_28177 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _29287 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29287 + 68] = mem[idx + _28177 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29287 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29287 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32872 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32872] = 30
                        mem[_32872 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33545 + 68] = mem[idx + _32872 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33545 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33545 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _20548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20548] = 30
                        mem[_20548 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _20716 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20716 + 68] = mem[idx + _20548 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20716 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20716 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _22166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22166] = 30
                        mem[_22166 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _22871 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22871 + 68] = mem[idx + _22166 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22871 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22871 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _25686 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25686] = 30
                        mem[_25686 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _26865 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26865 + 68] = mem[idx + _25686 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26865 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26865 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _21661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21661] = 30
                        mem[_21661 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _22165 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22165 + 68] = mem[idx + _21661 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22165 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22165 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24750] = 30
                        mem[_24750 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _25685 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25685 + 68] = mem[idx + _24750 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25685 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25685 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _29285 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29285] = 30
                        mem[_29285 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _30375 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30375 + 68] = mem[idx + _29285 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30375 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30375 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23805] = 30
                        mem[_23805 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24749 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24749 + 68] = mem[idx + _23805 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24749 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24749 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28175] = 30
                        mem[_28175 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29284 + 68] = mem[idx + _28175 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29284 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29284 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32869 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32869] = 30
                        mem[_32869 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33543 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33543 + 68] = mem[idx + _32869 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33543 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33543 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26864 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26864] = 30
                    mem[_26864 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28174 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28174 + 68] = mem[idx + _26864 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28174 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28174 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31737] = 30
                    mem[_31737 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32868 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32868 + 68] = mem[idx + _31737 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32868 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32868 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35487 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35487] = 30
                    mem[_35487 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35776 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35776 + 68] = mem[idx + _35487 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35776 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35776 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if 0 / stor14 / 100:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                            return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if 0 / stor14 / 100:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        return 0
                    else:
                        return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor16 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor16 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and sub_a55d4d5c > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (2 * 0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19041 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19041] = 26
                        mem[_19041 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19133 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19133 + 68] = mem[idx + _19041 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19133 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19133 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20314] = 30
                                mem[_20314 + 32] = 'SafeMath: subtraction overflow'
                                _21642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21642] = 30
                                mem[_21642 + 32] = 'SafeMath: subtraction overflow'
                                _24722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24722] = 30
                                mem[_24722 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25666 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25666 + 68] = mem[idx + _24722 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25666 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25666 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20313] = 30
                                    mem[_20313 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20539 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20539 + 68] = mem[idx + _20313 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20539 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20539 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21640 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21640] = 30
                                    mem[_21640 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _22150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22150 + 68] = mem[idx + _21640 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22150 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22150 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24720] = 30
                                    mem[_24720 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25665 + 68] = mem[idx + _24720 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25665 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21131] = 30
                                mem[_21131 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21639 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21639 + 68] = mem[idx + _21131 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21639 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21639 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23782 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23782] = 30
                                mem[_23782 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24719 + 68] = mem[idx + _23782 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24719 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _28143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28143] = 30
                                mem[_28143 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29259 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29259 + 68] = mem[idx + _28143 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29259 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29259 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21130] = 30
                                mem[_21130 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21638 + 68] = mem[idx + _21130 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21638 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21638 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23780] = 30
                                mem[_23780 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24718 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24718 + 68] = mem[idx + _23780 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24718 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24718 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28141] = 30
                                mem[_28141 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29258 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29258 + 68] = mem[idx + _28141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29258 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29258 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22857] = 30
                            mem[_22857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23779 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23779 + 68] = mem[idx + _22857 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23779 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23779 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26841] = 30
                            mem[_26841 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _28140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28140 + 68] = mem[idx + _26841 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28140 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28140 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31710 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31710] = 30
                            mem[_31710 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32843 + 68] = mem[idx + _31710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32843 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20311] = 30
                                mem[_20311 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20538 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20538 + 68] = mem[idx + _20311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20538 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20538 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21636] = 30
                                mem[_21636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22148 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22148 + 68] = mem[idx + _21636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22148 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22148 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24716] = 30
                                mem[_24716 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25664 + 68] = mem[idx + _24716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25664 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25664 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21129] = 30
                            mem[_21129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _21635 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21635 + 68] = mem[idx + _21129 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21635 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21635 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _23777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23777] = 30
                            mem[_23777 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _24715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24715 + 68] = mem[idx + _23777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24715 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24715 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _28138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28138] = 30
                            mem[_28138 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _29256 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29256 + 68] = mem[idx + _28138 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29256 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29256 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21128 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21128] = 30
                                mem[_21128 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21634 + 68] = mem[idx + _21128 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21634 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21634 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23775 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23775] = 30
                                mem[_23775 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24714 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24714 + 68] = mem[idx + _23775 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24714 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24714 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _28136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28136] = 30
                                mem[_28136 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29255 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29255 + 68] = mem[idx + _28136 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29255 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29255 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22856 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22856] = 30
                            mem[_22856 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23774 + 68] = mem[idx + _22856 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23774 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26839 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26839] = 30
                            mem[_26839 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28135 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28135 + 68] = mem[idx + _26839 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28135 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28135 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31707] = 30
                            mem[_31707 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32840 + 68] = mem[idx + _31707 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32840 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32840 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _22855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22855] = 30
                            mem[_22855 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23773 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23773 + 68] = mem[idx + _22855 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23773 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23773 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26837 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26837] = 30
                            mem[_26837 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28134 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28134 + 68] = mem[idx + _26837 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28134 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28134 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31705 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31705] = 30
                            mem[_31705 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32839 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32839 + 68] = mem[idx + _31705 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32839 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32839 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25663 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25663] = 30
                        mem[_25663 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26836 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26836 + 68] = mem[idx + _25663 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26836 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26836 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30354 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30354] = 30
                        mem[_30354 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31704 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31704 + 68] = mem[idx + _30354 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31704 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31704 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34611] = 30
                        mem[_34611 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35466 + 68] = mem[idx + _34611 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35466 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35466 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19134 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19134] = 30
                        mem[_19134 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19214 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19214 + 68] = mem[idx + _19134 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19214 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19214 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19567] = 30
                        mem[_19567 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19615 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19615 + 68] = mem[idx + _19567 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19615 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19615 + -mem[64] + 100
                    _19135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19135] = 26
                    mem[_19135 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19215 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19215 + 68] = mem[idx + _19135 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19215 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19215 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                return 0
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20544] = 30
                            mem[_20544 + 32] = 'SafeMath: subtraction overflow'
                            _22160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22160] = 30
                            mem[_22160 + 32] = 'SafeMath: subtraction overflow'
                            _25676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25676] = 30
                            mem[_25676 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26846 + 68] = mem[idx + _25676 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26846 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26846 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20543] = 30
                                mem[_20543 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20714 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20714 + 68] = mem[idx + _20543 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20714 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20714 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22158] = 30
                                mem[_22158 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22861 + 68] = mem[idx + _22158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22861 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25674 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25674] = 30
                                mem[_25674 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26845 + 68] = mem[idx + _25674 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26845 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21647 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21647] = 30
                            mem[_21647 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22157 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22157 + 68] = mem[idx + _21647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22157 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22157 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24732] = 30
                            mem[_24732 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25673 + 68] = mem[idx + _24732 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25673 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25673 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29271 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29271] = 30
                            mem[_29271 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30360 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30360 + 68] = mem[idx + _29271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30360 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30360 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21646 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21646] = 30
                            mem[_21646 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22156 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22156 + 68] = mem[idx + _21646 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22156 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22156 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24730] = 30
                            mem[_24730 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25672 + 68] = mem[idx + _24730 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25672 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29269] = 30
                            mem[_29269 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30359 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30359 + 68] = mem[idx + _29269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30359 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30359 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23786 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23786] = 30
                        mem[_23786 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24729 + 68] = mem[idx + _23786 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24729 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24729 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28151] = 30
                        mem[_28151 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _29268 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29268 + 68] = mem[idx + _28151 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29268 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29268 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32852] = 30
                        mem[_32852 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33536 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33536 + 68] = mem[idx + _32852 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33536 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33536 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _20541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20541] = 30
                            mem[_20541 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20713 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20713 + 68] = mem[idx + _20541 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20713 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20713 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _22154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22154] = 30
                            mem[_22154 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22859 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22859 + 68] = mem[idx + _22154 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22859 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22859 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25670] = 30
                            mem[_25670 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26844 + 68] = mem[idx + _25670 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26844 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26844 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21645 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21645] = 30
                        mem[_21645 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _22153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22153 + 68] = mem[idx + _21645 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22153 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _24727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24727] = 30
                        mem[_24727 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _25669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25669 + 68] = mem[idx + _24727 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25669 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25669 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _29266 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29266] = 30
                        mem[_29266 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _30357 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30357 + 68] = mem[idx + _29266 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30357 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30357 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21644] = 30
                            mem[_21644 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22152 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22152 + 68] = mem[idx + _21644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22152 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22152 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24725] = 30
                            mem[_24725 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25668 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25668 + 68] = mem[idx + _24725 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25668 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25668 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29264 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29264] = 30
                            mem[_29264 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30356 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30356 + 68] = mem[idx + _29264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30356 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30356 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23785] = 30
                        mem[_23785 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24724 + 68] = mem[idx + _23785 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24724 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24724 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28149] = 30
                        mem[_28149 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29263 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29263 + 68] = mem[idx + _28149 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29263 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29263 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32849] = 30
                        mem[_32849 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33533 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33533 + 68] = mem[idx + _32849 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33533 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33533 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _23784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23784] = 30
                        mem[_23784 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24723 + 68] = mem[idx + _23784 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24723 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28147] = 30
                        mem[_28147 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29262 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29262 + 68] = mem[idx + _28147 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29262 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29262 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32847 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32847] = 30
                        mem[_32847 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33532 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33532 + 68] = mem[idx + _32847 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33532 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33532 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26843 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26843] = 30
                    mem[_26843 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28146 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28146 + 68] = mem[idx + _26843 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28146 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28146 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31714] = 30
                    mem[_31714 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32846 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32846 + 68] = mem[idx + _31714 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32846 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32846 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35470 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35470] = 30
                    mem[_35470 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35772 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35772 + 68] = mem[idx + _35470 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35772 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35772 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                else:
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19040 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19040] = 26
                        mem[_19040 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19130 + 68] = mem[idx + _19040 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19130 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19130 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    if not 0 / stor14 / 100:
                                        return 0
                                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20305] = 30
                                    mem[_20305 + 32] = 'SafeMath: subtraction overflow'
                                    _21620 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21620] = 30
                                    mem[_21620 + 32] = 'SafeMath: subtraction overflow'
                                    _24687 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24687] = 30
                                    mem[_24687 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25642 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25642 + 68] = mem[idx + _24687 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25642 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25642 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20304 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20304] = 30
                                    mem[_20304 + 32] = 'SafeMath: subtraction overflow'
                                    _21619 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21619] = 30
                                    mem[_21619 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22130 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22130 + 68] = mem[idx + _21619 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22130 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22130 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24685 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24685] = 30
                                    mem[_24685 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25641 + 68] = mem[idx + _24685 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25641 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21115] = 30
                                mem[_21115 + 32] = 'SafeMath: subtraction overflow'
                                _23750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23750] = 30
                                mem[_23750 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24684 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24684 + 68] = mem[idx + _23750 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24684 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24684 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28102] = 30
                                mem[_28102 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29227 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29227 + 68] = mem[idx + _28102 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29227 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29227 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20303] = 30
                                    mem[_20303 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20530 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20530 + 68] = mem[idx + _20303 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20530 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20530 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21617] = 30
                                    mem[_21617 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _22129 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22129 + 68] = mem[idx + _21617 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22129 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22129 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24682 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24682] = 30
                                    mem[_24682 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25640 + 68] = mem[idx + _24682 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25640 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25640 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21114 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21114] = 30
                                mem[_21114 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21616 + 68] = mem[idx + _21114 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21616 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21616 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23748] = 30
                                mem[_23748 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24681 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24681 + 68] = mem[idx + _23748 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24681 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24681 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _28100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28100] = 30
                                mem[_28100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29225 + 68] = mem[idx + _28100 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29225 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21113] = 30
                                mem[_21113 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21615 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21615 + 68] = mem[idx + _21113 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21615 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21615 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23746] = 30
                                mem[_23746 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24680 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24680 + 68] = mem[idx + _23746 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24680 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24680 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28098] = 30
                                mem[_28098 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29224 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29224 + 68] = mem[idx + _28098 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29224 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29224 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22837 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22837] = 30
                            mem[_22837 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23745 + 68] = mem[idx + _22837 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23745 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26807] = 30
                            mem[_26807 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _28097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28097 + 68] = mem[idx + _26807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28097 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31673] = 30
                            mem[_31673 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32808 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32808 + 68] = mem[idx + _31673 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32808 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32808 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20301] = 30
                                    mem[_20301 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20529 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20529 + 68] = mem[idx + _20301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20529 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20529 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21613 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21613] = 30
                                    mem[_21613 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _22127 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22127 + 68] = mem[idx + _21613 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22127 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22127 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24678] = 30
                                    mem[_24678 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25639 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25639 + 68] = mem[idx + _24678 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25639 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25639 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21112 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21112] = 30
                                mem[_21112 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21612 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21612 + 68] = mem[idx + _21112 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21612 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21612 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23743] = 30
                                mem[_23743 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24677 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24677 + 68] = mem[idx + _23743 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24677 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24677 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _28095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28095] = 30
                                mem[_28095 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29222 + 68] = mem[idx + _28095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29222 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21111] = 30
                                mem[_21111 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21611 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21611 + 68] = mem[idx + _21111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21611 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21611 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23741] = 30
                                mem[_23741 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24676 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24676 + 68] = mem[idx + _23741 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24676 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24676 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28093] = 30
                                mem[_28093 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29221 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29221 + 68] = mem[idx + _28093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29221 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29221 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22836 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22836] = 30
                            mem[_22836 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23740 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23740 + 68] = mem[idx + _22836 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23740 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23740 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26805] = 30
                            mem[_26805 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _28092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28092 + 68] = mem[idx + _26805 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28092 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31670] = 30
                            mem[_31670 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32805 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32805 + 68] = mem[idx + _31670 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32805 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32805 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _21110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21110] = 30
                                mem[_21110 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21610 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21610 + 68] = mem[idx + _21110 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21610 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21610 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23738 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23738] = 30
                                mem[_23738 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24675 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24675 + 68] = mem[idx + _23738 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24675 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24675 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _28090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28090] = 30
                                mem[_28090 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29220 + 68] = mem[idx + _28090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29220 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22835] = 30
                            mem[_22835 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23737 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23737 + 68] = mem[idx + _22835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23737 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23737 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26803 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26803] = 30
                            mem[_26803 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28089 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28089 + 68] = mem[idx + _26803 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28089 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28089 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31668] = 30
                            mem[_31668 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32803 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32803 + 68] = mem[idx + _31668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32803 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32803 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22834] = 30
                            mem[_22834 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23736 + 68] = mem[idx + _22834 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23736 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23736 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26801] = 30
                            mem[_26801 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28088 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28088 + 68] = mem[idx + _26801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28088 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28088 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31666] = 30
                            mem[_31666 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32802 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32802 + 68] = mem[idx + _31666 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32802 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32802 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25638] = 30
                        mem[_25638 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26800 + 68] = mem[idx + _25638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26800 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26800 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30328] = 30
                        mem[_30328 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31665 + 68] = mem[idx + _30328 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31665 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31665 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34583 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34583] = 30
                        mem[_34583 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35439 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35439 + 68] = mem[idx + _34583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35439 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35439 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19131] = 30
                        mem[_19131 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19211 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19211 + 68] = mem[idx + _19131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19211 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19211 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19564 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19564] = 30
                        mem[_19564 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19612 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19612 + 68] = mem[idx + _19564 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19612 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19612 + -mem[64] + 100
                    _19132 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19132] = 26
                    mem[_19132 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19212 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19212 + 68] = mem[idx + _19132 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19212 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19212 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20537] = 30
                                mem[_20537 + 32] = 'SafeMath: subtraction overflow'
                                _22142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22142] = 30
                                mem[_22142 + 32] = 'SafeMath: subtraction overflow'
                                _25656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25656] = 30
                                mem[_25656 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26813 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26813 + 68] = mem[idx + _25656 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26813 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26813 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20536] = 30
                                mem[_20536 + 32] = 'SafeMath: subtraction overflow'
                                _22141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22141] = 30
                                mem[_22141 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22843 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22843 + 68] = mem[idx + _22141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22843 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22843 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25654] = 30
                                mem[_25654 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26812 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26812 + 68] = mem[idx + _25654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26812 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26812 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21627] = 30
                            mem[_21627 + 32] = 'SafeMath: subtraction overflow'
                            _24702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24702] = 30
                            mem[_24702 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _25653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25653 + 68] = mem[idx + _24702 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25653 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25653 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29244] = 30
                            mem[_29244 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30337 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30337 + 68] = mem[idx + _29244 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30337 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30337 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20535] = 30
                                mem[_20535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20707 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20707 + 68] = mem[idx + _20535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20707 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20707 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22139 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22139] = 30
                                mem[_22139 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22842 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22842 + 68] = mem[idx + _22139 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22842 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22842 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25651] = 30
                                mem[_25651 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26811 + 68] = mem[idx + _25651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26811 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26811 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21626 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21626] = 30
                            mem[_21626 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22138 + 68] = mem[idx + _21626 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22138 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24700] = 30
                            mem[_24700 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25650 + 68] = mem[idx + _24700 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25650 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25650 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29242 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29242] = 30
                            mem[_29242 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30335 + 68] = mem[idx + _29242 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30335 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30335 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21625] = 30
                            mem[_21625 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22137 + 68] = mem[idx + _21625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22137 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24698] = 30
                            mem[_24698 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25649 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25649 + 68] = mem[idx + _24698 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25649 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25649 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29240 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29240] = 30
                            mem[_29240 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30334 + 68] = mem[idx + _29240 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30334 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23754] = 30
                        mem[_23754 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24697 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24697 + 68] = mem[idx + _23754 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24697 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24697 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28112 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28112] = 30
                        mem[_28112 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _29239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29239 + 68] = mem[idx + _28112 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29239 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29239 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32820 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32820] = 30
                        mem[_32820 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33524 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33524 + 68] = mem[idx + _32820 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33524 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33524 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20533] = 30
                                mem[_20533 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20706 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20706 + 68] = mem[idx + _20533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20706 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20706 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _22135 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22135] = 30
                                mem[_22135 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22840 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22840 + 68] = mem[idx + _22135 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22840 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22840 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25647] = 30
                                mem[_25647 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26810 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26810 + 68] = mem[idx + _25647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26810 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26810 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21624] = 30
                            mem[_21624 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22134 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22134 + 68] = mem[idx + _21624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22134 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22134 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24695] = 30
                            mem[_24695 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25646 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25646 + 68] = mem[idx + _24695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25646 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25646 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29237] = 30
                            mem[_29237 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30332 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30332 + 68] = mem[idx + _29237 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30332 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30332 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21623] = 30
                            mem[_21623 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22133 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22133 + 68] = mem[idx + _21623 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22133 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22133 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24693] = 30
                            mem[_24693 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25645 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25645 + 68] = mem[idx + _24693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25645 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25645 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29235 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29235] = 30
                            mem[_29235 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30331 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30331 + 68] = mem[idx + _29235 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30331 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30331 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23753] = 30
                        mem[_23753 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24692 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24692 + 68] = mem[idx + _23753 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24692 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24692 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28110] = 30
                        mem[_28110 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29234 + 68] = mem[idx + _28110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29234 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29234 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32817] = 30
                        mem[_32817 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33521 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33521 + 68] = mem[idx + _32817 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33521 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33521 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _21622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21622] = 30
                            mem[_21622 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22132 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22132 + 68] = mem[idx + _21622 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22132 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22132 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24690] = 30
                            mem[_24690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25644 + 68] = mem[idx + _24690 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25644 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25644 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29232 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29232] = 30
                            mem[_29232 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30330 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30330 + 68] = mem[idx + _29232 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30330 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30330 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23752] = 30
                        mem[_23752 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24689 + 68] = mem[idx + _23752 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24689 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28108] = 30
                        mem[_28108 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29231 + 68] = mem[idx + _28108 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29231 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29231 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32815 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32815] = 30
                        mem[_32815 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33519 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33519 + 68] = mem[idx + _32815 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33519 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33519 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23751] = 30
                        mem[_23751 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24688 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24688 + 68] = mem[idx + _23751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24688 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24688 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28106] = 30
                        mem[_28106 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29230 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29230 + 68] = mem[idx + _28106 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29230 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29230 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32813] = 30
                        mem[_32813 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33518 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33518 + 68] = mem[idx + _32813 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33518 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33518 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26809 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26809] = 30
                    mem[_26809 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28105 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28105 + 68] = mem[idx + _26809 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28105 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28105 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31678] = 30
                    mem[_31678 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32812 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32812 + 68] = mem[idx + _31678 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32812 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32812 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35444] = 30
                    mem[_35444 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35767 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35767 + 68] = mem[idx + _35444 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35767 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35767 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if 0 / stor14 / 100:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if 0 / stor14 / 100:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and sub_a55d4d5c > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19039] = 26
                        mem[_19039 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19127 + 68] = mem[idx + _19039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19127 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19127 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor14 / 100:
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        return 0
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20292 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20292] = 30
                                    mem[_20292 + 32] = 'SafeMath: subtraction overflow'
                                    _21596 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21596] = 30
                                    mem[_21596 + 32] = 'SafeMath: subtraction overflow'
                                    _24644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24644] = 30
                                    mem[_24644 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25615 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25615 + 68] = mem[idx + _24644 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25615 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25615 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20291] = 30
                                    mem[_20291 + 32] = 'SafeMath: subtraction overflow'
                                    _21595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21595] = 30
                                    mem[_21595 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22106 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22106 + 68] = mem[idx + _21595 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22106 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22106 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24642] = 30
                                    mem[_24642 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25614 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25614 + 68] = mem[idx + _24642 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25614 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25614 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21093] = 30
                                mem[_21093 + 32] = 'SafeMath: subtraction overflow'
                                _23709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23709] = 30
                                mem[_23709 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24641 + 68] = mem[idx + _23709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24641 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28048 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28048] = 30
                                mem[_28048 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29190 + 68] = mem[idx + _28048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29190 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29190 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20290] = 30
                                    mem[_20290 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20521 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20521 + 68] = mem[idx + _20290 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20521 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20521 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21593] = 30
                                    mem[_21593 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        _22105 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22105 + 68] = mem[idx + _21593 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22105 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22105 + -mem[64] + 100
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24639] = 30
                                    mem[_24639 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25613 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25613 + 68] = mem[idx + _24639 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25613 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25613 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21092 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21092] = 30
                                mem[_21092 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21592 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21592 + 68] = mem[idx + _21092 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21592 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21592 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23707 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23707] = 30
                                mem[_23707 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24638 + 68] = mem[idx + _23707 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24638 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24638 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _28046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28046] = 30
                                mem[_28046 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29188 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29188 + 68] = mem[idx + _28046 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29188 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29188 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21091] = 30
                                mem[_21091 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21591 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21591 + 68] = mem[idx + _21091 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21591 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21591 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23705 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23705] = 30
                                mem[_23705 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _24637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24637 + 68] = mem[idx + _23705 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24637 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28044] = 30
                                mem[_28044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29187 + 68] = mem[idx + _28044 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29187 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29187 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22812] = 30
                            mem[_22812 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _23704 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23704 + 68] = mem[idx + _22812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23704 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23704 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26763] = 30
                            mem[_26763 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _28043 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28043 + 68] = mem[idx + _26763 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28043 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28043 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31624] = 30
                            mem[_31624 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32765 + 68] = mem[idx + _31624 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32765 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32765 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20288] = 30
                                    mem[_20288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20520 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20520 + 68] = mem[idx + _20288 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20520 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20520 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21589 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21589] = 30
                                    mem[_21589 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _22103 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22103 + 68] = mem[idx + _21589 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22103 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22103 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24635] = 30
                                    mem[_24635 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25612 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25612 + 68] = mem[idx + _24635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25612 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25612 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21090] = 30
                                mem[_21090 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21588 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21588 + 68] = mem[idx + _21090 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21588 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21588 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23702] = 30
                                mem[_23702 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24634 + 68] = mem[idx + _23702 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24634 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24634 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _28041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28041] = 30
                                mem[_28041 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29185 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29185 + 68] = mem[idx + _28041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29185 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29185 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21089] = 30
                                mem[_21089 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21587 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21587 + 68] = mem[idx + _21089 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21587 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21587 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23700 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23700] = 30
                                mem[_23700 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24633 + 68] = mem[idx + _23700 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24633 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24633 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _28039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28039] = 30
                                mem[_28039 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29184 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29184 + 68] = mem[idx + _28039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29184 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29184 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22811] = 30
                            mem[_22811 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23699 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23699 + 68] = mem[idx + _22811 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23699 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23699 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26761] = 30
                            mem[_26761 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _28038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28038 + 68] = mem[idx + _26761 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28038 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28038 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31621 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31621] = 30
                            mem[_31621 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32762 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32762 + 68] = mem[idx + _31621 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32762 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32762 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21088 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21088] = 30
                                mem[_21088 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21586 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21586 + 68] = mem[idx + _21088 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21586 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21586 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23697] = 30
                                mem[_23697 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    _24632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24632 + 68] = mem[idx + _23697 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24632 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _28036 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28036] = 30
                                mem[_28036 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29183 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29183 + 68] = mem[idx + _28036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29183 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29183 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22810 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22810] = 30
                            mem[_22810 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23696 + 68] = mem[idx + _22810 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23696 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26759] = 30
                            mem[_26759 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28035 + 68] = mem[idx + _26759 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28035 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28035 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31619] = 30
                            mem[_31619 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32760 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32760 + 68] = mem[idx + _31619 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32760 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32760 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _22809 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22809] = 30
                            mem[_22809 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23695 + 68] = mem[idx + _22809 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23695 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26757] = 30
                            mem[_26757 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _28034 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28034 + 68] = mem[idx + _26757 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28034 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28034 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31617] = 30
                            mem[_31617 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32759 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32759 + 68] = mem[idx + _31617 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32759 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32759 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25611] = 30
                        mem[_25611 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26756 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26756 + 68] = mem[idx + _25611 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26756 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26756 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30298 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30298] = 30
                        mem[_30298 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _31616 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31616 + 68] = mem[idx + _30298 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31616 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31616 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34549 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34549] = 30
                        mem[_34549 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35406 + 68] = mem[idx + _34549 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35406 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35406 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19128 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19128] = 30
                        mem[_19128 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19208 + 68] = mem[idx + _19128 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19208 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19561 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19561] = 30
                        mem[_19561 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19609 + 68] = mem[idx + _19561 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19609 + -mem[64] + 100
                    _19129 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19129] = 26
                    mem[_19129 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19209 + 68] = mem[idx + _19129 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19209 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19209 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20528] = 30
                                mem[_20528 + 32] = 'SafeMath: subtraction overflow'
                                _22118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22118] = 30
                                mem[_22118 + 32] = 'SafeMath: subtraction overflow'
                                _25629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25629] = 30
                                mem[_25629 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26769 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26769 + 68] = mem[idx + _25629 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26769 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26769 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20527] = 30
                                mem[_20527 + 32] = 'SafeMath: subtraction overflow'
                                _22117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22117] = 30
                                mem[_22117 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22818 + 68] = mem[idx + _22117 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22818 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22818 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25627] = 30
                                mem[_25627 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26768 + 68] = mem[idx + _25627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26768 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26768 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21603] = 30
                            mem[_21603 + 32] = 'SafeMath: subtraction overflow'
                            _24659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24659] = 30
                            mem[_24659 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _25626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25626 + 68] = mem[idx + _24659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25626 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25626 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29207 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29207] = 30
                            mem[_29207 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30307 + 68] = mem[idx + _29207 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30307 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30307 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20526 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20526] = 30
                                mem[_20526 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20699 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20699 + 68] = mem[idx + _20526 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20699 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20699 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22115] = 30
                                mem[_22115 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    _22817 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22817 + 68] = mem[idx + _22115 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22817 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22817 + -mem[64] + 100
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25624 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25624] = 30
                                mem[_25624 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26767 + 68] = mem[idx + _25624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26767 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26767 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21602] = 30
                            mem[_21602 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22114 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22114 + 68] = mem[idx + _21602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22114 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22114 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24657 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24657] = 30
                            mem[_24657 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25623 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25623 + 68] = mem[idx + _24657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25623 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25623 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29205] = 30
                            mem[_29205 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30305 + 68] = mem[idx + _29205 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30305 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30305 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21601] = 30
                            mem[_21601 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _22113 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22113 + 68] = mem[idx + _21601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22113 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22113 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24655] = 30
                            mem[_24655 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                _25622 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25622 + 68] = mem[idx + _24655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25622 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25622 + -mem[64] + 100
                            if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29203] = 30
                            mem[_29203 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30304 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30304 + 68] = mem[idx + _29203 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30304 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30304 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23713] = 30
                        mem[_23713 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                            _24654 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24654 + 68] = mem[idx + _23713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24654 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24654 + -mem[64] + 100
                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28058] = 30
                        mem[_28058 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                            _29202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29202 + 68] = mem[idx + _28058 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29202 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29202 + -mem[64] + 100
                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32777] = 30
                        mem[_32777 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33510 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33510 + 68] = mem[idx + _32777 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33510 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33510 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20524] = 30
                                mem[_20524 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20698 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20698 + 68] = mem[idx + _20524 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20698 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20698 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _22111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22111] = 30
                                mem[_22111 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22815 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22815 + 68] = mem[idx + _22111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22815 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22815 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25620] = 30
                                mem[_25620 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26766 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26766 + 68] = mem[idx + _25620 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26766 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26766 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21600] = 30
                            mem[_21600 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22110 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22110 + 68] = mem[idx + _21600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22110 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22110 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24652] = 30
                            mem[_24652 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25619 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25619 + 68] = mem[idx + _24652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25619 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25619 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29200] = 30
                            mem[_29200 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30302 + 68] = mem[idx + _29200 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30302 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30302 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21599 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21599] = 30
                            mem[_21599 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22109 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22109 + 68] = mem[idx + _21599 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22109 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22109 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24650] = 30
                            mem[_24650 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25618 + 68] = mem[idx + _24650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25618 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25618 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29198] = 30
                            mem[_29198 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30301 + 68] = mem[idx + _29198 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30301 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30301 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23712 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23712] = 30
                        mem[_23712 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24649 + 68] = mem[idx + _23712 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24649 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24649 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28056 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28056] = 30
                        mem[_28056 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29197 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29197 + 68] = mem[idx + _28056 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29197 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29197 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32774] = 30
                        mem[_32774 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33507 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33507 + 68] = mem[idx + _32774 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33507 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33507 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21598] = 30
                            mem[_21598 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22108 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22108 + 68] = mem[idx + _21598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22108 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22108 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24647 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24647] = 30
                            mem[_24647 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                _25617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25617 + 68] = mem[idx + _24647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25617 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29195 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29195] = 30
                            mem[_29195 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30300 + 68] = mem[idx + _29195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30300 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30300 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23711] = 30
                        mem[_23711 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24646 + 68] = mem[idx + _23711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24646 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24646 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28054] = 30
                        mem[_28054 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29194 + 68] = mem[idx + _28054 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29194 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29194 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32772 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32772] = 30
                        mem[_32772 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33505 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33505 + 68] = mem[idx + _32772 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33505 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33505 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _23710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23710] = 30
                        mem[_23710 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24645 + 68] = mem[idx + _23710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24645 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28052] = 30
                        mem[_28052 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            _29193 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29193 + 68] = mem[idx + _28052 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29193 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29193 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32770 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32770] = 30
                        mem[_32770 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33504 + 68] = mem[idx + _32770 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33504 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33504 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26765 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26765] = 30
                    mem[_26765 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _28051 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28051 + 68] = mem[idx + _26765 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28051 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28051 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31629] = 30
                    mem[_31629 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        _32769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32769 + 68] = mem[idx + _31629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32769 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32769 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35411 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35411] = 30
                    mem[_35411 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35762 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35762 + 68] = mem[idx + _35411 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35762 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35762 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
    else:
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor14:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19038] = 26
                        mem[_19038 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19124 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19124 + 68] = mem[idx + _19038 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19124 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19124 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20280] = 30
                                    mem[_20280 + 32] = 'SafeMath: subtraction overflow'
                                    _21574 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21574] = 30
                                    mem[_21574 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22085 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22085 + 68] = mem[idx + _21574 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22085 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22085 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24605] = 30
                                    mem[_24605 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25591 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25591 + 68] = mem[idx + _24605 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25591 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25591 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21073] = 30
                                mem[_21073 + 32] = 'SafeMath: subtraction overflow'
                                _23669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23669] = 30
                                mem[_23669 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24604 + 68] = mem[idx + _23669 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24604 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24604 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27996 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27996] = 30
                                mem[_27996 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29159 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29159 + 68] = mem[idx + _27996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29159 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29159 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20279] = 30
                                mem[_20279 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20513 + 68] = mem[idx + _20279 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20513 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20513 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _21572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21572] = 30
                                mem[_21572 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _22084 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22084 + 68] = mem[idx + _21572 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22084 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22084 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24602] = 30
                                mem[_24602 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25590 + 68] = mem[idx + _24602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25590 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25590 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21072 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21072] = 30
                                mem[_21072 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21571 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21571 + 68] = mem[idx + _21072 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21571 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21571 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23667 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23667] = 30
                                mem[_23667 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24601 + 68] = mem[idx + _23667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24601 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27994] = 30
                                mem[_27994 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29157 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29157 + 68] = mem[idx + _27994 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29157 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29157 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22788 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22788] = 30
                            mem[_22788 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _23666 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23666 + 68] = mem[idx + _22788 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23666 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23666 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26720 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26720] = 30
                            mem[_26720 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _27993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27993 + 68] = mem[idx + _26720 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27993 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27993 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31576] = 30
                            mem[_31576 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32726 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32726 + 68] = mem[idx + _31576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32726 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32726 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20277] = 30
                                mem[_20277 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20512 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20512 + 68] = mem[idx + _20277 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20512 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20512 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _21569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21569] = 30
                                mem[_21569 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22082 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22082 + 68] = mem[idx + _21569 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22082 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22082 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _24599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24599] = 30
                                mem[_24599 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _25589 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25589 + 68] = mem[idx + _24599 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25589 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25589 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21071] = 30
                                mem[_21071 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21568 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21568 + 68] = mem[idx + _21071 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21568 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21568 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23664] = 30
                                mem[_23664 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24598 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24598 + 68] = mem[idx + _23664 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24598 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24598 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27991 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27991] = 30
                                mem[_27991 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29155 + 68] = mem[idx + _27991 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29155 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29155 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22787 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22787] = 30
                            mem[_22787 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23663 + 68] = mem[idx + _22787 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23663 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23663 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26718 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26718] = 30
                            mem[_26718 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27990 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27990 + 68] = mem[idx + _26718 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27990 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27990 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31573] = 30
                            mem[_31573 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32724 + 68] = mem[idx + _31573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32724 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32724 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21070] = 30
                            mem[_21070 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _21567 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21567 + 68] = mem[idx + _21070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21567 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21567 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _23661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23661] = 30
                            mem[_23661 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _24597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24597 + 68] = mem[idx + _23661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24597 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24597 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _27988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27988] = 30
                            mem[_27988 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _29154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29154 + 68] = mem[idx + _27988 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29154 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29154 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22786 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22786] = 30
                            mem[_22786 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23660 + 68] = mem[idx + _22786 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23660 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23660 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26716] = 30
                            mem[_26716 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27987 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27987 + 68] = mem[idx + _26716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27987 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27987 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31571] = 30
                            mem[_31571 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32722 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32722 + 68] = mem[idx + _31571 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32722 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32722 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25588] = 30
                        mem[_25588 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26715 + 68] = mem[idx + _25588 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26715 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26715 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30271] = 30
                        mem[_30271 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _31570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31570 + 68] = mem[idx + _30271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31570 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34517 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34517] = 30
                        mem[_34517 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35376 + 68] = mem[idx + _34517 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35376 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35376 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19125] = 30
                        mem[_19125 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19205 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19205 + 68] = mem[idx + _19125 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19205 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19205 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19558] = 30
                        mem[_19558 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19606 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19606 + 68] = mem[idx + _19558 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19606 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19606 + -mem[64] + 100
                    _19126 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19126] = 26
                    mem[_19126 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19206 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19206 + 68] = mem[idx + _19126 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19206 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19206 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                return 0
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20519 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20519] = 30
                                mem[_20519 + 32] = 'SafeMath: subtraction overflow'
                                _22094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22094] = 30
                                mem[_22094 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22793 + 68] = mem[idx + _22094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22793 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25601 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25601] = 30
                                mem[_25601 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26725 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26725 + 68] = mem[idx + _25601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26725 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26725 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21579] = 30
                            mem[_21579 + 32] = 'SafeMath: subtraction overflow'
                            _24616 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24616] = 30
                            mem[_24616 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _25600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25600 + 68] = mem[idx + _24616 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25600 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29170 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29170] = 30
                            mem[_29170 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30278 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30278 + 68] = mem[idx + _29170 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30278 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30278 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _20518 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20518] = 30
                            mem[_20518 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _20691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20691 + 68] = mem[idx + _20518 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20691 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20691 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _22092 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22092] = 30
                            mem[_22092 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _22792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22792 + 68] = mem[idx + _22092 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22792 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22792 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25598] = 30
                            mem[_25598 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26724 + 68] = mem[idx + _25598 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26724 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26724 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21578 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21578] = 30
                            mem[_21578 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22091 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22091 + 68] = mem[idx + _21578 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22091 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22091 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24614] = 30
                            mem[_24614 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25597 + 68] = mem[idx + _24614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25597 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25597 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29168 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29168] = 30
                            mem[_29168 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30276 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30276 + 68] = mem[idx + _29168 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30276 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30276 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23672] = 30
                        mem[_23672 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24613 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24613 + 68] = mem[idx + _23672 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24613 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24613 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28004] = 30
                        mem[_28004 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _29167 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29167 + 68] = mem[idx + _28004 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29167 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29167 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32735] = 30
                        mem[_32735 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33497 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33497 + 68] = mem[idx + _32735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33497 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33497 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _20516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20516] = 30
                            mem[_20516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _20690 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20690 + 68] = mem[idx + _20516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20690 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20690 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _22089 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22089] = 30
                            mem[_22089 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22790 + 68] = mem[idx + _22089 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22790 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22790 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _25595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25595] = 30
                            mem[_25595 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _26723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26723 + 68] = mem[idx + _25595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26723 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21577] = 30
                            mem[_21577 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22088 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22088 + 68] = mem[idx + _21577 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22088 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22088 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24611 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24611] = 30
                            mem[_24611 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25594 + 68] = mem[idx + _24611 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25594 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29165] = 30
                            mem[_29165 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30274 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30274 + 68] = mem[idx + _29165 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30274 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30274 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23671] = 30
                        mem[_23671 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24610 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24610 + 68] = mem[idx + _23671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24610 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24610 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _28002 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28002] = 30
                        mem[_28002 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29164 + 68] = mem[idx + _28002 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29164 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29164 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32732 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32732] = 30
                        mem[_32732 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33495 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33495 + 68] = mem[idx + _32732 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33495 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33495 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _21576 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21576] = 30
                        mem[_21576 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _22087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22087 + 68] = mem[idx + _21576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22087 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22087 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _24608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24608] = 30
                        mem[_24608 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _25593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25593 + 68] = mem[idx + _24608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25593 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _29162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29162] = 30
                        mem[_29162 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _30273 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30273 + 68] = mem[idx + _29162 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30273 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30273 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23670 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23670] = 30
                        mem[_23670 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24607 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24607 + 68] = mem[idx + _23670 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24607 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24607 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _28000 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28000] = 30
                        mem[_28000 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29161 + 68] = mem[idx + _28000 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29161 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32730] = 30
                        mem[_32730 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33493 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33493 + 68] = mem[idx + _32730 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33493 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33493 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26722 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26722] = 30
                    mem[_26722 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27999 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27999 + 68] = mem[idx + _26722 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27999 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27999 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31580] = 30
                    mem[_31580 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _32729 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32729 + 68] = mem[idx + _31580 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32729 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32729 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35380] = 30
                    mem[_35380 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35758 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35758 + 68] = mem[idx + _35380 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35758 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35758 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if 0 / stor14 / 100:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if 0 / stor14 / 100:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and sub_a55d4d5c > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (0 / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19037] = 26
                        mem[_19037 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19121 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19121 + 68] = mem[idx + _19037 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19121 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19121 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        return 0
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20268 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20268] = 30
                                    mem[_20268 + 32] = 'SafeMath: subtraction overflow'
                                    _21553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21553] = 30
                                    mem[_21553 + 32] = 'SafeMath: subtraction overflow'
                                    _24568 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24568] = 30
                                    mem[_24568 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25567 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25567 + 68] = mem[idx + _24568 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25567 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25567 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20267] = 30
                                    mem[_20267 + 32] = 'SafeMath: subtraction overflow'
                                    _21552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21552] = 30
                                    mem[_21552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22066 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22066 + 68] = mem[idx + _21552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22066 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22066 + -mem[64] + 100
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24566] = 30
                                    mem[_24566 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25566 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25566 + 68] = mem[idx + _24566 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25566 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25566 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21055] = 30
                                mem[_21055 + 32] = 'SafeMath: subtraction overflow'
                                _23639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23639] = 30
                                mem[_23639 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24565 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24565 + 68] = mem[idx + _23639 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24565 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24565 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27953 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27953] = 30
                                mem[_27953 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29126 + 68] = mem[idx + _27953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29126 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29126 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20266] = 30
                                    mem[_20266 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20504 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20504 + 68] = mem[idx + _20266 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20504 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20504 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21550] = 30
                                    mem[_21550 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        _22065 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22065 + 68] = mem[idx + _21550 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22065 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22065 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24563 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24563] = 30
                                    mem[_24563 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25565 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25565 + 68] = mem[idx + _24563 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25565 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25565 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21054] = 30
                                mem[_21054 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21549 + 68] = mem[idx + _21054 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21549 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23637 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23637] = 30
                                mem[_23637 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24562 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24562 + 68] = mem[idx + _23637 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24562 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24562 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27951 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27951] = 30
                                mem[_27951 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29124 + 68] = mem[idx + _27951 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29124 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29124 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21053] = 30
                                mem[_21053 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21548 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21548 + 68] = mem[idx + _21053 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21548 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21548 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23635] = 30
                                mem[_23635 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24561 + 68] = mem[idx + _23635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24561 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24561 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27949 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27949] = 30
                                mem[_27949 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29123 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29123 + 68] = mem[idx + _27949 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29123 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29123 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22768] = 30
                            mem[_22768 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _23634 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23634 + 68] = mem[idx + _22768 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23634 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23634 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26688] = 30
                            mem[_26688 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _27948 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27948 + 68] = mem[idx + _26688 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27948 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27948 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31539] = 30
                            mem[_31539 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32691 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32691 + 68] = mem[idx + _31539 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32691 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32691 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20264] = 30
                                    mem[_20264 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20503 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20503 + 68] = mem[idx + _20264 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20503 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20503 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21546] = 30
                                    mem[_21546 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _22063 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22063 + 68] = mem[idx + _21546 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22063 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22063 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24559] = 30
                                    mem[_24559 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25564 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25564 + 68] = mem[idx + _24559 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25564 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25564 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21052] = 30
                                mem[_21052 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21545 + 68] = mem[idx + _21052 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21545 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21545 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23632 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23632] = 30
                                mem[_23632 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24558 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24558 + 68] = mem[idx + _23632 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24558 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24558 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27946 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27946] = 30
                                mem[_27946 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29121 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29121 + 68] = mem[idx + _27946 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29121 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29121 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21051] = 30
                                mem[_21051 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21544 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21544 + 68] = mem[idx + _21051 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21544 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21544 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23630] = 30
                                mem[_23630 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24557 + 68] = mem[idx + _23630 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24557 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24557 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27944] = 30
                                mem[_27944 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29120 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29120 + 68] = mem[idx + _27944 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29120 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29120 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22767 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22767] = 30
                            mem[_22767 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23629 + 68] = mem[idx + _22767 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23629 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26686] = 30
                            mem[_26686 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27943 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27943 + 68] = mem[idx + _26686 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27943 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27943 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31536] = 30
                            mem[_31536 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32688 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32688 + 68] = mem[idx + _31536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32688 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32688 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21050] = 30
                                mem[_21050 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21543 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21543 + 68] = mem[idx + _21050 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21543 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21543 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23627] = 30
                                mem[_23627 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    _24556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24556 + 68] = mem[idx + _23627 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24556 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24556 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27941 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27941] = 30
                                mem[_27941 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29119 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29119 + 68] = mem[idx + _27941 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29119 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29119 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22766 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22766] = 30
                            mem[_22766 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23626 + 68] = mem[idx + _22766 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23626 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23626 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26684 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26684] = 30
                            mem[_26684 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27940 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27940 + 68] = mem[idx + _26684 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27940 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27940 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31534 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31534] = 30
                            mem[_31534 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32686 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32686 + 68] = mem[idx + _31534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32686 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32686 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _22765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22765] = 30
                            mem[_22765 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23625 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23625 + 68] = mem[idx + _22765 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23625 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23625 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26682] = 30
                            mem[_26682 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27939 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27939 + 68] = mem[idx + _26682 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27939 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27939 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31532] = 30
                            mem[_31532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32685 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32685 + 68] = mem[idx + _31532 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32685 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32685 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25563 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25563] = 30
                        mem[_25563 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26681 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26681 + 68] = mem[idx + _25563 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26681 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26681 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30245] = 30
                        mem[_30245 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _31531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31531 + 68] = mem[idx + _30245 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31531 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31531 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34489] = 30
                        mem[_34489 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35349 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35349 + 68] = mem[idx + _34489 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35349 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35349 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19122 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19122] = 30
                        mem[_19122 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19202 + 68] = mem[idx + _19122 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19202 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19202 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19555] = 30
                        mem[_19555 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19603 + 68] = mem[idx + _19555 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19603 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19603 + -mem[64] + 100
                    _19123 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19123] = 26
                    mem[_19123 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19203 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19203 + 68] = mem[idx + _19123 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19203 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19203 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20511] = 30
                                mem[_20511 + 32] = 'SafeMath: subtraction overflow'
                                _22078 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22078] = 30
                                mem[_22078 + 32] = 'SafeMath: subtraction overflow'
                                _25581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25581] = 30
                                mem[_25581 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26694 + 68] = mem[idx + _25581 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26694 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20510] = 30
                                mem[_20510 + 32] = 'SafeMath: subtraction overflow'
                                _22077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22077] = 30
                                mem[_22077 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22774 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22774 + 68] = mem[idx + _22077 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22774 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22774 + -mem[64] + 100
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25579] = 30
                                mem[_25579 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26693 + 68] = mem[idx + _25579 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26693 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21560] = 30
                            mem[_21560 + 32] = 'SafeMath: subtraction overflow'
                            _24583 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24583] = 30
                            mem[_24583 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                _25578 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25578 + 68] = mem[idx + _24583 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25578 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25578 + -mem[64] + 100
                            if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29143] = 30
                            mem[_29143 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30254 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30254 + 68] = mem[idx + _29143 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30254 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30254 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20509 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20509] = 30
                                mem[_20509 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20687 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20687 + 68] = mem[idx + _20509 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20687 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20687 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22075] = 30
                                mem[_22075 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _22773 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22773 + 68] = mem[idx + _22075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22773 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22773 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25576] = 30
                                mem[_25576 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26692 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26692 + 68] = mem[idx + _25576 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26692 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26692 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21559] = 30
                            mem[_21559 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22074 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22074 + 68] = mem[idx + _21559 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22074 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22074 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24581] = 30
                            mem[_24581 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25575 + 68] = mem[idx + _24581 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25575 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29141] = 30
                            mem[_29141 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30252 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30252 + 68] = mem[idx + _29141 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30252 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30252 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21558] = 30
                            mem[_21558 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22073 + 68] = mem[idx + _21558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22073 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24579] = 30
                            mem[_24579 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25574 + 68] = mem[idx + _24579 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25574 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29139 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29139] = 30
                            mem[_29139 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30251 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30251 + 68] = mem[idx + _29139 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30251 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30251 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23643] = 30
                        mem[_23643 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24578 + 68] = mem[idx + _23643 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24578 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24578 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27963 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27963] = 30
                        mem[_27963 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _29138 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29138 + 68] = mem[idx + _27963 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29138 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29138 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32703] = 30
                        mem[_32703 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33485 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33485 + 68] = mem[idx + _32703 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33485 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33485 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20507] = 30
                                mem[_20507 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20686 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20686 + 68] = mem[idx + _20507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20686 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20686 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _22071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22071] = 30
                                mem[_22071 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22771 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22771 + 68] = mem[idx + _22071 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22771 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22771 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25572] = 30
                                mem[_25572 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26691 + 68] = mem[idx + _25572 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26691 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26691 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21557] = 30
                            mem[_21557 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22070 + 68] = mem[idx + _21557 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22070 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22070 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24576] = 30
                            mem[_24576 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25571 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25571 + 68] = mem[idx + _24576 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25571 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25571 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29136] = 30
                            mem[_29136 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30249 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30249 + 68] = mem[idx + _29136 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30249 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30249 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21556] = 30
                            mem[_21556 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22069 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22069 + 68] = mem[idx + _21556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22069 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22069 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24574 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24574] = 30
                            mem[_24574 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25570 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25570 + 68] = mem[idx + _24574 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25570 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25570 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29134] = 30
                            mem[_29134 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30248 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30248 + 68] = mem[idx + _29134 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30248 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30248 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23642] = 30
                        mem[_23642 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24573 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24573 + 68] = mem[idx + _23642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24573 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24573 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27961 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27961] = 30
                        mem[_27961 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29133 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29133 + 68] = mem[idx + _27961 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29133 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29133 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32700] = 30
                        mem[_32700 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33482 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33482 + 68] = mem[idx + _32700 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33482 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33482 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21555] = 30
                            mem[_21555 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22068 + 68] = mem[idx + _21555 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22068 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22068 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24571] = 30
                            mem[_24571 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _25569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25569 + 68] = mem[idx + _24571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25569 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25569 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29131] = 30
                            mem[_29131 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30247 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30247 + 68] = mem[idx + _29131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30247 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30247 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23641 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23641] = 30
                        mem[_23641 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24570 + 68] = mem[idx + _23641 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24570 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27959 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27959] = 30
                        mem[_27959 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29130 + 68] = mem[idx + _27959 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29130 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29130 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32698] = 30
                        mem[_32698 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33480 + 68] = mem[idx + _32698 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33480 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33480 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _23640 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23640] = 30
                        mem[_23640 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24569 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24569 + 68] = mem[idx + _23640 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24569 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24569 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27957 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27957] = 30
                        mem[_27957 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29129 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29129 + 68] = mem[idx + _27957 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29129 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29129 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32696] = 30
                        mem[_32696 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33479 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33479 + 68] = mem[idx + _32696 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33479 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33479 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26690 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26690] = 30
                    mem[_26690 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27956 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27956 + 68] = mem[idx + _26690 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27956 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27956 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31544 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31544] = 30
                    mem[_31544 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _32695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32695 + 68] = mem[idx + _31544 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32695 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32695 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35354] = 30
                    mem[_35354 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35753 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35753 + 68] = mem[idx + _35354 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35753 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35753 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * 0 / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (0 / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (0 / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor14:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < 0 / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19036] = 26
                        mem[_19036 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19118 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19118 + 68] = mem[idx + _19036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19118 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19118 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    if not 0 / stor14 / 100:
                                        return 0
                                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20255] = 30
                                    mem[_20255 + 32] = 'SafeMath: subtraction overflow'
                                    _21529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21529] = 30
                                    mem[_21529 + 32] = 'SafeMath: subtraction overflow'
                                    _24525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24525] = 30
                                    mem[_24525 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25540 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25540 + 68] = mem[idx + _24525 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25540 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25540 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    _20254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20254] = 30
                                    mem[_20254 + 32] = 'SafeMath: subtraction overflow'
                                    _21528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21528] = 30
                                    mem[_21528 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22042 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22042 + 68] = mem[idx + _21528 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22042 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22042 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24523] = 30
                                    mem[_24523 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25539 + 68] = mem[idx + _24523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25539 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25539 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21033] = 30
                                mem[_21033 + 32] = 'SafeMath: subtraction overflow'
                                _23598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23598] = 30
                                mem[_23598 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24522 + 68] = mem[idx + _23598 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24522 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24522 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27899] = 30
                                mem[_27899 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29089 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29089 + 68] = mem[idx + _27899 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29089 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29089 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20253 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20253] = 30
                                    mem[_20253 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20495 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20495 + 68] = mem[idx + _20253 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20495 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20495 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21526 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21526] = 30
                                    mem[_21526 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        _22041 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22041 + 68] = mem[idx + _21526 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22041 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22041 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24520 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24520] = 30
                                    mem[_24520 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25538 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25538 + 68] = mem[idx + _24520 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25538 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25538 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21032] = 30
                                mem[_21032 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21525 + 68] = mem[idx + _21032 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21525 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21525 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23596] = 30
                                mem[_23596 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24519 + 68] = mem[idx + _23596 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24519 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27897] = 30
                                mem[_27897 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29087 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29087 + 68] = mem[idx + _27897 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29087 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29087 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21031] = 30
                                mem[_21031 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21524 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21524 + 68] = mem[idx + _21031 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21524 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21524 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23594] = 30
                                mem[_23594 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24518 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24518 + 68] = mem[idx + _23594 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24518 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24518 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27895] = 30
                                mem[_27895 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29086 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29086 + 68] = mem[idx + _27895 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29086 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29086 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22743 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22743] = 30
                            mem[_22743 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _23593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23593 + 68] = mem[idx + _22743 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23593 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23593 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26644] = 30
                            mem[_26644 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _27894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27894 + 68] = mem[idx + _26644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27894 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27894 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31490] = 30
                            mem[_31490 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32648 + 68] = mem[idx + _31490 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32648 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    _20251 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20251] = 30
                                    mem[_20251 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20494 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20494 + 68] = mem[idx + _20251 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20494 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20494 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21522] = 30
                                    mem[_21522 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _22039 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22039 + 68] = mem[idx + _21522 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22039 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22039 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24516 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24516] = 30
                                    mem[_24516 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25537 + 68] = mem[idx + _24516 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25537 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25537 + -mem[64] + 100
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21030] = 30
                                mem[_21030 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21521 + 68] = mem[idx + _21030 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21521 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21521 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23591] = 30
                                mem[_23591 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24515 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24515 + 68] = mem[idx + _23591 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24515 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24515 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27892] = 30
                                mem[_27892 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29084 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29084 + 68] = mem[idx + _27892 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29084 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29084 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _21029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21029] = 30
                                mem[_21029 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21520 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21520 + 68] = mem[idx + _21029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21520 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21520 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23589 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23589] = 30
                                mem[_23589 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24514 + 68] = mem[idx + _23589 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24514 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24514 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27890] = 30
                                mem[_27890 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29083 + 68] = mem[idx + _27890 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29083 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22742 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22742] = 30
                            mem[_22742 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23588 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23588 + 68] = mem[idx + _22742 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23588 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23588 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26642] = 30
                            mem[_26642 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27889 + 68] = mem[idx + _26642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27889 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27889 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31487] = 30
                            mem[_31487 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32645 + 68] = mem[idx + _31487 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32645 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _21028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21028] = 30
                                mem[_21028 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21519 + 68] = mem[idx + _21028 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21519 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23586] = 30
                                mem[_23586 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    _24513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24513 + 68] = mem[idx + _23586 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24513 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24513 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27887] = 30
                                mem[_27887 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29082 + 68] = mem[idx + _27887 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29082 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22741 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22741] = 30
                            mem[_22741 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23585 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23585 + 68] = mem[idx + _22741 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23585 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23585 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26640] = 30
                            mem[_26640 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27886 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27886 + 68] = mem[idx + _26640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27886 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27886 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31485] = 30
                            mem[_31485 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32643 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32643 + 68] = mem[idx + _31485 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32643 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32643 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _22740 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22740] = 30
                            mem[_22740 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23584 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23584 + 68] = mem[idx + _22740 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23584 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23584 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26638] = 30
                            mem[_26638 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27885 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27885 + 68] = mem[idx + _26638 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27885 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27885 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31483] = 30
                            mem[_31483 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32642 + 68] = mem[idx + _31483 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32642 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32642 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25536] = 30
                        mem[_25536 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26637 + 68] = mem[idx + _25536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26637 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26637 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30215 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30215] = 30
                        mem[_30215 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _31482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31482 + 68] = mem[idx + _30215 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31482 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34455] = 30
                        mem[_34455 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35316 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35316 + 68] = mem[idx + _34455 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35316 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35316 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19119] = 30
                        mem[_19119 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19199 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19199 + 68] = mem[idx + _19119 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19199 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19199 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19552] = 30
                        mem[_19552 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19600 + 68] = mem[idx + _19552 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19600 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19600 + -mem[64] + 100
                    _19120 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19120] = 26
                    mem[_19120 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19200 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19200 + 68] = mem[idx + _19120 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19200 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19200 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    return 0
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20502] = 30
                                mem[_20502 + 32] = 'SafeMath: subtraction overflow'
                                _22054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22054] = 30
                                mem[_22054 + 32] = 'SafeMath: subtraction overflow'
                                _25554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25554] = 30
                                mem[_25554 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26650 + 68] = mem[idx + _25554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26650 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26650 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                _20501 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20501] = 30
                                mem[_20501 + 32] = 'SafeMath: subtraction overflow'
                                _22053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22053] = 30
                                mem[_22053 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22749 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22749 + 68] = mem[idx + _22053 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22749 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22749 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25552] = 30
                                mem[_25552 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26649 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26649 + 68] = mem[idx + _25552 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26649 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26649 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21536] = 30
                            mem[_21536 + 32] = 'SafeMath: subtraction overflow'
                            _24540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24540] = 30
                            mem[_24540 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _25551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25551 + 68] = mem[idx + _24540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25551 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29106 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29106] = 30
                            mem[_29106 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30224 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30224 + 68] = mem[idx + _29106 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30224 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30224 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20500] = 30
                                mem[_20500 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20679 + 68] = mem[idx + _20500 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20679 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20679 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22051] = 30
                                mem[_22051 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _22748 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22748 + 68] = mem[idx + _22051 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22748 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22748 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25549] = 30
                                mem[_25549 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26648 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26648 + 68] = mem[idx + _25549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26648 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26648 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21535 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21535] = 30
                            mem[_21535 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22050 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22050 + 68] = mem[idx + _21535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22050 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22050 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24538] = 30
                            mem[_24538 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25548 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25548 + 68] = mem[idx + _24538 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25548 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25548 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29104] = 30
                            mem[_29104 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30222 + 68] = mem[idx + _29104 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30222 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21534 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21534] = 30
                            mem[_21534 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22049 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22049 + 68] = mem[idx + _21534 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22049 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22049 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24536] = 30
                            mem[_24536 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25547 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25547 + 68] = mem[idx + _24536 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25547 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25547 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29102 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29102] = 30
                            mem[_29102 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30221 + 68] = mem[idx + _29102 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30221 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30221 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23602] = 30
                        mem[_23602 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24535 + 68] = mem[idx + _23602 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24535 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24535 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27909] = 30
                        mem[_27909 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _29101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29101 + 68] = mem[idx + _27909 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29101 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29101 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32660] = 30
                        mem[_32660 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33471 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33471 + 68] = mem[idx + _32660 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33471 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33471 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                _20498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20498] = 30
                                mem[_20498 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20678 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20678 + 68] = mem[idx + _20498 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20678 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20678 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _22047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22047] = 30
                                mem[_22047 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22746 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22746 + 68] = mem[idx + _22047 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22746 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22746 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25545] = 30
                                mem[_25545 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26647 + 68] = mem[idx + _25545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26647 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26647 + -mem[64] + 100
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21533] = 30
                            mem[_21533 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22046 + 68] = mem[idx + _21533 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22046 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24533] = 30
                            mem[_24533 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25544 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25544 + 68] = mem[idx + _24533 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25544 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25544 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29099 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29099] = 30
                            mem[_29099 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30219 + 68] = mem[idx + _29099 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30219 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30219 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            _21532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21532] = 30
                            mem[_21532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22045 + 68] = mem[idx + _21532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22045 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22045 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24531 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24531] = 30
                            mem[_24531 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25543 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25543 + 68] = mem[idx + _24531 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25543 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25543 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29097 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29097] = 30
                            mem[_29097 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30218 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30218 + 68] = mem[idx + _29097 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30218 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30218 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23601] = 30
                        mem[_23601 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24530 + 68] = mem[idx + _23601 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24530 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24530 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27907 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27907] = 30
                        mem[_27907 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29096 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29096 + 68] = mem[idx + _27907 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29096 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29096 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32657] = 30
                        mem[_32657 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33468 + 68] = mem[idx + _32657 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33468 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33468 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            _21531 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21531] = 30
                            mem[_21531 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22044 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22044 + 68] = mem[idx + _21531 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22044 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22044 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24528 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24528] = 30
                            mem[_24528 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _25542 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25542 + 68] = mem[idx + _24528 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25542 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25542 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29094 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29094] = 30
                            mem[_29094 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30217 + 68] = mem[idx + _29094 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30217 + -mem[64] + 100
                        if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                            revert with 0, 17
                        if not 0 / stor14 / 100:
                            revert with 0, 18
                        if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23600 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23600] = 30
                        mem[_23600 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24527 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24527 + 68] = mem[idx + _23600 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24527 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24527 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27905] = 30
                        mem[_27905 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29093 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29093 + 68] = mem[idx + _27905 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29093 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29093 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32655] = 30
                        mem[_32655 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33466 + 68] = mem[idx + _32655 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33466 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33466 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor14 / 100:
                        _23599 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23599] = 30
                        mem[_23599 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24526 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24526 + 68] = mem[idx + _23599 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24526 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24526 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27903 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27903] = 30
                        mem[_27903 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29092 + 68] = mem[idx + _27903 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29092 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29092 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32653] = 30
                        mem[_32653 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33465 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33465 + 68] = mem[idx + _32653 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33465 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33465 + -mem[64] + 100
                    if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                        revert with 0, 17
                    if not 0 / stor14 / 100:
                        revert with 0, 18
                    if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26646 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26646] = 30
                    mem[_26646 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27902 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27902 + 68] = mem[idx + _26646 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27902 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27902 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31495 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31495] = 30
                    mem[_31495 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _32652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32652 + 68] = mem[idx + _31495 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32652 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32652 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35321 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35321] = 30
                    mem[_35321 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35748 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35748 + 68] = mem[idx + _35321 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35748 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35748 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if 0 / stor14 / 100:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not 0 / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                        revert with 0, 17
                                    if not 0 / stor14 / 100:
                                        revert with 0, 18
                                    if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and t / s > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * t / s / 0 / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0 / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if 0 / stor14 / 100:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                    revert with 0, 17
                                if not 0 / stor14 / 100:
                                    revert with 0, 18
                                if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor14 / 100 and stor16 / totalSupply > -1 / 0 / stor14 / 100:
                                revert with 0, 17
                            if not 0 / stor14 / 100:
                                revert with 0, 18
                            if 0 / stor14 / 100 * stor16 / totalSupply / 0 / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0 / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and sub_a55d4d5c > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * sub_a55d4d5c / arg1 != sub_a55d4d5c:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor14:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor14 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor14 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) < arg1 * _BURN_FEE / stor14 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * sub_a55d4d5c / stor14 / 100 > arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor14 / 100) - (arg1 * _BURN_FEE / stor14 / 100) < arg1 * sub_a55d4d5c / stor14 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19035] = 26
                        mem[_19035 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19115 + 68] = mem[idx + _19035 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19115 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19115 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        return 0
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20242] = 30
                                    mem[_20242 + 32] = 'SafeMath: subtraction overflow'
                                    _21505 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21505] = 30
                                    mem[_21505 + 32] = 'SafeMath: subtraction overflow'
                                    _24482 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24482] = 30
                                    mem[_24482 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                        if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25513 + 68] = mem[idx + _24482 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25513 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25513 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20241] = 30
                                    mem[_20241 + 32] = 'SafeMath: subtraction overflow'
                                    _21504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21504] = 30
                                    mem[_21504 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _22018 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22018 + 68] = mem[idx + _21504 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22018 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22018 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _24480 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24480] = 30
                                    mem[_24480 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25512 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25512 + 68] = mem[idx + _24480 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25512 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25512 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21011 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21011] = 30
                                mem[_21011 + 32] = 'SafeMath: subtraction overflow'
                                _23557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23557] = 30
                                mem[_23557 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _24479 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24479 + 68] = mem[idx + _23557 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24479 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24479 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27845 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27845] = 30
                                mem[_27845 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29052 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29052 + 68] = mem[idx + _27845 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29052 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29052 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20240 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20240] = 30
                                    mem[_20240 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                        _20486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20486 + 68] = mem[idx + _20240 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20486 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    _21502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21502] = 30
                                    mem[_21502 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        _22017 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22017 + 68] = mem[idx + _21502 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22017 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22017 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24477 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24477] = 30
                                    mem[_24477 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25511 + 68] = mem[idx + _24477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25511 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25511 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21010 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21010] = 30
                                mem[_21010 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21501 + 68] = mem[idx + _21010 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21501 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21501 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23555] = 30
                                mem[_23555 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24476 + 68] = mem[idx + _23555 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24476 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24476 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27843 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27843] = 30
                                mem[_27843 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29050 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29050 + 68] = mem[idx + _27843 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29050 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29050 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21009] = 30
                                mem[_21009 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _21500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21500 + 68] = mem[idx + _21009 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21500 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21500 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23553] = 30
                                mem[_23553 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _24475 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24475 + 68] = mem[idx + _23553 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24475 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24475 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27841] = 30
                                mem[_27841 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29049 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29049 + 68] = mem[idx + _27841 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29049 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29049 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22718 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22718] = 30
                            mem[_22718 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _23552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23552 + 68] = mem[idx + _22718 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23552 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23552 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26600] = 30
                            mem[_26600 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _27840 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27840 + 68] = mem[idx + _26600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27840 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27840 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31441 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31441] = 30
                            mem[_31441 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32605 + 68] = mem[idx + _31441 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32605 + -mem[64] + 100
                        if arg1 and stor16 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    _20238 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20238] = 30
                                    mem[_20238 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _20485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20485 + 68] = mem[idx + _20238 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20485 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20485 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _21498 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21498] = 30
                                    mem[_21498 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor16 / totalSupply:
                                        _22015 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22015 + 68] = mem[idx + _21498 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22015 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22015 + -mem[64] + 100
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    _24473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24473] = 30
                                    mem[_24473 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor16 / totalSupply:
                                        if arg1 * stor16 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor16 / totalSupply)
                                    _25510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25510 + 68] = mem[idx + _24473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25510 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25510 + -mem[64] + 100
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21008] = 30
                                mem[_21008 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21497 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21497 + 68] = mem[idx + _21008 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21497 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21497 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23550] = 30
                                mem[_23550 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _24472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24472 + 68] = mem[idx + _23550 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24472 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _27838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27838] = 30
                                mem[_27838 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29047 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29047 + 68] = mem[idx + _27838 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29047 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29047 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21007] = 30
                                mem[_21007 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _21496 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21496 + 68] = mem[idx + _21007 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21496 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21496 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _23548 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23548] = 30
                                mem[_23548 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _24471 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24471 + 68] = mem[idx + _23548 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24471 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24471 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _27836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27836] = 30
                                mem[_27836 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29046 + 68] = mem[idx + _27836 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29046 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22717 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22717] = 30
                            mem[_22717 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _23547 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23547 + 68] = mem[idx + _22717 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23547 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23547 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _26598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26598] = 30
                            mem[_26598 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _27835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27835 + 68] = mem[idx + _26598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27835 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31438 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31438] = 30
                            mem[_31438 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32602 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32602 + 68] = mem[idx + _31438 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32602 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32602 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _21006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21006] = 30
                                mem[_21006 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                    _21495 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21495 + 68] = mem[idx + _21006 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21495 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21495 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _23545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23545] = 30
                                mem[_23545 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    _24470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24470 + 68] = mem[idx + _23545 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24470 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24470 + -mem[64] + 100
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                _27833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27833] = 30
                                mem[_27833 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _29045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29045 + 68] = mem[idx + _27833 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29045 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29045 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22716] = 30
                            mem[_22716 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23544 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23544 + 68] = mem[idx + _22716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23544 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23544 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26596] = 30
                            mem[_26596 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27832 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27832 + 68] = mem[idx + _26596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27832 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27832 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _31436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31436] = 30
                            mem[_31436 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32600 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32600 + 68] = mem[idx + _31436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32600 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32600 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _22715 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22715] = 30
                            mem[_22715 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _23543 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23543 + 68] = mem[idx + _22715 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23543 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23543 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _26594 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26594] = 30
                            mem[_26594 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _27831 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27831 + 68] = mem[idx + _26594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27831 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27831 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _31434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31434] = 30
                            mem[_31434 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _32599 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32599 + 68] = mem[idx + _31434 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32599 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32599 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25509 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25509] = 30
                        mem[_25509 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _26593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26593 + 68] = mem[idx + _25509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26593 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _30185 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30185] = 30
                        mem[_30185 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _31433 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31433 + 68] = mem[idx + _30185 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31433 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31433 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _34421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34421] = 30
                        mem[_34421 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _35283 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35283 + 68] = mem[idx + _34421 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35283 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35283 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19116] = 30
                        mem[_19116 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19196 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19196 + 68] = mem[idx + _19116 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19196 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19196 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19549 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19549] = 30
                        mem[_19549 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19597 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19597 + 68] = mem[idx + _19549 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19597 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19597 + -mem[64] + 100
                    _19117 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19117] = 26
                    mem[_19117 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19197 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19197 + 68] = mem[idx + _19117 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19197 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19197 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    return 0
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20493] = 30
                                mem[_20493 + 32] = 'SafeMath: subtraction overflow'
                                _22030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22030] = 30
                                mem[_22030 + 32] = 'SafeMath: subtraction overflow'
                                _25527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25527] = 30
                                mem[_25527 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= 0:
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26606 + 68] = mem[idx + _25527 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26606 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20492 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20492] = 30
                                mem[_20492 + 32] = 'SafeMath: subtraction overflow'
                                _22029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22029] = 30
                                mem[_22029 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _22724 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22724 + 68] = mem[idx + _22029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22724 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22724 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _25525 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25525] = 30
                                mem[_25525 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26605 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26605 + 68] = mem[idx + _25525 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26605 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26605 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21512] = 30
                            mem[_21512 + 32] = 'SafeMath: subtraction overflow'
                            _24497 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24497] = 30
                            mem[_24497 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _25524 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25524 + 68] = mem[idx + _24497 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25524 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25524 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29069 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29069] = 30
                            mem[_29069 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30194 + 68] = mem[idx + _29069 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30194 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30194 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20491] = 30
                                mem[_20491 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    _20671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20671 + 68] = mem[idx + _20491 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20671 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                _22027 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22027] = 30
                                mem[_22027 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    _22723 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22723 + 68] = mem[idx + _22027 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22723 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22723 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25522] = 30
                                mem[_25522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26604 + 68] = mem[idx + _25522 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26604 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21511] = 30
                            mem[_21511 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22026 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22026 + 68] = mem[idx + _21511 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22026 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22026 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24495] = 30
                            mem[_24495 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25521 + 68] = mem[idx + _24495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25521 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29067 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29067] = 30
                            mem[_29067 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30192 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30192 + 68] = mem[idx + _29067 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30192 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30192 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21510 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21510] = 30
                            mem[_21510 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                _22025 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22025 + 68] = mem[idx + _21510 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22025 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22025 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24493] = 30
                            mem[_24493 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                _25520 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25520 + 68] = mem[idx + _24493 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25520 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25520 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29065] = 30
                            mem[_29065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30191 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30191 + 68] = mem[idx + _29065 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30191 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30191 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23561 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23561] = 30
                        mem[_23561 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                            _24492 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24492 + 68] = mem[idx + _23561 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24492 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24492 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27855 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27855] = 30
                        mem[_27855 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            _29064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29064 + 68] = mem[idx + _27855 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29064 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29064 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32617] = 30
                        mem[_32617 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33457 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33457 + 68] = mem[idx + _32617 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33457 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33457 + -mem[64] + 100
                    if arg1 and stor16 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                _20489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20489] = 30
                                mem[_20489 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _20670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20670 + 68] = mem[idx + _20489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20670 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20670 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _22023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22023] = 30
                                mem[_22023 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor16 / totalSupply:
                                    _22721 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22721 + 68] = mem[idx + _22023 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22721 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22721 + -mem[64] + 100
                                if arg1 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                _25518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25518] = 30
                                mem[_25518 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor16 / totalSupply:
                                    if arg1 * stor16 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor16 / totalSupply)
                                _26603 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26603 + 68] = mem[idx + _25518 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26603 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26603 + -mem[64] + 100
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21509] = 30
                            mem[_21509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22022 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22022 + 68] = mem[idx + _21509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22022 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22022 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24490] = 30
                            mem[_24490 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _25517 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25517 + 68] = mem[idx + _24490 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25517 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25517 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _29062 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29062] = 30
                            mem[_29062 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= arg1 * stor16 / totalSupply:
                                if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30189 + 68] = mem[idx + _29062 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30189 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30189 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21508 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21508] = 30
                            mem[_21508 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                _22021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22021 + 68] = mem[idx + _21508 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22021 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22021 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            _24488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24488] = 30
                            mem[_24488 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _25516 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25516 + 68] = mem[idx + _24488 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25516 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25516 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _29060 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29060] = 30
                            mem[_29060 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30188 + 68] = mem[idx + _29060 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30188 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30188 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23560] = 30
                        mem[_23560 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor16 / totalSupply:
                            _24487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24487 + 68] = mem[idx + _23560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24487 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < 0:
                            revert with 0, 17
                        _27853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27853] = 30
                        mem[_27853 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _29059 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29059 + 68] = mem[idx + _27853 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29059 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29059 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32614 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32614] = 30
                        mem[_32614 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33454 + 68] = mem[idx + _32614 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33454 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33454 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            _21507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21507] = 30
                            mem[_21507 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                _22020 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22020 + 68] = mem[idx + _21507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22020 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22020 + -mem[64] + 100
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            _24485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24485] = 30
                            mem[_24485 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                _25515 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25515 + 68] = mem[idx + _24485 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25515 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25515 + -mem[64] + 100
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            _29057 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29057] = 30
                            mem[_29057 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor16 / totalSupply)
                            _30187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30187 + 68] = mem[idx + _29057 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30187 + -mem[64] + 100
                        if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            revert with 0, 18
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23559] = 30
                        mem[_23559 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24484 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24484 + 68] = mem[idx + _23559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24484 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24484 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27851 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27851] = 30
                        mem[_27851 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29056 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29056 + 68] = mem[idx + _27851 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29056 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29056 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                            revert with 0, 17
                        _32612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32612] = 30
                        mem[_32612 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33452 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33452 + 68] = mem[idx + _32612 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33452 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33452 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        _23558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23558] = 30
                        mem[_23558 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                            _24483 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24483 + 68] = mem[idx + _23558 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24483 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24483 + -mem[64] + 100
                        if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _27849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27849] = 30
                        mem[_27849 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                            _29055 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29055 + 68] = mem[idx + _27849 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29055 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29055 + -mem[64] + 100
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        _32610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32610] = 30
                        mem[_32610 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor16 / totalSupply)
                        _33451 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33451 + 68] = mem[idx + _32610 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33451 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33451 + -mem[64] + 100
                    if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                        revert with 0, 18
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26602] = 30
                    mem[_26602 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                        _27848 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27848 + 68] = mem[idx + _26602 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27848 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27848 + -mem[64] + 100
                    if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _31446 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31446] = 30
                    mem[_31446 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                        _32609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32609 + 68] = mem[idx + _31446 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32609 + -mem[64] + 100
                    if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                        revert with 0, 17
                    _35288 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35288] = 30
                    mem[_35288 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply <= (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                        if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor16 / totalSupply)
                    _35743 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35743 + 68] = mem[idx + _35288 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35743 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35743 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 17
                                    if not arg1 * sub_a55d4d5c / stor14 / 100:
                                        revert with 0, 18
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor14 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor14 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor14 / 100 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * t / s / arg1 * _TAX_FEE / stor14 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * t / s / arg1 * _BURN_FEE / stor14 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and t / s > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s / arg1 * sub_a55d4d5c / stor14 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) < arg1 * _BURN_FEE / stor14 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor14 / 100 * t / s) - (arg1 * _BURN_FEE / stor14 / 100 * t / s) < arg1 * sub_a55d4d5c / stor14 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor14 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 17
                                if not arg1 * sub_a55d4d5c / stor14 / 100:
                                    revert with 0, 18
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                                if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor14 / 100:
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor14 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _TAX_FEE / stor14 / 100 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor14 / 100:
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor14 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply / arg1 * _BURN_FEE / stor14 / 100 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * sub_a55d4d5c / stor14 / 100:
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * sub_a55d4d5c / stor14 / 100 and stor16 / totalSupply > -1 / arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 17
                            if not arg1 * sub_a55d4d5c / stor14 / 100:
                                revert with 0, 18
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply / arg1 * sub_a55d4d5c / stor14 / 100 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply > arg1 * stor16 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor16 / totalSupply < arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
                            if arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply > (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor16 / totalSupply) - (arg1 * _TAX_FEE / stor14 / 100 * stor16 / totalSupply) - (arg1 * _BURN_FEE / stor14 / 100 * stor16 / totalSupply) < arg1 * sub_a55d4d5c / stor14 / 100 * stor16 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor16 / totalSupply)
}



}

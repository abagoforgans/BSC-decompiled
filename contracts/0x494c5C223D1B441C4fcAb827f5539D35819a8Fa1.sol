contract main {




// =====================  Runtime code  =====================


#
#  - add(uint256 arg1, address arg2, bool arg3)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2)
#
const sub_1b4d1981(?) = 2

const sub_2ea83516(?) = 10

const sub_be279845(?) = 10

const sub_fc246dda(?) = (40 * 3600)

const BONUS_BLOCKNUM = (120 * 24 * 3600)

const MINTEND_BLOCKNUM = (320 * 3600)


address owner;
address sub_c3c5a5acAddress;
address devaddr;
uint256 betaTestEndBlock;
uint256 bonusEndBlock;
uint256 mintEndBlock;
uint256 sub_9aae7b7d;
uint32 stor7;
address migratorAddress;
uint256 stor7;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function bonusEndBlock() payable {
    return bonusEndBlock
}

function mintEndBlock() payable {
    return mintEndBlock
}

function betaTestEndBlock() payable {
    return betaTestEndBlock
}

function startBlock() payable {
    return startBlock
}

function migrator() payable {
    return address(migratorAddress)
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function sub_9aae7b7d(?) payable {
    return sub_9aae7b7d
}

function sub_c3c5a5ac(?) payable {
    return sub_c3c5a5acAddress
}

function devaddr() payable {
    return devaddr
}

function _fallback() payable {
    revert
}

function dev(address arg1) payable {
    require calldata.size - 4 >= 32
    if devaddr != msg.sender:
        revert with 0, 'BnEX::Master::dev::FORBIDDEN'
    devaddr = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setMigrator(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(migratorAddress) = arg1
}

function sub_9e80f188(?) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(sub_c3c5a5acAddress)
    call sub_c3c5a5acAddress.0xf2fde38b with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function recoverERC20(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    43,
                    0x77426e45583a3a4d61737465723a3a7265636f76657245524332303a3a5452414e534645525f4641494c45,
                    mem[207 len 21]
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][msg.sender].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x445361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x445361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][msg.sender].field_0, msg.sender, arg1);
    userInfo[arg1][msg.sender].field_0 = 0
    userInfo[arg1][msg.sender].field_256 = 0
}

function migrate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not address(migratorAddress):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x64426e45583a3a4d61737465723a3a6d6967726174653a3a4d49475241544f525f4e4f545f45584953,
                    mem[205 len 23]
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(migratorAddress)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        54,
                        0x545361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                        mem[218 len 10]
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor7), uint32(stor7), ext_call.return_data[0 len 28]
    mem[324 len 0] = 0
    call poolInfo[arg1].field_0 with:
       funct uint32(stor7)
         gas gas_remaining wei
        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor7), uint32(stor7), ext_call.return_data[0]
        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor7):
            revert with 0, 32, 42, 0x445361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
        require ext_code.size(address(migratorAddress))
        call address(migratorAddress).migrate(address rg1) with:
             gas gas_remaining wei
            args poolInfo[arg1].field_0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] != ext_call.return_data[0]:
            revert with 0, 32, 36, 0x73426e45583a3a4d61737465723a3a6d6967726174653a3a4552524f525f42414c414e43, mem[364 len 28]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x445361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
        require ext_code.size(address(migratorAddress))
        call address(migratorAddress).migrate(address rg1) with:
             gas gas_remaining wei
            args poolInfo[arg1].field_0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        36,
                        0x73426e45583a3a4d61737465723a3a6d6967726174653a3a4552524f525f42414c414e43,
                        mem[ceil32(return_data.size) + 365 len 28]
    ('eq', ('ext_call.return_data', 0, 32), ('ext_call.return_data', 0, 32))
    poolInfo[arg1].field_0 = address(ext_call.return_data[0])
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > mintEndBlock:
        if mintEndBlock <= betaTestEndBlock:
            if arg1 > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            return (mintEndBlock - arg1)
        if arg1 >= mintEndBlock:
            return 0
        if mintEndBlock <= bonusEndBlock:
            if arg1 >= betaTestEndBlock:
                if arg1 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - arg1:
                    return 0
                if (10 * mintEndBlock) - (10 * arg1) / mintEndBlock - arg1 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                return ((10 * mintEndBlock) - (10 * arg1))
            if betaTestEndBlock > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - betaTestEndBlock:
                if arg1 > betaTestEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (betaTestEndBlock - arg1)
            if (10 * mintEndBlock) - (10 * betaTestEndBlock) / mintEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if arg1 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * mintEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            return ((10 * mintEndBlock) - (9 * betaTestEndBlock) - arg1)
        if arg1 >= betaTestEndBlock:
            if betaTestEndBlock > arg1:
                if arg1 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - arg1:
                    return 0
                if 2 * mintEndBlock - arg1 / mintEndBlock - arg1 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                return (2 * mintEndBlock - arg1)
            if arg1 >= bonusEndBlock:
                if arg1 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - arg1:
                    return 0
                if 2 * mintEndBlock - arg1 / mintEndBlock - arg1 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                return (2 * mintEndBlock - arg1)
            if bonusEndBlock > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - bonusEndBlock:
                if arg1 > bonusEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - arg1:
                    return 0
                if (10 * bonusEndBlock) - (10 * arg1) / bonusEndBlock - arg1 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                return ((10 * bonusEndBlock) - (10 * arg1))
            if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - arg1:
                if 2 * mintEndBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return (2 * mintEndBlock - bonusEndBlock)
            if (10 * bonusEndBlock) - (10 * arg1) / bonusEndBlock - arg1 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if 2 * mintEndBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * arg1))
        if bonusEndBlock > mintEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not mintEndBlock - bonusEndBlock:
            if betaTestEndBlock > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - betaTestEndBlock:
                if arg1 > betaTestEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (betaTestEndBlock - arg1)
            if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if arg1 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            return ((10 * bonusEndBlock) - (9 * betaTestEndBlock) - arg1)
        if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if betaTestEndBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - betaTestEndBlock:
            if arg1 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if 2 * mintEndBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - arg1)
        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if arg1 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if 2 * mintEndBlock - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - arg1)
    if arg2 <= betaTestEndBlock:
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        return (arg2 - arg1)
    if arg1 >= mintEndBlock:
        return 0
    if arg2 <= bonusEndBlock:
        if arg1 >= betaTestEndBlock:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if not arg2 - arg1:
                return 0
            if (10 * arg2) - (10 * arg1) / arg2 - arg1 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            return ((10 * arg2) - (10 * arg1))
        if betaTestEndBlock > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        if not arg2 - betaTestEndBlock:
            if arg1 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            return (betaTestEndBlock - arg1)
        if (10 * arg2) - (10 * betaTestEndBlock) / arg2 - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if arg1 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * arg2) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        return ((10 * arg2) - (9 * betaTestEndBlock) - arg1)
    if arg1 >= betaTestEndBlock:
        if betaTestEndBlock > arg1:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if not arg2 - arg1:
                return 0
            if 2 * arg2 - arg1 / arg2 - arg1 != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            return (2 * arg2 - arg1)
        if arg1 >= bonusEndBlock:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if not arg2 - arg1:
                return 0
            if 2 * arg2 - arg1 / arg2 - arg1 != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            return (2 * arg2 - arg1)
        if bonusEndBlock > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        if not arg2 - bonusEndBlock:
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - arg1:
                return 0
            if (10 * bonusEndBlock) - (10 * arg1) / bonusEndBlock - arg1 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            return ((10 * bonusEndBlock) - (10 * arg1))
        if 2 * arg2 - bonusEndBlock / arg2 - bonusEndBlock != 2:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - arg1:
            if 2 * arg2 - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            return (2 * arg2 - bonusEndBlock)
        if (10 * bonusEndBlock) - (10 * arg1) / bonusEndBlock - arg1 != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if 2 * arg2 - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((2 * arg2 - bonusEndBlock) + (10 * bonusEndBlock) - (10 * arg1))
    if bonusEndBlock > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    if not arg2 - bonusEndBlock:
        if betaTestEndBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - betaTestEndBlock:
            if arg1 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            return (betaTestEndBlock - arg1)
        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if arg1 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        return ((10 * bonusEndBlock) - (9 * betaTestEndBlock) - arg1)
    if 2 * arg2 - bonusEndBlock / arg2 - bonusEndBlock != 2:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if betaTestEndBlock > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if not bonusEndBlock - betaTestEndBlock:
        if arg1 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if 2 * arg2 - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((2 * arg2 - bonusEndBlock) + betaTestEndBlock - arg1)
    if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if arg1 > betaTestEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
        revert with 0, 'SafeMath: addition overflow'
    if 2 * arg2 - bonusEndBlock < 0:
        revert with 0, 'SafeMath: addition overflow'
    return ((2 * arg2 - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - arg1)
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if block.number > mintEndBlock:
                if mintEndBlock <= betaTestEndBlock:
                    if poolInfo[arg1].field_512 > mintEndBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if not (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                else:
                    if poolInfo[arg1].field_512 >= mintEndBlock:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if mintEndBlock <= bonusEndBlock:
                            if poolInfo[arg1].field_512 >= betaTestEndBlock:
                                if poolInfo[arg1].field_512 > mintEndBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not mintEndBlock - poolInfo[arg1].field_512:
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(sub_c3c5a5acAddress)
                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_c3c5a5acAddress)
                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512) / mintEndBlock - poolInfo[arg1].field_512 != 10:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if not (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512):
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        if not (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if betaTestEndBlock > mintEndBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not mintEndBlock - betaTestEndBlock:
                                    if poolInfo[arg1].field_512 > betaTestEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not betaTestEndBlock - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (10 * mintEndBlock) - (10 * betaTestEndBlock) / mintEndBlock - betaTestEndBlock != 10:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if poolInfo[arg1].field_512 > betaTestEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (10 * mintEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if not (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if poolInfo[arg1].field_512 >= betaTestEndBlock:
                                if betaTestEndBlock > poolInfo[arg1].field_512:
                                    if poolInfo[arg1].field_512 > mintEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not mintEndBlock - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if 2 * mintEndBlock - poolInfo[arg1].field_512 / mintEndBlock - poolInfo[arg1].field_512 != 2:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        if not 2 * mintEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / 2 * mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_512 >= bonusEndBlock:
                                        if poolInfo[arg1].field_512 > mintEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not mintEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if 2 * mintEndBlock - poolInfo[arg1].field_512 / mintEndBlock - poolInfo[arg1].field_512 != 2:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not 2 * mintEndBlock - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / 2 * mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512:
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if bonusEndBlock > mintEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not mintEndBlock - bonusEndBlock:
                                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                if not (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                                if 2 * mintEndBlock - bonusEndBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 2 * mintEndBlock - bonusEndBlock:
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / 2 * mintEndBlock - bonusEndBlock != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock:
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                if 2 * mintEndBlock - bonusEndBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if bonusEndBlock > mintEndBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not mintEndBlock - bonusEndBlock:
                                    if betaTestEndBlock > bonusEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not bonusEndBlock - betaTestEndBlock:
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not betaTestEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if betaTestEndBlock > bonusEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not bonusEndBlock - betaTestEndBlock:
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 2 * mintEndBlock - bonusEndBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 2 * mintEndBlock - bonusEndBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
            else:
                if block.number <= betaTestEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if not (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                else:
                    if poolInfo[arg1].field_512 >= mintEndBlock:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if block.number <= bonusEndBlock:
                            if poolInfo[arg1].field_512 >= betaTestEndBlock:
                                if poolInfo[arg1].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.number - poolInfo[arg1].field_512:
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(sub_c3c5a5acAddress)
                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / 10
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_c3c5a5acAddress)
                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        if not (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if betaTestEndBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.number - betaTestEndBlock:
                                    if poolInfo[arg1].field_512 > betaTestEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not betaTestEndBlock - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (10 * block.number) - (10 * betaTestEndBlock) / block.number - betaTestEndBlock != 10:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if poolInfo[arg1].field_512 > betaTestEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (10 * block.number) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if not (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if poolInfo[arg1].field_512 >= betaTestEndBlock:
                                if betaTestEndBlock > poolInfo[arg1].field_512:
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.number - poolInfo[arg1].field_512:
                                        if not totalAllocPoint:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / 10
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_c3c5a5acAddress)
                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if 2 * block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 2:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        if not 2 * block.number - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / 2 * block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_512 >= bonusEndBlock:
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not block.number - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if 2 * block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 2:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if not 2 * block.number - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / 2 * block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                if not sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512:
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if bonusEndBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not block.number - bonusEndBlock:
                                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                if not (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                                if 2 * block.number - bonusEndBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 2 * block.number - bonusEndBlock:
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if sub_9aae7b7d * 2 * block.number - bonusEndBlock / 2 * block.number - bonusEndBlock != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not sub_9aae7b7d * 2 * block.number - bonusEndBlock:
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / sub_9aae7b7d * 2 * block.number - bonusEndBlock != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                if 2 * block.number - bonusEndBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                                    if not totalAllocPoint:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0 / totalAllocPoint / 10
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require ext_code.size(sub_c3c5a5acAddress)
                                                    call sub_c3c5a5acAddress.0x40c10f19 with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if not 0 / totalAllocPoint:
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                        if not ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                    if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, 0 / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not 0 / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                                        if not totalAllocPoint:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require ext_code.size(sub_c3c5a5acAddress)
                                                        call sub_c3c5a5acAddress.0x40c10f19 with:
                                                             gas gas_remaining wei
                                                            args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                            if not ext_call.return_data[0]:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if bonusEndBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.number - bonusEndBlock:
                                    if betaTestEndBlock > bonusEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not bonusEndBlock - betaTestEndBlock:
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if not betaTestEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if betaTestEndBlock > bonusEndBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not bonusEndBlock - betaTestEndBlock:
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 2 * block.number - bonusEndBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if poolInfo[arg1].field_512 > betaTestEndBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 2 * block.number - bonusEndBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                                            if not totalAllocPoint:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args devaddr, 0 / totalAllocPoint / 10
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sub_c3c5a5acAddress)
                                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0 / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                                                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                                if not totalAllocPoint:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / 10
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(sub_c3c5a5acAddress)
                                                call sub_c3c5a5acAddress.0x40c10f19 with:
                                                     gas gas_remaining wei
                                                    args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.number
}

function sub_0d406532(?) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number > mintEndBlock:
        if mintEndBlock <= betaTestEndBlock:
            if poolInfo[arg1].field_512 > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (mintEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if poolInfo[arg1].field_512 >= mintEndBlock:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if mintEndBlock <= bonusEndBlock:
            if poolInfo[arg1].field_512 >= betaTestEndBlock:
                if poolInfo[arg1].field_512 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512) / mintEndBlock - poolInfo[arg1].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if betaTestEndBlock > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - betaTestEndBlock:
                if poolInfo[arg1].field_512 > betaTestEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not betaTestEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * mintEndBlock) - (10 * betaTestEndBlock) / mintEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if poolInfo[arg1].field_512 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * mintEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if poolInfo[arg1].field_512 >= betaTestEndBlock:
            if betaTestEndBlock > poolInfo[arg1].field_512:
                if poolInfo[arg1].field_512 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 2 * mintEndBlock - poolInfo[arg1].field_512 / mintEndBlock - poolInfo[arg1].field_512 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not 2 * mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / 2 * mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if poolInfo[arg1].field_512 >= bonusEndBlock:
                if poolInfo[arg1].field_512 > mintEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 2 * mintEndBlock - poolInfo[arg1].field_512 / mintEndBlock - poolInfo[arg1].field_512 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not 2 * mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / 2 * mintEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if bonusEndBlock > mintEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - bonusEndBlock:
                if poolInfo[arg1].field_512 > bonusEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if poolInfo[arg1].field_512 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - poolInfo[arg1].field_512:
                if 2 * mintEndBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not 2 * mintEndBlock - bonusEndBlock:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / 2 * mintEndBlock - bonusEndBlock != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if 2 * mintEndBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if bonusEndBlock > mintEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not mintEndBlock - bonusEndBlock:
            if betaTestEndBlock > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - betaTestEndBlock:
                if poolInfo[arg1].field_512 > betaTestEndBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not betaTestEndBlock - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if poolInfo[arg1].field_512 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if betaTestEndBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - betaTestEndBlock:
            if poolInfo[arg1].field_512 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if 2 * mintEndBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if poolInfo[arg1].field_512 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if 2 * mintEndBlock - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number <= betaTestEndBlock:
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (block.number * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 >= mintEndBlock:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number <= bonusEndBlock:
        if poolInfo[arg1].field_512 >= betaTestEndBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if betaTestEndBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - betaTestEndBlock:
            if poolInfo[arg1].field_512 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not betaTestEndBlock - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number) - (10 * betaTestEndBlock) / block.number - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if poolInfo[arg1].field_512 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * block.number) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if not (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 >= betaTestEndBlock:
        if betaTestEndBlock > poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 2 * block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not 2 * block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / 2 * block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if poolInfo[arg1].field_512 >= bonusEndBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 2 * block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not 2 * block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / 2 * block.number - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[arg1].field_512 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if bonusEndBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - bonusEndBlock:
            if poolInfo[arg1].field_512 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if poolInfo[arg1].field_512 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - poolInfo[arg1].field_512:
            if 2 * block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not 2 * block.number - bonusEndBlock:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if sub_9aae7b7d * 2 * block.number - bonusEndBlock / 2 * block.number - bonusEndBlock != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not sub_9aae7b7d * 2 * block.number - bonusEndBlock:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / sub_9aae7b7d * 2 * block.number - bonusEndBlock != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * poolInfo[arg1].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if 2 * block.number - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if bonusEndBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - bonusEndBlock:
        if betaTestEndBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - betaTestEndBlock:
            if poolInfo[arg1].field_512 > betaTestEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not betaTestEndBlock - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if poolInfo[arg1].field_512 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if betaTestEndBlock > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if not bonusEndBlock - betaTestEndBlock:
        if poolInfo[arg1].field_512 > betaTestEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if 2 * block.number - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[arg1].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if poolInfo[arg1].field_512 > betaTestEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
        revert with 0, 'SafeMath: addition overflow'
    if 2 * block.number - bonusEndBlock < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[arg1].field_512 != sub_9aae7b7d:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[arg1].field_512 * sub_9aae7b7d) != poolInfo[arg1].field_256:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero'
    if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256
    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_9aae7b7d * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 8
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if block.number > mintEndBlock:
            if mintEndBlock <= betaTestEndBlock:
                _3691 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3691] = 30
                mem[_3691 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > mintEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3691 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - poolInfo[idx].field_512:
                    _3927 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3927] = 26
                    mem[_3927 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _3975 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3975 + 68] = mem[idx + _3927 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3975 + 68] = mem[_3975 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3975 + -mem[64] + 100
                    _4101 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4101] = 26
                    mem[_4101 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _4659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4659] = 26
                        mem[_4659 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4748 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4748 + 68] = mem[idx + _4659 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4748 + 68] = mem[_4748 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4748 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4699] = 26
                    mem[_4699 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4812 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4812 + 68] = mem[idx + _4699 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4812 + 68] = mem[_4812 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4812 + -mem[64] + 100
                if (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _3950 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3950] = 26
                    mem[_3950 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4011 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4011 + 68] = mem[idx + _3950 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4011 + 68] = mem[_4011 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4011 + -mem[64] + 100
                    _4127 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4127] = 26
                    mem[_4127 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _4698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4698] = 26
                        mem[_4698 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4809 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4809 + 68] = mem[idx + _4698 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4809 + 68] = mem[_4809 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4809 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4747 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4747] = 26
                    mem[_4747 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4874 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4874 + 68] = mem[idx + _4747 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4874 + 68] = mem[_4874 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4874 + -mem[64] + 100
                if (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3974 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3974] = 26
                mem[_3974 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4044 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4044 + 68] = mem[idx + _3974 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4044 + 68] = mem[_4044 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4044 + -mem[64] + 100
                _4151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4151] = 26
                mem[_4151 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _4746 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4746] = 26
                    mem[_4746 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4871 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4871 + 68] = mem[idx + _4746 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4871 + 68] = mem[_4871 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4871 + -mem[64] + 100
                if 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4808 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4808] = 26
                mem[_4808 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4918 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4918 + 68] = mem[idx + _4808 + 32]
                    idx = idx + 32
                    continue 
                mem[_4918 + 68] = mem[_4918 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4918 + -mem[64] + 100
            if poolInfo[idx].field_512 >= mintEndBlock:
                _3849 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3849] = 26
                mem[_3849 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _3883 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3883 + 68] = mem[idx + _3849 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3883 + 68] = mem[_3883 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3883 + -mem[64] + 100
                _3972 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3972] = 26
                mem[_3972 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _4507 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4507] = 26
                    mem[_4507 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4582 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4582 + 68] = mem[idx + _4507 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4582 + 68] = mem[_4582 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4582 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4545 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4545] = 26
                mem[_4545 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4620 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4620 + 68] = mem[idx + _4545 + 32]
                    idx = idx + 32
                    continue 
                mem[_4620 + 68] = mem[_4620 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4620 + -mem[64] + 100
            if mintEndBlock <= bonusEndBlock:
                if poolInfo[idx].field_512 >= betaTestEndBlock:
                    _3700 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3700] = 30
                    mem[_3700 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3700 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - poolInfo[idx].field_512:
                        _4122 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4122] = 26
                        mem[_4122 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4176 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4176 + 68] = mem[idx + _4122 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4176 + 68] = mem[_4176 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4176 + -mem[64] + 100
                        _4361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4361] = 26
                        mem[_4361 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5011 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5011] = 26
                            mem[_5011 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5166 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5166 + 68] = mem[idx + _5011 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5166 + 68] = mem[_5166 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5166 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5081 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5081] = 26
                        mem[_5081 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5262 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5262 + 68] = mem[idx + _5081 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5262 + 68] = mem[_5262 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5262 + -mem[64] + 100
                    if (10 * mintEndBlock) - (10 * poolInfo[idx].field_512) / mintEndBlock - poolInfo[idx].field_512 != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * mintEndBlock) - (10 * poolInfo[idx].field_512):
                        _4150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4150] = 26
                        mem[_4150 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4209 + 68] = mem[idx + _4150 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4209 + 68] = mem[_4209 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4209 + -mem[64] + 100
                        _4414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4414] = 26
                        mem[_4414 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5080] = 26
                            mem[_5080 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5259 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5259 + 68] = mem[idx + _5080 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5259 + 68] = mem[_5259 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5259 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5165] = 26
                        mem[_5165 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5354 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5354 + 68] = mem[idx + _5165 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5354 + 68] = mem[_5354 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5354 + -mem[64] + 100
                    if (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4175] = 26
                        mem[_4175 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4249 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4249 + 68] = mem[idx + _4175 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4249 + 68] = mem[_4249 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4249 + -mem[64] + 100
                        _4455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4455] = 26
                        mem[_4455 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5164] = 26
                            mem[_5164 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5351 + 68] = mem[idx + _5164 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5351 + 68] = mem[_5351 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5351 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5258] = 26
                        mem[_5258 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5437 + 68] = mem[idx + _5258 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5437 + 68] = mem[_5437 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5437 + -mem[64] + 100
                    if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4208] = 26
                    mem[_4208 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4303 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4303 + 68] = mem[idx + _4208 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4303 + 68] = mem[_4303 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4303 + -mem[64] + 100
                    _4501 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4501] = 26
                    mem[_4501 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _5257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5257] = 26
                        mem[_5257 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5434 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5434 + 68] = mem[idx + _5257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5434 + 68] = mem[_5434 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5434 + -mem[64] + 100
                    if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5350 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5350] = 26
                    mem[_5350 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5518 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5518 + 68] = mem[idx + _5350 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5518 + 68] = mem[_5518 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5518 + -mem[64] + 100
                _3701 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3701] = 30
                mem[_3701 + 32] = 'SafeMath: subtraction overflow'
                if betaTestEndBlock > mintEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3701 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - betaTestEndBlock:
                    _3869 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3869] = 30
                    mem[_3869 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3869 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not betaTestEndBlock - poolInfo[idx].field_512:
                        _4459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4459] = 26
                        mem[_4459 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4542 + 68] = mem[idx + _4459 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4542 + 68] = mem[_4542 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4542 + -mem[64] + 100
                        _4691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4691] = 26
                        mem[_4691 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5731] = 26
                            mem[_5731 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5939 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5939 + 68] = mem[idx + _5731 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5939 + 68] = mem[_5939 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5939 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5843] = 26
                        mem[_5843 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6025 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6025 + 68] = mem[idx + _5843 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6025 + 68] = mem[_6025 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6025 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4506] = 26
                        mem[_4506 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4579 + 68] = mem[idx + _4506 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4579 + 68] = mem[_4579 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4579 + -mem[64] + 100
                        _4741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4741] = 26
                        mem[_4741 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5842 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5842] = 26
                            mem[_5842 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6022 + 68] = mem[idx + _5842 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6022 + 68] = mem[_6022 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6022 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5938 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5938] = 26
                        mem[_5938 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6100 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6100 + 68] = mem[idx + _5938 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6100 + 68] = mem[_6100 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6100 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4541 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4541] = 26
                    mem[_4541 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4616 + 68] = mem[idx + _4541 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4616 + 68] = mem[_4616 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4616 + -mem[64] + 100
                    _4803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4803] = 26
                    mem[_4803 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _5937 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5937] = 26
                        mem[_5937 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6097 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6097 + 68] = mem[idx + _5937 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6097 + 68] = mem[_6097 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6097 + -mem[64] + 100
                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6021 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6021] = 26
                    mem[_6021 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6163 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6163 + 68] = mem[idx + _6021 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6163 + 68] = mem[_6163 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6163 + -mem[64] + 100
                if (10 * mintEndBlock) - (10 * betaTestEndBlock) / mintEndBlock - betaTestEndBlock != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3882 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3882] = 30
                mem[_3882 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3882 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if (10 * mintEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                    _4505 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4505] = 26
                    mem[_4505 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4576 + 68] = mem[idx + _4505 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4576 + 68] = mem[_4576 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4576 + -mem[64] + 100
                    _4737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4737] = 26
                    mem[_4737 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5839] = 26
                        mem[_5839 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6018 + 68] = mem[idx + _5839 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6018 + 68] = mem[_6018 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6018 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5936 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5936] = 26
                    mem[_5936 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6094 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6094 + 68] = mem[idx + _5936 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6094 + 68] = mem[_6094 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6094 + -mem[64] + 100
                if (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4540 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4540] = 26
                    mem[_4540 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4613 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4613 + 68] = mem[idx + _4540 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4613 + 68] = mem[_4613 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4613 + -mem[64] + 100
                    _4801 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4801] = 26
                    mem[_4801 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5935 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5935] = 26
                        mem[_5935 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6091 + 68] = mem[idx + _5935 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6091 + 68] = mem[_6091 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6091 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6017 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6017] = 26
                    mem[_6017 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6159 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6159 + 68] = mem[idx + _6017 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6159 + 68] = mem[_6159 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6159 + -mem[64] + 100
                if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4575 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4575] = 26
                mem[_4575 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4649 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4649 + 68] = mem[idx + _4575 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4649 + 68] = mem[_4649 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4649 + -mem[64] + 100
                _4867 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4867] = 26
                mem[_4867 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6016 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6016] = 26
                    mem[_6016 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6156 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6156 + 68] = mem[idx + _6016 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6156 + 68] = mem[_6156 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6156 + -mem[64] + 100
                if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6090 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6090] = 26
                mem[_6090 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6217 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6217 + 68] = mem[idx + _6090 + 32]
                    idx = idx + 32
                    continue 
                mem[_6217 + 68] = mem[_6217 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6217 + -mem[64] + 100
            if poolInfo[idx].field_512 >= betaTestEndBlock:
                if betaTestEndBlock > poolInfo[idx].field_512:
                    _3711 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3711] = 30
                    mem[_3711 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3711 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - poolInfo[idx].field_512:
                        _4165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4165] = 26
                        mem[_4165 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4232 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4232 + 68] = mem[idx + _4165 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4232 + 68] = mem[_4232 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4232 + -mem[64] + 100
                        _4444 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4444] = 26
                        mem[_4444 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5137] = 26
                            mem[_5137 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5321 + 68] = mem[idx + _5137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5321 + 68] = mem[_5321 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5321 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5228] = 26
                        mem[_5228 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5408 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5408 + 68] = mem[idx + _5228 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5408 + 68] = mem[_5408 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5408 + -mem[64] + 100
                    if 2 * mintEndBlock - poolInfo[idx].field_512 / mintEndBlock - poolInfo[idx].field_512 != 2:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * mintEndBlock - poolInfo[idx].field_512:
                        _4199 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4199] = 26
                        mem[_4199 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4284 + 68] = mem[idx + _4199 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4284 + 68] = mem[_4284 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4284 + -mem[64] + 100
                        _4490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4490] = 26
                        mem[_4490 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5227 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5227] = 26
                            mem[_5227 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5405 + 68] = mem[idx + _5227 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5405 + 68] = mem[_5405 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5405 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5320 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5320] = 26
                        mem[_5320 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5489 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5489 + 68] = mem[idx + _5320 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5489 + 68] = mem[_5489 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5489 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / 2 * mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512:
                        _4231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4231] = 26
                        mem[_4231 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4339 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4339 + 68] = mem[idx + _4231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4339 + 68] = mem[_4339 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4339 + -mem[64] + 100
                        _4531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4531] = 26
                        mem[_4531 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5319 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5319] = 26
                            mem[_5319 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5486 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5486 + 68] = mem[idx + _5319 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5486 + 68] = mem[_5486 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5486 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5404] = 26
                        mem[_5404 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5574 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5574 + 68] = mem[idx + _5404 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5574 + 68] = mem[_5574 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5574 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4283] = 26
                    mem[_4283 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4395 + 68] = mem[idx + _4283 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4395 + 68] = mem[_4395 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4395 + -mem[64] + 100
                    _4563 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4563] = 26
                    mem[_4563 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint:
                        _5403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5403] = 26
                        mem[_5403 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5571 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5571 + 68] = mem[idx + _5403 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5571 + 68] = mem[_5571 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5571 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5485 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5485] = 26
                    mem[_5485 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5673 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5673 + 68] = mem[idx + _5485 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5673 + 68] = mem[_5673 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5673 + -mem[64] + 100
                if poolInfo[idx].field_512 >= bonusEndBlock:
                    _3735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3735] = 30
                    mem[_3735 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3735 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - poolInfo[idx].field_512:
                        _4200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4200] = 26
                        mem[_4200 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4288 + 68] = mem[idx + _4200 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4288 + 68] = mem[_4288 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4288 + -mem[64] + 100
                        _4495 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4495] = 26
                        mem[_4495 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5231] = 26
                            mem[_5231 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5415 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5415 + 68] = mem[idx + _5231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5415 + 68] = mem[_5415 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5415 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5327] = 26
                        mem[_5327 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5498 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5498 + 68] = mem[idx + _5327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5498 + 68] = mem[_5498 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5498 + -mem[64] + 100
                    if 2 * mintEndBlock - poolInfo[idx].field_512 / mintEndBlock - poolInfo[idx].field_512 != 2:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * mintEndBlock - poolInfo[idx].field_512:
                        _4237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4237] = 26
                        mem[_4237 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4344 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4344 + 68] = mem[idx + _4237 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4344 + 68] = mem[_4344 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4344 + -mem[64] + 100
                        _4536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4536] = 26
                        mem[_4536 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5326] = 26
                            mem[_5326 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5495 + 68] = mem[idx + _5326 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5495 + 68] = mem[_5495 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5495 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5414] = 26
                        mem[_5414 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5585 + 68] = mem[idx + _5414 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5585 + 68] = mem[_5585 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5585 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / 2 * mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512:
                        _4287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4287] = 26
                        mem[_4287 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4401 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4401 + 68] = mem[idx + _4287 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4401 + 68] = mem[_4401 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4401 + -mem[64] + 100
                        _4567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4567] = 26
                        mem[_4567 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5413 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5413] = 26
                            mem[_5413 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5582 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5582 + 68] = mem[idx + _5413 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5582 + 68] = mem[_5582 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5582 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5494] = 26
                        mem[_5494 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5686 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5686 + 68] = mem[idx + _5494 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5686 + 68] = mem[_5686 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5686 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4343] = 26
                    mem[_4343 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4446 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4446 + 68] = mem[idx + _4343 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4446 + 68] = mem[_4446 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4446 + -mem[64] + 100
                    _4607 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4607] = 26
                    mem[_4607 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint:
                        _5493 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5493] = 26
                        mem[_5493 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5683 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5683 + 68] = mem[idx + _5493 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5683 + 68] = mem[_5683 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5683 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5581 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5581] = 26
                    mem[_5581 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5801 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5801 + 68] = mem[idx + _5581 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5801 + 68] = mem[_5801 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5801 + -mem[64] + 100
                _3736 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3736] = 30
                mem[_3736 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > mintEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3736 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - bonusEndBlock:
                    _3915 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3915] = 30
                    mem[_3915 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > bonusEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3915 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[idx].field_512:
                        _4729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4729] = 26
                        mem[_4729 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4862 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4862 + 68] = mem[idx + _4729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4862 + 68] = mem[_4862 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4862 + -mem[64] + 100
                        _5069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5069] = 26
                        mem[_5069 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6265] = 26
                            mem[_6265 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6398 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6398 + 68] = mem[idx + _6265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6398 + 68] = mem[_6398 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6398 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6331] = 26
                        mem[_6331 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6459 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6459 + 68] = mem[idx + _6331 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6459 + 68] = mem[_6459 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6459 + -mem[64] + 100
                    if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                        _4792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4792] = 26
                        mem[_4792 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4915 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4915 + 68] = mem[idx + _4792 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4915 + 68] = mem[_4915 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4915 + -mem[64] + 100
                        _5151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5151] = 26
                        mem[_5151 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6330] = 26
                            mem[_6330 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6456 + 68] = mem[idx + _6330 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6456 + 68] = mem[_6456 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6456 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6397] = 26
                        mem[_6397 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6509 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6509 + 68] = mem[idx + _6397 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6509 + 68] = mem[_6509 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6509 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4861] = 26
                        mem[_4861 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4954 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4954 + 68] = mem[idx + _4861 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4954 + 68] = mem[_4954 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4954 + -mem[64] + 100
                        _5243 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5243] = 26
                        mem[_5243 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6396] = 26
                            mem[_6396 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6506 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6506 + 68] = mem[idx + _6396 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6506 + 68] = mem[_6506 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6506 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6455] = 26
                        mem[_6455 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6558 + 68] = mem[idx + _6455 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6558 + 68] = mem[_6558 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6558 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4914 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4914] = 26
                    mem[_4914 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5000 + 68] = mem[idx + _4914 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5000 + 68] = mem[_5000 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5000 + -mem[64] + 100
                    _5334 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5334] = 26
                    mem[_5334 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6454 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6454] = 26
                        mem[_6454 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6555 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6555 + 68] = mem[idx + _6454 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6555 + 68] = mem[_6555 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6555 + -mem[64] + 100
                    if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6505 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6505] = 26
                    mem[_6505 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6617 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6617 + 68] = mem[idx + _6505 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6617 + 68] = mem[_6617 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6617 + -mem[64] + 100
                if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3941 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3941] = 30
                mem[_3941 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3941 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - poolInfo[idx].field_512:
                    if 2 * mintEndBlock - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not 2 * mintEndBlock - bonusEndBlock:
                        _4789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4789] = 26
                        mem[_4789 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4911 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4911 + 68] = mem[idx + _4789 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4911 + 68] = mem[_4911 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4911 + -mem[64] + 100
                        _5146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5146] = 26
                        mem[_5146 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6327] = 26
                            mem[_6327 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6451 + 68] = mem[idx + _6327 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6451 + 68] = mem[_6451 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6451 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6393 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6393] = 26
                        mem[_6393 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6502 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6502 + 68] = mem[idx + _6393 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6502 + 68] = mem[_6502 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6502 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / 2 * mintEndBlock - bonusEndBlock != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock:
                        _4860 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4860] = 26
                        mem[_4860 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4951 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4951 + 68] = mem[idx + _4860 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4951 + 68] = mem[_4951 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4951 + -mem[64] + 100
                        _5239 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5239] = 26
                        mem[_5239 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6392] = 26
                            mem[_6392 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6499 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6499 + 68] = mem[idx + _6392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6499 + 68] = mem[_6499 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6499 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6450 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6450] = 26
                        mem[_6450 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6551 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6551 + 68] = mem[idx + _6450 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6551 + 68] = mem[_6551 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6551 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4910 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4910] = 26
                    mem[_4910 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4996 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4996 + 68] = mem[idx + _4910 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4996 + 68] = mem[_4996 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4996 + -mem[64] + 100
                    _5332 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5332] = 26
                    mem[_5332 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint:
                        _6449 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6449] = 26
                        mem[_6449 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6548 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6548 + 68] = mem[idx + _6449 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6548 + 68] = mem[_6548 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6548 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6498 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6498] = 26
                    mem[_6498 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6610 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6610 + 68] = mem[idx + _6498 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6610 + 68] = mem[_6610 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6610 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 2 * mintEndBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                    _4859 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4859] = 26
                    mem[_4859 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4948 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4948 + 68] = mem[idx + _4859 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4948 + 68] = mem[_4948 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4948 + -mem[64] + 100
                    _5235 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5235] = 26
                    mem[_5235 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6389 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6389] = 26
                        mem[_6389 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6495 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6495 + 68] = mem[idx + _6389 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6495 + 68] = mem[_6495 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6495 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6448 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6448] = 26
                    mem[_6448 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6545 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6545 + 68] = mem[idx + _6448 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6545 + 68] = mem[_6545 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6545 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4909 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4909] = 26
                    mem[_4909 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4993 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4993 + 68] = mem[idx + _4909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4993 + 68] = mem[_4993 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4993 + -mem[64] + 100
                    _5330 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5330] = 26
                    mem[_5330 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6447 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6447] = 26
                        mem[_6447 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6542 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6542 + 68] = mem[idx + _6447 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6542 + 68] = mem[_6542 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6542 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6494] = 26
                    mem[_6494 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6606 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6606 + 68] = mem[idx + _6494 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6606 + 68] = mem[_6606 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6606 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4947 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4947] = 26
                mem[_4947 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5059 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5059 + 68] = mem[idx + _4947 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5059 + 68] = mem[_5059 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5059 + -mem[64] + 100
                _5418 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5418] = 26
                mem[_5418 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6493] = 26
                    mem[_6493 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6603 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6603 + 68] = mem[idx + _6493 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6603 + 68] = mem[_6603 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6603 + -mem[64] + 100
                if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6541 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6541] = 26
                mem[_6541 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6675 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6675 + 68] = mem[idx + _6541 + 32]
                    idx = idx + 32
                    continue 
                mem[_6675 + 68] = mem[_6675 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6675 + -mem[64] + 100
            _3699 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3699] = 30
            mem[_3699 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > mintEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3699 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not mintEndBlock - bonusEndBlock:
                _3868 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3868] = 30
                mem[_3868 + 32] = 'SafeMath: subtraction overflow'
                if betaTestEndBlock > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3868 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - betaTestEndBlock:
                    _4097 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4097] = 30
                    mem[_4097 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _4097 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not betaTestEndBlock - poolInfo[idx].field_512:
                        _5008 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5008] = 26
                        mem[_5008 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5159 + 68] = mem[idx + _5008 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5159 + 68] = mem[_5159 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5159 + -mem[64] + 100
                        _5516 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5516] = 26
                        mem[_5516 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6571] = 26
                            mem[_6571 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6712 + 68] = mem[idx + _6571 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6712 + 68] = mem[_6712 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6712 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6638] = 26
                        mem[_6638 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6800 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6800 + 68] = mem[idx + _6638 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6800 + 68] = mem[_6800 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6800 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _5077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5077] = 26
                        mem[_5077 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5254 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5254 + 68] = mem[idx + _5077 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5254 + 68] = mem[_5254 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5254 + -mem[64] + 100
                        _5608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5608] = 26
                        mem[_5608 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6637] = 26
                            mem[_6637 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6797 + 68] = mem[idx + _6637 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6797 + 68] = mem[_6797 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6797 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6711] = 26
                        mem[_6711 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6898 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6898 + 68] = mem[idx + _6711 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6898 + 68] = mem[_6898 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6898 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5158 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5158] = 26
                    mem[_5158 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5346 + 68] = mem[idx + _5158 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5346 + 68] = mem[_5346 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5346 + -mem[64] + 100
                    _5714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5714] = 26
                    mem[_5714 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6710] = 26
                        mem[_6710 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6895 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6895 + 68] = mem[idx + _6710 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6895 + 68] = mem[_6895 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6895 + -mem[64] + 100
                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6796 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6796] = 26
                    mem[_6796 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6992 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6992 + 68] = mem[idx + _6796 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6992 + 68] = mem[_6992 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6992 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4121 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4121] = 30
                mem[_4121 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4121 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                    _5076 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5076] = 26
                    mem[_5076 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5251 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5251 + 68] = mem[idx + _5076 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5251 + 68] = mem[_5251 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5251 + -mem[64] + 100
                    _5604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5604] = 26
                    mem[_5604 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6634 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6634] = 26
                        mem[_6634 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6793 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6793 + 68] = mem[idx + _6634 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6793 + 68] = mem[_6793 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6793 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6709] = 26
                    mem[_6709 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6892 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6892 + 68] = mem[idx + _6709 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6892 + 68] = mem[_6892 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6892 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5157 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5157] = 26
                    mem[_5157 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5343 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5343 + 68] = mem[idx + _5157 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5343 + 68] = mem[_5343 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5343 + -mem[64] + 100
                    _5712 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5712] = 26
                    mem[_5712 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6708 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6708] = 26
                        mem[_6708 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6889 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6889 + 68] = mem[idx + _6708 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6889 + 68] = mem[_6889 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6889 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6792 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6792] = 26
                    mem[_6792 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6988 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6988 + 68] = mem[idx + _6792 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6988 + 68] = mem[_6988 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6988 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5250 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5250] = 26
                mem[_5250 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5427 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5427 + 68] = mem[idx + _5250 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5427 + 68] = mem[_5427 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5427 + -mem[64] + 100
                _5827 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5827] = 26
                mem[_5827 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6791 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6791] = 26
                    mem[_6791 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6985 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6985 + 68] = mem[idx + _6791 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6985 + 68] = mem[_6985 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6985 + -mem[64] + 100
                if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6888 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6888] = 26
                mem[_6888 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7068 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7068 + 68] = mem[idx + _6888 + 32]
                    idx = idx + 32
                    continue 
                mem[_7068 + 68] = mem[_7068 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7068 + -mem[64] + 100
            if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3881 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3881] = 30
            mem[_3881 + 32] = 'SafeMath: subtraction overflow'
            if betaTestEndBlock > bonusEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3881 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - betaTestEndBlock:
                _4120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4120] = 30
                mem[_4120 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4120 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if 2 * mintEndBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512:
                    _5073 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5073] = 26
                    mem[_5073 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5247 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5247 + 68] = mem[idx + _5073 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5247 + 68] = mem[_5247 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5247 + -mem[64] + 100
                    _5599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5599] = 26
                    mem[_5599 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6631] = 26
                        mem[_6631 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6788 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6788 + 68] = mem[idx + _6631 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6788 + 68] = mem[_6788 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6788 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6705 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6705] = 26
                    mem[_6705 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6885 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6885 + 68] = mem[idx + _6705 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6885 + 68] = mem[_6885 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6885 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5156 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5156] = 26
                    mem[_5156 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5340 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5340 + 68] = mem[idx + _5156 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5340 + 68] = mem[_5340 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5340 + -mem[64] + 100
                    _5708 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5708] = 26
                    mem[_5708 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6704 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6704] = 26
                        mem[_6704 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6882 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6882 + 68] = mem[idx + _6704 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6882 + 68] = mem[_6882 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6882 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6787 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6787] = 26
                    mem[_6787 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6981 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6981 + 68] = mem[idx + _6787 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6981 + 68] = mem[_6981 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6981 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5246 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5246] = 26
                mem[_5246 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5423 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5423 + 68] = mem[idx + _5246 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5423 + 68] = mem[_5423 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5423 + -mem[64] + 100
                _5825 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5825] = 26
                mem[_5825 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6786 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6786] = 26
                    mem[_6786 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6978 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6978 + 68] = mem[idx + _6786 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6978 + 68] = mem[_6978 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6978 + -mem[64] + 100
                if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6881 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6881] = 26
                mem[_6881 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7061 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7061 + 68] = mem[idx + _6881 + 32]
                    idx = idx + 32
                    continue 
                mem[_7061 + 68] = mem[_7061 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7061 + -mem[64] + 100
            if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4144 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4144] = 30
            mem[_4144 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > betaTestEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _4144 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if 2 * mintEndBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                _5155 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5155] = 26
                mem[_5155 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5337 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5337 + 68] = mem[idx + _5155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5337 + 68] = mem[_5337 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5337 + -mem[64] + 100
                _5704 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5704] = 26
                mem[_5704 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6701] = 26
                    mem[_6701 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6878 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6878 + 68] = mem[idx + _6701 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6878 + 68] = mem[_6878 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6878 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6785 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6785] = 26
                mem[_6785 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6975 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6975 + 68] = mem[idx + _6785 + 32]
                    idx = idx + 32
                    continue 
                mem[_6975 + 68] = mem[_6975 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6975 + -mem[64] + 100
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _5245 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5245] = 26
                mem[_5245 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5420 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5420 + 68] = mem[idx + _5245 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5420 + 68] = mem[_5420 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5420 + -mem[64] + 100
                _5823 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5823] = 26
                mem[_5823 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6784 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6784] = 26
                    mem[_6784 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6972 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6972 + 68] = mem[idx + _6784 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6972 + 68] = mem[_6972 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6972 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6877 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6877] = 26
                mem[_6877 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7057 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7057 + 68] = mem[idx + _6877 + 32]
                    idx = idx + 32
                    continue 
                mem[_7057 + 68] = mem[_7057 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7057 + -mem[64] + 100
            if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5336 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5336] = 26
            mem[_5336 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5503 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5503 + 68] = mem[idx + _5336 + 32]
                    idx = idx + 32
                    continue 
                mem[_5503 + 68] = mem[_5503 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5503 + -mem[64] + 100
            _5926 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5926] = 26
            mem[_5926 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6876 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6876] = 26
                mem[_6876 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7054 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7054 + 68] = mem[idx + _6876 + 32]
                    idx = idx + 32
                    continue 
                mem[_7054 + 68] = mem[_7054 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7054 + -mem[64] + 100
            if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6971 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6971] = 26
            mem[_6971 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7121 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7121 + 68] = mem[idx + _6971 + 32]
                idx = idx + 32
                continue 
            mem[_7121 + 68] = mem[_7121 + 74 len 26]
            revert with memory
              from mem[64]
               len _7121 + -mem[64] + 100
        if block.number <= betaTestEndBlock:
            _3692 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3692] = 30
            mem[_3692 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > block.number:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3692 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[idx].field_512:
                _3940 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3940] = 26
                mem[_3940 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _3992 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3992 + 68] = mem[idx + _3940 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3992 + 68] = mem[_3992 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3992 + -mem[64] + 100
                _4115 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4115] = 26
                mem[_4115 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _4676 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4676] = 26
                    mem[_4676 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4776 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4776 + 68] = mem[idx + _4676 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4776 + 68] = mem[_4776 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4776 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4722 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4722] = 26
                mem[_4722 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4848 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4848 + 68] = mem[idx + _4722 + 32]
                    idx = idx + 32
                    continue 
                mem[_4848 + 68] = mem[_4848 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4848 + -mem[64] + 100
            if (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _3960 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3960] = 26
                mem[_3960 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4030 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4030 + 68] = mem[idx + _3960 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4030 + 68] = mem[_4030 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4030 + -mem[64] + 100
                _4139 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4139] = 26
                mem[_4139 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _4721 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4721] = 26
                    mem[_4721 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4845 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4845 + 68] = mem[idx + _4721 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4845 + 68] = mem[_4845 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4845 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4775 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4775] = 26
                mem[_4775 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4901 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4901 + 68] = mem[idx + _4775 + 32]
                    idx = idx + 32
                    continue 
                mem[_4901 + 68] = mem[_4901 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4901 + -mem[64] + 100
            if (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3991 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3991] = 26
            mem[_3991 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _4059 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4059 + 68] = mem[idx + _3991 + 32]
                    idx = idx + 32
                    continue 
                mem[_4059 + 68] = mem[_4059 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4059 + -mem[64] + 100
            _4163 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4163] = 26
            mem[_4163 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _4774 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4774] = 26
                mem[_4774 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4898 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4898 + 68] = mem[idx + _4774 + 32]
                    idx = idx + 32
                    continue 
                mem[_4898 + 68] = mem[_4898 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4898 + -mem[64] + 100
            if 10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4844 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4844] = 26
            mem[_4844 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4938 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _4938 + 68] = mem[idx + _4844 + 32]
                idx = idx + 32
                continue 
            mem[_4938 + 68] = mem[_4938 + 74 len 26]
            revert with memory
              from mem[64]
               len _4938 + -mem[64] + 100
        if poolInfo[idx].field_512 >= mintEndBlock:
            _3862 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3862] = 26
            mem[_3862 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _3892 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _3892 + 68] = mem[idx + _3862 + 32]
                    idx = idx + 32
                    continue 
                mem[_3892 + 68] = mem[_3892 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3892 + -mem[64] + 100
            _3989 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3989] = 26
            mem[_3989 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _4528 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4528] = 26
                mem[_4528 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4604 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4604 + 68] = mem[idx + _4528 + 32]
                    idx = idx + 32
                    continue 
                mem[_4604 + 68] = mem[_4604 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4604 + -mem[64] + 100
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4562 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4562] = 26
            mem[_4562 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4638 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _4638 + 68] = mem[idx + _4562 + 32]
                idx = idx + 32
                continue 
            mem[_4638 + 68] = mem[_4638 + 74 len 26]
            revert with memory
              from mem[64]
               len _4638 + -mem[64] + 100
        if block.number <= bonusEndBlock:
            if poolInfo[idx].field_512 >= betaTestEndBlock:
                _3704 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3704] = 30
                mem[_3704 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3704 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[idx].field_512:
                    _4134 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4134] = 26
                    mem[_4134 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4192 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4192 + 68] = mem[idx + _4134 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4192 + 68] = mem[_4192 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4192 + -mem[64] + 100
                    _4389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4389] = 26
                    mem[_4389 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5043] = 26
                        mem[_5043 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5211 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5211 + 68] = mem[idx + _5043 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5211 + 68] = mem[_5211 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5211 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5120 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5120] = 26
                    mem[_5120 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5308 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5308 + 68] = mem[idx + _5120 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5308 + 68] = mem[_5308 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5308 + -mem[64] + 100
                if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                    _4162 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4162] = 26
                    mem[_4162 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4226 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4226 + 68] = mem[idx + _4162 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4226 + 68] = mem[_4226 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4226 + -mem[64] + 100
                    _4437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4437] = 26
                    mem[_4437 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5119] = 26
                        mem[_5119 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5305 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5305 + 68] = mem[idx + _5119 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5305 + 68] = mem[_5305 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5305 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5210 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5210] = 26
                    mem[_5210 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5397 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5397 + 68] = mem[idx + _5210 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5397 + 68] = mem[_5397 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5397 + -mem[64] + 100
                if (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * block.number) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4191 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4191] = 26
                    mem[_4191 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4275 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4275 + 68] = mem[idx + _4191 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4275 + 68] = mem[_4275 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4275 + -mem[64] + 100
                    _4478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4478] = 26
                    mem[_4478 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5209 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5209] = 26
                        mem[_5209 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5394 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5394 + 68] = mem[idx + _5209 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5394 + 68] = mem[_5394 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5394 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5304] = 26
                    mem[_5304 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5478 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5478 + 68] = mem[idx + _5304 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5478 + 68] = mem[_5478 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5478 + -mem[64] + 100
                if (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4225] = 26
                mem[_4225 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4331 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4331 + 68] = mem[idx + _4225 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4331 + 68] = mem[_4331 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4331 + -mem[64] + 100
                _4522 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4522] = 26
                mem[_4522 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _5303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5303] = 26
                    mem[_5303 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5475 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5475 + 68] = mem[idx + _5303 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5475 + 68] = mem[_5475 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5475 + -mem[64] + 100
                if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5393 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5393] = 26
                mem[_5393 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5561 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5561 + 68] = mem[idx + _5393 + 32]
                    idx = idx + 32
                    continue 
                mem[_5561 + 68] = mem[_5561 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5561 + -mem[64] + 100
            _3705 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3705] = 30
            mem[_3705 + 32] = 'SafeMath: subtraction overflow'
            if betaTestEndBlock > block.number:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3705 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - betaTestEndBlock:
                _3876 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3876] = 30
                mem[_3876 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3876 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not betaTestEndBlock - poolInfo[idx].field_512:
                    _4482 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4482] = 26
                    mem[_4482 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4559 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4559 + 68] = mem[idx + _4482 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4559 + 68] = mem[_4559 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4559 + -mem[64] + 100
                    _4714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4714] = 26
                    mem[_4714 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5790] = 26
                        mem[_5790 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5984 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5984 + 68] = mem[idx + _5790 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5984 + 68] = mem[_5984 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5984 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5896 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5896] = 26
                    mem[_5896 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6066 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6066 + 68] = mem[idx + _5896 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6066 + 68] = mem[_6066 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6066 + -mem[64] + 100
                if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4527] = 26
                    mem[_4527 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4601 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4601 + 68] = mem[idx + _4527 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4601 + 68] = mem[_4601 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4601 + -mem[64] + 100
                    _4769 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4769] = 26
                    mem[_4769 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5895 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5895] = 26
                        mem[_5895 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6063 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6063 + 68] = mem[idx + _5895 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6063 + 68] = mem[_6063 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6063 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5983 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5983] = 26
                    mem[_5983 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6135 + 68] = mem[idx + _5983 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6135 + 68] = mem[_6135 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6135 + -mem[64] + 100
                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4558 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4558] = 26
                mem[_4558 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4634 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4634 + 68] = mem[idx + _4558 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4634 + 68] = mem[_4634 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4634 + -mem[64] + 100
                _4839 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4839] = 26
                mem[_4839 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _5982 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5982] = 26
                    mem[_5982 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6132 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6132 + 68] = mem[idx + _5982 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6132 + 68] = mem[_6132 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6132 + -mem[64] + 100
                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6062 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6062] = 26
                mem[_6062 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6194 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6194 + 68] = mem[idx + _6062 + 32]
                    idx = idx + 32
                    continue 
                mem[_6194 + 68] = mem[_6194 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6194 + -mem[64] + 100
            if (10 * block.number) - (10 * betaTestEndBlock) / block.number - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3891 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3891] = 30
            mem[_3891 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > betaTestEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3891 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * block.number) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                _4526 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4526] = 26
                mem[_4526 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4598 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4598 + 68] = mem[idx + _4526 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4598 + 68] = mem[_4598 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4598 + -mem[64] + 100
                _4765 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4765] = 26
                mem[_4765 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _5892 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5892] = 26
                    mem[_5892 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6059 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6059 + 68] = mem[idx + _5892 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6059 + 68] = mem[_6059 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6059 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5981 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5981] = 26
                mem[_5981 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6129 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6129 + 68] = mem[idx + _5981 + 32]
                    idx = idx + 32
                    continue 
                mem[_6129 + 68] = mem[_6129 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6129 + -mem[64] + 100
            if (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _4557 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4557] = 26
                mem[_4557 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4631 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4631 + 68] = mem[idx + _4557 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4631 + 68] = mem[_4631 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4631 + -mem[64] + 100
                _4837 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4837] = 26
                mem[_4837 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _5980 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5980] = 26
                    mem[_5980 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6126 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6126 + 68] = mem[idx + _5980 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6126 + 68] = mem[_6126 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6126 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6058 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6058] = 26
                mem[_6058 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6190 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6190 + 68] = mem[idx + _6058 + 32]
                    idx = idx + 32
                    continue 
                mem[_6190 + 68] = mem[_6190 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6190 + -mem[64] + 100
            if (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4597 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4597] = 26
            mem[_4597 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _4666 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4666 + 68] = mem[idx + _4597 + 32]
                    idx = idx + 32
                    continue 
                mem[_4666 + 68] = mem[_4666 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4666 + -mem[64] + 100
            _4894 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4894] = 26
            mem[_4894 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6057 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6057] = 26
                mem[_6057 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6187 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6187 + 68] = mem[idx + _6057 + 32]
                    idx = idx + 32
                    continue 
                mem[_6187 + 68] = mem[_6187 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6187 + -mem[64] + 100
            if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6125 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6125] = 26
            mem[_6125 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _6247 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _6247 + 68] = mem[idx + _6125 + 32]
                idx = idx + 32
                continue 
            mem[_6247 + 68] = mem[_6247 + 74 len 26]
            revert with memory
              from mem[64]
               len _6247 + -mem[64] + 100
        if poolInfo[idx].field_512 >= betaTestEndBlock:
            if betaTestEndBlock > poolInfo[idx].field_512:
                _3723 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3723] = 30
                mem[_3723 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3723 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[idx].field_512:
                    _4181 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4181] = 26
                    mem[_4181 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4258 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4258 + 68] = mem[idx + _4181 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4258 + 68] = mem[_4258 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4258 + -mem[64] + 100
                    _4467 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4467] = 26
                    mem[_4467 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5182 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5182] = 26
                        mem[_5182 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5364 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5364 + 68] = mem[idx + _5182 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5364 + 68] = mem[_5364 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5364 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5274 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5274] = 26
                    mem[_5274 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5449 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5449 + 68] = mem[idx + _5274 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5449 + 68] = mem[_5449 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5449 + -mem[64] + 100
                if 2 * block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * block.number - poolInfo[idx].field_512:
                    _4216 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4216] = 26
                    mem[_4216 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4312 + 68] = mem[idx + _4216 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4312 + 68] = mem[_4312 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4312 + -mem[64] + 100
                    _4511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4511] = 26
                    mem[_4511 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5273] = 26
                        mem[_5273 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5446 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5446 + 68] = mem[idx + _5273 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5446 + 68] = mem[_5446 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5446 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5363] = 26
                    mem[_5363 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5532 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5532 + 68] = mem[idx + _5363 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5532 + 68] = mem[_5532 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5532 + -mem[64] + 100
                if sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / 2 * block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512:
                    _4257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4257] = 26
                    mem[_4257 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4367 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4367 + 68] = mem[idx + _4257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4367 + 68] = mem[_4367 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4367 + -mem[64] + 100
                    _4548 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4548] = 26
                    mem[_4548 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5362] = 26
                        mem[_5362 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5529 + 68] = mem[idx + _5362 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5529 + 68] = mem[_5529 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5529 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5445 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5445] = 26
                    mem[_5445 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5625 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5625 + 68] = mem[idx + _5445 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5625 + 68] = mem[_5625 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5625 + -mem[64] + 100
                if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4311 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4311] = 26
                mem[_4311 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4418 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4418 + 68] = mem[idx + _4311 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4418 + 68] = mem[_4418 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4418 + -mem[64] + 100
                _4585 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4585] = 26
                mem[_4585 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint:
                    _5444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5444] = 26
                    mem[_5444 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5622 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5622 + 68] = mem[idx + _5444 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5622 + 68] = mem[_5622 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5622 + -mem[64] + 100
                if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5528 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5528] = 26
                mem[_5528 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5732 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5732 + 68] = mem[idx + _5528 + 32]
                    idx = idx + 32
                    continue 
                mem[_5732 + 68] = mem[_5732 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5732 + -mem[64] + 100
            if poolInfo[idx].field_512 >= bonusEndBlock:
                _3742 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3742] = 30
                mem[_3742 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3742 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[idx].field_512:
                    _4217 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4217] = 26
                    mem[_4217 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4316 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4316 + 68] = mem[idx + _4217 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4316 + 68] = mem[_4316 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4316 + -mem[64] + 100
                    _4516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4516] = 26
                    mem[_4516 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5277] = 26
                        mem[_5277 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5456 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5456 + 68] = mem[idx + _5277 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5456 + 68] = mem[_5456 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5456 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5370] = 26
                    mem[_5370 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5541 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5541 + 68] = mem[idx + _5370 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5541 + 68] = mem[_5541 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5541 + -mem[64] + 100
                if 2 * block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * block.number - poolInfo[idx].field_512:
                    _4263 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4263] = 26
                    mem[_4263 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4372 + 68] = mem[idx + _4263 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4372 + 68] = mem[_4372 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4372 + -mem[64] + 100
                    _4553 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4553] = 26
                    mem[_4553 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5369] = 26
                        mem[_5369 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5538 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5538 + 68] = mem[idx + _5369 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5538 + 68] = mem[_5538 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5538 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5455 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5455] = 26
                    mem[_5455 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5636 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5636 + 68] = mem[idx + _5455 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5636 + 68] = mem[_5636 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5636 + -mem[64] + 100
                if sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / 2 * block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512:
                    _4315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4315] = 26
                    mem[_4315 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4424 + 68] = mem[idx + _4315 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4424 + 68] = mem[_4424 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4424 + -mem[64] + 100
                    _4589 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4589] = 26
                    mem[_4589 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5454 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5454] = 26
                        mem[_5454 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5633 + 68] = mem[idx + _5454 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5633 + 68] = mem[_5633 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5633 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5537 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5537] = 26
                    mem[_5537 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5745 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5745 + 68] = mem[idx + _5537 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5745 + 68] = mem[_5745 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5745 + -mem[64] + 100
                if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4371 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4371] = 26
                mem[_4371 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4469 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4469 + 68] = mem[idx + _4371 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4469 + 68] = mem[_4469 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4469 + -mem[64] + 100
                _4625 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4625] = 26
                mem[_4625 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint:
                    _5536 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5536] = 26
                    mem[_5536 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5742 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5742 + 68] = mem[idx + _5536 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5742 + 68] = mem[_5742 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5742 + -mem[64] + 100
                if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5632 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5632] = 26
                mem[_5632 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5854 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5854 + 68] = mem[idx + _5632 + 32]
                    idx = idx + 32
                    continue 
                mem[_5854 + 68] = mem[_5854 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5854 + -mem[64] + 100
            _3743 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3743] = 30
            mem[_3743 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3743 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - bonusEndBlock:
                _3928 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3928] = 30
                mem[_3928 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3928 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - poolInfo[idx].field_512:
                    _4757 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4757] = 26
                    mem[_4757 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4889 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4889 + 68] = mem[idx + _4757 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4889 + 68] = mem[_4889 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4889 + -mem[64] + 100
                    _5108 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5108] = 26
                    mem[_5108 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6296] = 26
                        mem[_6296 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6427 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6427 + 68] = mem[idx + _6296 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6427 + 68] = mem[_6427 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6427 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6363] = 26
                    mem[_6363 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6483 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6483 + 68] = mem[idx + _6363 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6483 + 68] = mem[_6483 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6483 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                    _4828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4828] = 26
                    mem[_4828 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4935 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4935 + 68] = mem[idx + _4828 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4935 + 68] = mem[_4935 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4935 + -mem[64] + 100
                    _5196 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5196] = 26
                    mem[_5196 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6362] = 26
                        mem[_6362 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6480 + 68] = mem[idx + _6362 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6480 + 68] = mem[_6480 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6480 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6426 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6426] = 26
                    mem[_6426 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6533 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6533 + 68] = mem[idx + _6426 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6533 + 68] = mem[_6533 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6533 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4888 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4888] = 26
                    mem[_4888 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4978 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4978 + 68] = mem[idx + _4888 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4978 + 68] = mem[_4978 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4978 + -mem[64] + 100
                    _5289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5289] = 26
                    mem[_5289 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6425] = 26
                        mem[_6425 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6530 + 68] = mem[idx + _6425 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6530 + 68] = mem[_6530 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6530 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6479 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6479] = 26
                    mem[_6479 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6589 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6589 + 68] = mem[idx + _6479 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6589 + 68] = mem[_6589 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6589 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4934 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4934] = 26
                mem[_4934 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5032 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5032 + 68] = mem[idx + _4934 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5032 + 68] = mem[_5032 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5032 + -mem[64] + 100
                _5377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5377] = 26
                mem[_5377 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6478] = 26
                    mem[_6478 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6586 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6586 + 68] = mem[idx + _6478 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6586 + 68] = mem[_6586 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6586 + -mem[64] + 100
                if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6529 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6529] = 26
                mem[_6529 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6653 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6653 + 68] = mem[idx + _6529 + 32]
                    idx = idx + 32
                    continue 
                mem[_6653 + 68] = mem[_6653 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6653 + -mem[64] + 100
            if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3951 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3951] = 30
            mem[_3951 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > bonusEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3951 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - poolInfo[idx].field_512:
                if 2 * block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not 2 * block.number - bonusEndBlock:
                    _4825 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4825] = 26
                    mem[_4825 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4931 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4931 + 68] = mem[idx + _4825 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4931 + 68] = mem[_4931 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4931 + -mem[64] + 100
                    _5191 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5191] = 26
                    mem[_5191 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6359] = 26
                        mem[_6359 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6475 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6475 + 68] = mem[idx + _6359 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6475 + 68] = mem[_6475 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6475 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6422] = 26
                    mem[_6422 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6526 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6526 + 68] = mem[idx + _6422 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6526 + 68] = mem[_6526 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6526 + -mem[64] + 100
                if sub_9aae7b7d * 2 * block.number - bonusEndBlock / 2 * block.number - bonusEndBlock != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_9aae7b7d * 2 * block.number - bonusEndBlock:
                    _4887 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4887] = 26
                    mem[_4887 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4975 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4975 + 68] = mem[idx + _4887 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4975 + 68] = mem[_4975 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4975 + -mem[64] + 100
                    _5285 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5285] = 26
                    mem[_5285 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6421] = 26
                        mem[_6421 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6523 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6523 + 68] = mem[idx + _6421 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6523 + 68] = mem[_6523 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6523 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6474] = 26
                    mem[_6474 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6582 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6582 + 68] = mem[idx + _6474 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6582 + 68] = mem[_6582 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6582 + -mem[64] + 100
                if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / sub_9aae7b7d * 2 * block.number - bonusEndBlock != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4930 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4930] = 26
                mem[_4930 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5028 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5028 + 68] = mem[idx + _4930 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5028 + 68] = mem[_5028 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5028 + -mem[64] + 100
                _5375 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5375] = 26
                mem[_5375 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint:
                    _6473 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6473] = 26
                    mem[_6473 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6579 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6579 + 68] = mem[idx + _6473 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6579 + 68] = mem[_6579 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6579 + -mem[64] + 100
                if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6522 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6522] = 26
                mem[_6522 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6646 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6646 + 68] = mem[idx + _6522 + 32]
                    idx = idx + 32
                    continue 
                mem[_6646 + 68] = mem[_6646 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6646 + -mem[64] + 100
            if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 2 * block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                _4886 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4886] = 26
                mem[_4886 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4972 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4972 + 68] = mem[idx + _4886 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4972 + 68] = mem[_4972 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4972 + -mem[64] + 100
                _5281 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5281] = 26
                mem[_5281 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6418] = 26
                    mem[_6418 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6519 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6519 + 68] = mem[idx + _6418 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6519 + 68] = mem[_6519 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6519 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6472 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6472] = 26
                mem[_6472 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6576 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6576 + 68] = mem[idx + _6472 + 32]
                    idx = idx + 32
                    continue 
                mem[_6576 + 68] = mem[_6576 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6576 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                _4929 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4929] = 26
                mem[_4929 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5025 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5025 + 68] = mem[idx + _4929 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5025 + 68] = mem[_5025 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5025 + -mem[64] + 100
                _5373 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5373] = 26
                mem[_5373 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6471 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6471] = 26
                    mem[_6471 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6573 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6573 + 68] = mem[idx + _6471 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6573 + 68] = mem[_6573 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6573 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6518 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6518] = 26
                mem[_6518 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6642 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6642 + 68] = mem[idx + _6518 + 32]
                    idx = idx + 32
                    continue 
                mem[_6642 + 68] = mem[_6642 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6642 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4971 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4971] = 26
            mem[_4971 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5098 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5098 + 68] = mem[idx + _4971 + 32]
                    idx = idx + 32
                    continue 
                mem[_5098 + 68] = mem[_5098 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5098 + -mem[64] + 100
            _5459 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5459] = 26
            mem[_5459 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6517 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6517] = 26
                mem[_6517 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6639 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6639 + 68] = mem[idx + _6517 + 32]
                    idx = idx + 32
                    continue 
                mem[_6639 + 68] = mem[_6639 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6639 + -mem[64] + 100
            if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6572 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6572] = 26
            mem[_6572 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _6715 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _6715 + 68] = mem[idx + _6572 + 32]
                idx = idx + 32
                continue 
            mem[_6715 + 68] = mem[_6715 + 74 len 26]
            revert with memory
              from mem[64]
               len _6715 + -mem[64] + 100
        _3703 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3703] = 30
        mem[_3703 + 32] = 'SafeMath: subtraction overflow'
        if bonusEndBlock > block.number:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _3703 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - bonusEndBlock:
            _3875 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3875] = 30
            mem[_3875 + 32] = 'SafeMath: subtraction overflow'
            if betaTestEndBlock > bonusEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3875 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - betaTestEndBlock:
                _4111 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4111] = 30
                mem[_4111 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4111 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not betaTestEndBlock - poolInfo[idx].field_512:
                    _5040 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5040] = 26
                    mem[_5040 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5204 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5204 + 68] = mem[idx + _5040 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5204 + 68] = mem[_5204 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5204 + -mem[64] + 100
                    _5559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5559] = 26
                    mem[_5559 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6602] = 26
                        mem[_6602 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6752 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6752 + 68] = mem[idx + _6602 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6752 + 68] = mem[_6752 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6752 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6674] = 26
                    mem[_6674 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6848 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6848 + 68] = mem[idx + _6674 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6848 + 68] = mem[_6848 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6848 + -mem[64] + 100
                if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5116 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5116] = 26
                    mem[_5116 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5300 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5300 + 68] = mem[idx + _5116 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5300 + 68] = mem[_5300 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5300 + -mem[64] + 100
                    _5659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5659] = 26
                    mem[_5659 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6673 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6673] = 26
                        mem[_6673 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6845 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6845 + 68] = mem[idx + _6673 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6845 + 68] = mem[_6845 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6845 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6751 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6751] = 26
                    mem[_6751 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6949 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6949 + 68] = mem[idx + _6751 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6949 + 68] = mem[_6949 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6949 + -mem[64] + 100
                if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5203] = 26
                mem[_5203 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5389 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5389 + 68] = mem[idx + _5203 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5389 + 68] = mem[_5389 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5389 + -mem[64] + 100
                _5773 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5773] = 26
                mem[_5773 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6750 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6750] = 26
                    mem[_6750 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6946 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6946 + 68] = mem[idx + _6750 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6946 + 68] = mem[_6946 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6946 + -mem[64] + 100
                if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6844 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6844] = 26
                mem[_6844 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7038 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7038 + 68] = mem[idx + _6844 + 32]
                    idx = idx + 32
                    continue 
                mem[_7038 + 68] = mem[_7038 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7038 + -mem[64] + 100
            if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4133] = 30
            mem[_4133 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > betaTestEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _4133 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                _5115 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5115] = 26
                mem[_5115 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5297 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5297 + 68] = mem[idx + _5115 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5297 + 68] = mem[_5297 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5297 + -mem[64] + 100
                _5655 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5655] = 26
                mem[_5655 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6670 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6670] = 26
                    mem[_6670 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6841 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6841 + 68] = mem[idx + _6670 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6841 + 68] = mem[_6841 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6841 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6749 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6749] = 26
                mem[_6749 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6943 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6943 + 68] = mem[idx + _6749 + 32]
                    idx = idx + 32
                    continue 
                mem[_6943 + 68] = mem[_6943 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6943 + -mem[64] + 100
            if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _5202 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5202] = 26
                mem[_5202 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5386 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5386 + 68] = mem[idx + _5202 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5386 + 68] = mem[_5386 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5386 + -mem[64] + 100
                _5771 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5771] = 26
                mem[_5771 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6748 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6748] = 26
                    mem[_6748 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6940 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6940 + 68] = mem[idx + _6748 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6940 + 68] = mem[_6940 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6940 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6840 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6840] = 26
                mem[_6840 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7034 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7034 + 68] = mem[idx + _6840 + 32]
                    idx = idx + 32
                    continue 
                mem[_7034 + 68] = mem[_7034 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7034 + -mem[64] + 100
            if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5296 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5296] = 26
            mem[_5296 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5468 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5468 + 68] = mem[idx + _5296 + 32]
                    idx = idx + 32
                    continue 
                mem[_5468 + 68] = mem[_5468 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5468 + -mem[64] + 100
            _5880 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5880] = 26
            mem[_5880 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6839 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6839] = 26
                mem[_6839 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7031 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7031 + 68] = mem[idx + _6839 + 32]
                    idx = idx + 32
                    continue 
                mem[_7031 + 68] = mem[_7031 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7031 + -mem[64] + 100
            if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6939 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6939] = 26
            mem[_6939 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7105 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7105 + 68] = mem[idx + _6939 + 32]
                idx = idx + 32
                continue 
            mem[_7105 + 68] = mem[_7105 + 74 len 26]
            revert with memory
              from mem[64]
               len _7105 + -mem[64] + 100
        if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _3890 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3890] = 30
        mem[_3890 + 32] = 'SafeMath: subtraction overflow'
        if betaTestEndBlock > bonusEndBlock:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _3890 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - betaTestEndBlock:
            _4132 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4132] = 30
            mem[_4132 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > betaTestEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _4132 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if 2 * block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512:
                _5112 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5112] = 26
                mem[_5112 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5293 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5293 + 68] = mem[idx + _5112 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5293 + 68] = mem[_5293 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5293 + -mem[64] + 100
                _5650 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5650] = 26
                mem[_5650 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6667 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6667] = 26
                    mem[_6667 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6836 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6836 + 68] = mem[idx + _6667 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6836 + 68] = mem[_6836 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6836 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6745 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6745] = 26
                mem[_6745 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6936 + 68] = mem[idx + _6745 + 32]
                    idx = idx + 32
                    continue 
                mem[_6936 + 68] = mem[_6936 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6936 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _5201 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5201] = 26
                mem[_5201 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5383 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5383 + 68] = mem[idx + _5201 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5383 + 68] = mem[_5383 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5383 + -mem[64] + 100
                _5767 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5767] = 26
                mem[_5767 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6744 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6744] = 26
                    mem[_6744 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6933 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6933 + 68] = mem[idx + _6744 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6933 + 68] = mem[_6933 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6933 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6835 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6835] = 26
                mem[_6835 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7027 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7027 + 68] = mem[idx + _6835 + 32]
                    idx = idx + 32
                    continue 
                mem[_7027 + 68] = mem[_7027 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7027 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5292 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5292] = 26
            mem[_5292 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5464 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5464 + 68] = mem[idx + _5292 + 32]
                    idx = idx + 32
                    continue 
                mem[_5464 + 68] = mem[_5464 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5464 + -mem[64] + 100
            _5878 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5878] = 26
            mem[_5878 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6834 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6834] = 26
                mem[_6834 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7024 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7024 + 68] = mem[idx + _6834 + 32]
                    idx = idx + 32
                    continue 
                mem[_7024 + 68] = mem[_7024 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7024 + -mem[64] + 100
            if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6932 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6932] = 26
            mem[_6932 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7098 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7098 + 68] = mem[idx + _6932 + 32]
                idx = idx + 32
                continue 
            mem[_7098 + 68] = mem[_7098 + 74 len 26]
            revert with memory
              from mem[64]
               len _7098 + -mem[64] + 100
        if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _4156 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4156] = 30
        mem[_4156 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > betaTestEndBlock:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _4156 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if 2 * block.number - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
            _5200 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5200] = 26
            mem[_5200 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5380 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5380 + 68] = mem[idx + _5200 + 32]
                    idx = idx + 32
                    continue 
                mem[_5380 + 68] = mem[_5380 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5380 + -mem[64] + 100
            _5763 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5763] = 26
            mem[_5763 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _6741 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6741] = 26
                mem[_6741 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6929 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6929 + 68] = mem[idx + _6741 + 32]
                    idx = idx + 32
                    continue 
                mem[_6929 + 68] = mem[_6929 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6929 + -mem[64] + 100
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6833 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6833] = 26
            mem[_6833 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7021 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7021 + 68] = mem[idx + _6833 + 32]
                idx = idx + 32
                continue 
            mem[_7021 + 68] = mem[_7021 + 74 len 26]
            revert with memory
              from mem[64]
               len _7021 + -mem[64] + 100
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
            _5291 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5291] = 26
            mem[_5291 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5461 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5461 + 68] = mem[idx + _5291 + 32]
                    idx = idx + 32
                    continue 
                mem[_5461 + 68] = mem[_5461 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5461 + -mem[64] + 100
            _5876 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5876] = 26
            mem[_5876 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, 0 / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _6832 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6832] = 26
                mem[_6832 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7018 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7018 + 68] = mem[idx + _6832 + 32]
                    idx = idx + 32
                    continue 
                mem[_7018 + 68] = mem[_7018 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7018 + -mem[64] + 100
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6928 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6928] = 26
            mem[_6928 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7094 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7094 + 68] = mem[idx + _6928 + 32]
                idx = idx + 32
                continue 
            mem[_7094 + 68] = mem[_7094 + 74 len 26]
            revert with memory
              from mem[64]
               len _7094 + -mem[64] + 100
        if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5379 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5379] = 26
        mem[_5379 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _5546 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5546 + 68] = mem[idx + _5379 + 32]
                idx = idx + 32
                continue 
            mem[_5546 + 68] = mem[_5546 + 74 len 26]
            revert with memory
              from mem[64]
               len _5546 + -mem[64] + 100
        _5971 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5971] = 26
        mem[_5971 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sub_c3c5a5acAddress)
        call sub_c3c5a5acAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(sub_c3c5a5acAddress)
        call sub_c3c5a5acAddress.0x40c10f19 with:
             gas gas_remaining wei
            args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
            _6927 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6927] = 26
            mem[_6927 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7091 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7091 + 68] = mem[idx + _6927 + 32]
                idx = idx + 32
                continue 
            mem[_7091 + 68] = mem[_7091 + 74 len 26]
            revert with memory
              from mem[64]
               len _7091 + -mem[64] + 100
        if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _7017 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7017] = 26
        mem[_7017 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0]:
            if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _7153 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _7153 + 68] = mem[idx + _7017 + 32]
            idx = idx + 32
            continue 
        mem[_7153 + 68] = mem[_7153 + 74 len 26]
        revert with memory
          from mem[64]
           len _7153 + -mem[64] + 100
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 8
            if block.number <= poolInfo[idx].field_512:
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            if block.number > mintEndBlock:
                if mintEndBlock <= betaTestEndBlock:
                    _3745 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3745] = 30
                    mem[_3745 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3745 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - poolInfo[idx].field_512:
                        _3981 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3981] = 26
                        mem[_3981 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4029 + 68] = mem[idx + _3981 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4029 + 68] = mem[_4029 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4029 + -mem[64] + 100
                        _4155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4155] = 26
                        mem[_4155 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _4713 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4713] = 26
                            mem[_4713 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4802 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4802 + 68] = mem[idx + _4713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4802 + 68] = mem[_4802 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4802 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4753] = 26
                        mem[_4753 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4866 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4866 + 68] = mem[idx + _4753 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4866 + 68] = mem[_4866 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4866 + -mem[64] + 100
                    if (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4004] = 26
                        mem[_4004 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4065 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4065 + 68] = mem[idx + _4004 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4065 + 68] = mem[_4065 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4065 + -mem[64] + 100
                        _4181 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4181] = 26
                        mem[_4181 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _4752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4752] = 26
                            mem[_4752 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4863 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4863 + 68] = mem[idx + _4752 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4863 + 68] = mem[_4863 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4863 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4801] = 26
                        mem[_4801 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4928 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4928 + 68] = mem[idx + _4801 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4928 + 68] = mem[_4928 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4928 + -mem[64] + 100
                    if (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (mintEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4028 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4028] = 26
                    mem[_4028 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4098 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4098 + 68] = mem[idx + _4028 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4098 + 68] = mem[_4098 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4098 + -mem[64] + 100
                    _4205 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4205] = 26
                    mem[_4205 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _4800 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4800] = 26
                        mem[_4800 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4925 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4925 + 68] = mem[idx + _4800 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4925 + 68] = mem[_4925 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4925 + -mem[64] + 100
                    if 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4862 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4862] = 26
                    mem[_4862 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4972 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4972 + 68] = mem[idx + _4862 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4972 + 68] = mem[_4972 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4972 + -mem[64] + 100
                if poolInfo[idx].field_512 >= mintEndBlock:
                    _3903 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3903] = 26
                    mem[_3903 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _3937 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3937 + 68] = mem[idx + _3903 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3937 + 68] = mem[_3937 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3937 + -mem[64] + 100
                    _4026 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4026] = 26
                    mem[_4026 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _4561 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4561] = 26
                        mem[_4561 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4636 + 68] = mem[idx + _4561 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4636 + 68] = mem[_4636 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4636 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4599] = 26
                    mem[_4599 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4674 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4674 + 68] = mem[idx + _4599 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4674 + 68] = mem[_4674 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4674 + -mem[64] + 100
                if mintEndBlock <= bonusEndBlock:
                    if poolInfo[idx].field_512 >= betaTestEndBlock:
                        _3754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3754] = 30
                        mem[_3754 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > mintEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _3754 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not mintEndBlock - poolInfo[idx].field_512:
                            _4176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4176] = 26
                            mem[_4176 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4230 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4230 + 68] = mem[idx + _4176 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4230 + 68] = mem[_4230 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4230 + -mem[64] + 100
                            _4415 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4415] = 26
                            mem[_4415 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5065 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5065] = 26
                                mem[_5065 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5220 + 68] = mem[idx + _5065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5220 + 68] = mem[_5220 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5220 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5135] = 26
                            mem[_5135 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5316 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5316 + 68] = mem[idx + _5135 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5316 + 68] = mem[_5316 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5316 + -mem[64] + 100
                        if (10 * mintEndBlock) - (10 * poolInfo[idx].field_512) / mintEndBlock - poolInfo[idx].field_512 != 10:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (10 * mintEndBlock) - (10 * poolInfo[idx].field_512):
                            _4204 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4204] = 26
                            mem[_4204 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4263 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4263 + 68] = mem[idx + _4204 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4263 + 68] = mem[_4263 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4263 + -mem[64] + 100
                            _4468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4468] = 26
                            mem[_4468 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5134 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5134] = 26
                                mem[_5134 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5313 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5313 + 68] = mem[idx + _5134 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5313 + 68] = mem[_5313 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5313 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5219] = 26
                            mem[_5219 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5408 + 68] = mem[idx + _5219 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5408 + 68] = mem[_5408 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5408 + -mem[64] + 100
                        if (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                            _4229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4229] = 26
                            mem[_4229 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4303 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4303 + 68] = mem[idx + _4229 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4303 + 68] = mem[_4303 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4303 + -mem[64] + 100
                            _4509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4509] = 26
                            mem[_4509 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5218 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5218] = 26
                                mem[_5218 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5405 + 68] = mem[idx + _5218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5405 + 68] = mem[_5405 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5405 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5312] = 26
                            mem[_5312 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5491 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5491 + 68] = mem[idx + _5312 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5491 + 68] = mem[_5491 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5491 + -mem[64] + 100
                        if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4262] = 26
                        mem[_4262 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4357 + 68] = mem[idx + _4262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4357 + 68] = mem[_4357 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4357 + -mem[64] + 100
                        _4555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4555] = 26
                        mem[_4555 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                            _5311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5311] = 26
                            mem[_5311 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5488 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5488 + 68] = mem[idx + _5311 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5488 + 68] = mem[_5488 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5488 + -mem[64] + 100
                        if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5404] = 26
                        mem[_5404 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5572 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5572 + 68] = mem[idx + _5404 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5572 + 68] = mem[_5572 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5572 + -mem[64] + 100
                    _3755 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3755] = 30
                    mem[_3755 + 32] = 'SafeMath: subtraction overflow'
                    if betaTestEndBlock > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3755 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - betaTestEndBlock:
                        _3923 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3923] = 30
                        mem[_3923 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > betaTestEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _3923 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not betaTestEndBlock - poolInfo[idx].field_512:
                            _4513 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4513] = 26
                            mem[_4513 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4596 + 68] = mem[idx + _4513 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4596 + 68] = mem[_4596 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4596 + -mem[64] + 100
                            _4745 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4745] = 26
                            mem[_4745 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5785] = 26
                                mem[_5785 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5993 + 68] = mem[idx + _5785 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5993 + 68] = mem[_5993 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5993 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5897 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5897] = 26
                            mem[_5897 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6079 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6079 + 68] = mem[idx + _5897 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6079 + 68] = mem[_6079 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6079 + -mem[64] + 100
                        if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                            _4560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4560] = 26
                            mem[_4560 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4633 + 68] = mem[idx + _4560 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4633 + 68] = mem[_4633 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4633 + -mem[64] + 100
                            _4795 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4795] = 26
                            mem[_4795 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5896 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5896] = 26
                                mem[_5896 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6076 + 68] = mem[idx + _5896 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6076 + 68] = mem[_6076 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6076 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5992] = 26
                            mem[_5992 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6154 + 68] = mem[idx + _5992 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6154 + 68] = mem[_6154 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6154 + -mem[64] + 100
                        if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4595] = 26
                        mem[_4595 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4670 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4670 + 68] = mem[idx + _4595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4670 + 68] = mem[_4670 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4670 + -mem[64] + 100
                        _4857 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4857] = 26
                        mem[_4857 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                            _5991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5991] = 26
                            mem[_5991 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6151 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6151 + 68] = mem[idx + _5991 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6151 + 68] = mem[_6151 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6151 + -mem[64] + 100
                        if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6075 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6075] = 26
                        mem[_6075 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6217 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6217 + 68] = mem[idx + _6075 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6217 + 68] = mem[_6217 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6217 + -mem[64] + 100
                    if (10 * mintEndBlock) - (10 * betaTestEndBlock) / mintEndBlock - betaTestEndBlock != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3936 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3936] = 30
                    mem[_3936 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3936 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if (10 * mintEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                        _4559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4559] = 26
                        mem[_4559 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4630 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4630 + 68] = mem[idx + _4559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4630 + 68] = mem[_4630 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4630 + -mem[64] + 100
                        _4791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4791] = 26
                        mem[_4791 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5893] = 26
                            mem[_5893 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6072 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6072 + 68] = mem[idx + _5893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6072 + 68] = mem[_6072 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6072 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5990] = 26
                        mem[_5990 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6148 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6148 + 68] = mem[idx + _5990 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6148 + 68] = mem[_6148 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6148 + -mem[64] + 100
                    if (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * mintEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4594] = 26
                        mem[_4594 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4667 + 68] = mem[idx + _4594 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4667 + 68] = mem[_4667 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4667 + -mem[64] + 100
                        _4855 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4855] = 26
                        mem[_4855 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5989] = 26
                            mem[_5989 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6145 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6145 + 68] = mem[idx + _5989 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6145 + 68] = mem[_6145 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6145 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6071 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6071] = 26
                        mem[_6071 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6213 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6213 + 68] = mem[idx + _6071 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6213 + 68] = mem[_6213 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6213 + -mem[64] + 100
                    if (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * mintEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4629] = 26
                    mem[_4629 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4703 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4703 + 68] = mem[idx + _4629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4703 + 68] = mem[_4703 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4703 + -mem[64] + 100
                    _4921 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4921] = 26
                    mem[_4921 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6070 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6070] = 26
                        mem[_6070 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6210 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6210 + 68] = mem[idx + _6070 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6210 + 68] = mem[_6210 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6210 + -mem[64] + 100
                    if 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6144 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6144] = 26
                    mem[_6144 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * mintEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6271 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6271 + 68] = mem[idx + _6144 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6271 + 68] = mem[_6271 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6271 + -mem[64] + 100
                if poolInfo[idx].field_512 >= betaTestEndBlock:
                    if betaTestEndBlock > poolInfo[idx].field_512:
                        _3765 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3765] = 30
                        mem[_3765 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > mintEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _3765 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not mintEndBlock - poolInfo[idx].field_512:
                            _4219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4219] = 26
                            mem[_4219 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4286 + 68] = mem[idx + _4219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4286 + 68] = mem[_4286 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4286 + -mem[64] + 100
                            _4498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4498] = 26
                            mem[_4498 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5191] = 26
                                mem[_5191 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5375 + 68] = mem[idx + _5191 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5375 + 68] = mem[_5375 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5375 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5282 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5282] = 26
                            mem[_5282 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5462 + 68] = mem[idx + _5282 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5462 + 68] = mem[_5462 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5462 + -mem[64] + 100
                        if 2 * mintEndBlock - poolInfo[idx].field_512 / mintEndBlock - poolInfo[idx].field_512 != 2:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * mintEndBlock - poolInfo[idx].field_512:
                            _4253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4253] = 26
                            mem[_4253 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4338 + 68] = mem[idx + _4253 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4338 + 68] = mem[_4338 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4338 + -mem[64] + 100
                            _4544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4544] = 26
                            mem[_4544 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5281] = 26
                                mem[_5281 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5459 + 68] = mem[idx + _5281 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5459 + 68] = mem[_5459 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5459 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5374 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5374] = 26
                            mem[_5374 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5543 + 68] = mem[idx + _5374 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5543 + 68] = mem[_5543 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5543 + -mem[64] + 100
                        if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / 2 * mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512:
                            _4285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4285] = 26
                            mem[_4285 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4393 + 68] = mem[idx + _4285 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4393 + 68] = mem[_4393 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4393 + -mem[64] + 100
                            _4585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4585] = 26
                            mem[_4585 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5373 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5373] = 26
                                mem[_5373 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5540 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5540 + 68] = mem[idx + _5373 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5540 + 68] = mem[_5540 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5540 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5458] = 26
                            mem[_5458 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5628 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5628 + 68] = mem[idx + _5458 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5628 + 68] = mem[_5628 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5628 + -mem[64] + 100
                        if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4337] = 26
                        mem[_4337 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4449 + 68] = mem[idx + _4337 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4449 + 68] = mem[_4449 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4449 + -mem[64] + 100
                        _4617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4617] = 26
                        mem[_4617 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint:
                            _5457 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5457] = 26
                            mem[_5457 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5625 + 68] = mem[idx + _5457 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5625 + 68] = mem[_5625 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5625 + -mem[64] + 100
                        if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5539 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5539] = 26
                        mem[_5539 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5727 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5727 + 68] = mem[idx + _5539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5727 + 68] = mem[_5727 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5727 + -mem[64] + 100
                    if poolInfo[idx].field_512 >= bonusEndBlock:
                        _3789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3789] = 30
                        mem[_3789 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > mintEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _3789 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not mintEndBlock - poolInfo[idx].field_512:
                            _4254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4254] = 26
                            mem[_4254 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4342 + 68] = mem[idx + _4254 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4342 + 68] = mem[_4342 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4342 + -mem[64] + 100
                            _4549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4549] = 26
                            mem[_4549 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5285] = 26
                                mem[_5285 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5469 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5469 + 68] = mem[idx + _5285 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5469 + 68] = mem[_5469 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5469 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5381 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5381] = 26
                            mem[_5381 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5552 + 68] = mem[idx + _5381 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5552 + 68] = mem[_5552 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5552 + -mem[64] + 100
                        if 2 * mintEndBlock - poolInfo[idx].field_512 / mintEndBlock - poolInfo[idx].field_512 != 2:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * mintEndBlock - poolInfo[idx].field_512:
                            _4291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4291] = 26
                            mem[_4291 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4398 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4398 + 68] = mem[idx + _4291 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4398 + 68] = mem[_4398 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4398 + -mem[64] + 100
                            _4590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4590] = 26
                            mem[_4590 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5380 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5380] = 26
                                mem[_5380 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5549 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5549 + 68] = mem[idx + _5380 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5549 + 68] = mem[_5549 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5549 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5468] = 26
                            mem[_5468 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5639 + 68] = mem[idx + _5468 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5639 + 68] = mem[_5639 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5639 + -mem[64] + 100
                        if sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / 2 * mintEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512:
                            _4341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4341] = 26
                            mem[_4341 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4455 + 68] = mem[idx + _4341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4455 + 68] = mem[_4455 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4455 + -mem[64] + 100
                            _4621 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4621] = 26
                            mem[_4621 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _5467 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5467] = 26
                                mem[_5467 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _5636 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5636 + 68] = mem[idx + _5467 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5636 + 68] = mem[_5636 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5636 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5548] = 26
                            mem[_5548 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5740 + 68] = mem[idx + _5548 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5740 + 68] = mem[_5740 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5740 + -mem[64] + 100
                        if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4397] = 26
                        mem[_4397 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4500 + 68] = mem[idx + _4397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4500 + 68] = mem[_4500 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4500 + -mem[64] + 100
                        _4661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4661] = 26
                        mem[_4661 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint:
                            _5547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5547] = 26
                            mem[_5547 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5737 + 68] = mem[idx + _5547 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5737 + 68] = mem[_5737 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5737 + -mem[64] + 100
                        if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5635 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5635] = 26
                        mem[_5635 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5855 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5855 + 68] = mem[idx + _5635 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5855 + 68] = mem[_5855 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5855 + -mem[64] + 100
                    _3790 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3790] = 30
                    mem[_3790 + 32] = 'SafeMath: subtraction overflow'
                    if bonusEndBlock > mintEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3790 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not mintEndBlock - bonusEndBlock:
                        _3969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3969] = 30
                        mem[_3969 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > bonusEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _3969 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not bonusEndBlock - poolInfo[idx].field_512:
                            _4783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4783] = 26
                            mem[_4783 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4916 + 68] = mem[idx + _4783 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4916 + 68] = mem[_4916 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4916 + -mem[64] + 100
                            _5123 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5123] = 26
                            mem[_5123 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6319] = 26
                                mem[_6319 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6452 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6452 + 68] = mem[idx + _6319 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6452 + 68] = mem[_6452 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6452 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6385] = 26
                            mem[_6385 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6513 + 68] = mem[idx + _6385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6513 + 68] = mem[_6513 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6513 + -mem[64] + 100
                        if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                            _4846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4846] = 26
                            mem[_4846 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4969 + 68] = mem[idx + _4846 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4969 + 68] = mem[_4969 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4969 + -mem[64] + 100
                            _5205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5205] = 26
                            mem[_5205 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6384 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6384] = 26
                                mem[_6384 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6510 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6510 + 68] = mem[idx + _6384 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6510 + 68] = mem[_6510 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6510 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6451] = 26
                            mem[_6451 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6563 + 68] = mem[idx + _6451 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6563 + 68] = mem[_6563 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6563 + -mem[64] + 100
                        if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                            _4915 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4915] = 26
                            mem[_4915 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _5008 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5008 + 68] = mem[idx + _4915 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5008 + 68] = mem[_5008 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5008 + -mem[64] + 100
                            _5297 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5297] = 26
                            mem[_5297 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6450 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6450] = 26
                                mem[_6450 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6560 + 68] = mem[idx + _6450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6560 + 68] = mem[_6560 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6560 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6509] = 26
                            mem[_6509 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6612 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6612 + 68] = mem[idx + _6509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6612 + 68] = mem[_6612 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6612 + -mem[64] + 100
                        if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4968 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4968] = 26
                        mem[_4968 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5054 + 68] = mem[idx + _4968 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5054 + 68] = mem[_5054 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5054 + -mem[64] + 100
                        _5388 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5388] = 26
                        mem[_5388 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                            _6508 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6508] = 26
                            mem[_6508 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6609 + 68] = mem[idx + _6508 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6609 + 68] = mem[_6609 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6609 + -mem[64] + 100
                        if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6559] = 26
                        mem[_6559 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6671 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6671 + 68] = mem[idx + _6559 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6671 + 68] = mem[_6671 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6671 + -mem[64] + 100
                    if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3995 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3995] = 30
                    mem[_3995 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > bonusEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3995 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[idx].field_512:
                        if 2 * mintEndBlock - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 2 * mintEndBlock - bonusEndBlock:
                            _4843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4843] = 26
                            mem[_4843 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _4965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4965 + 68] = mem[idx + _4843 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4965 + 68] = mem[_4965 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _4965 + -mem[64] + 100
                            _5200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5200] = 26
                            mem[_5200 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6381] = 26
                                mem[_6381 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6505 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6505 + 68] = mem[idx + _6381 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6505 + 68] = mem[_6505 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6505 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6447 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6447] = 26
                            mem[_6447 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6556 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6556 + 68] = mem[idx + _6447 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6556 + 68] = mem[_6556 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6556 + -mem[64] + 100
                        if sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / 2 * mintEndBlock - bonusEndBlock != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock:
                            _4914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4914] = 26
                            mem[_4914 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _5005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5005 + 68] = mem[idx + _4914 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5005 + 68] = mem[_5005 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5005 + -mem[64] + 100
                            _5293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5293] = 26
                            mem[_5293 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6446] = 26
                                mem[_6446 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6553 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6553 + 68] = mem[idx + _6446 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6553 + 68] = mem[_6553 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6553 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6504] = 26
                            mem[_6504 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6605 + 68] = mem[idx + _6504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6605 + 68] = mem[_6605 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6605 + -mem[64] + 100
                        if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4964 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4964] = 26
                        mem[_4964 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5050 + 68] = mem[idx + _4964 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5050 + 68] = mem[_5050 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5050 + -mem[64] + 100
                        _5386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5386] = 26
                        mem[_5386 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint:
                            _6503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6503] = 26
                            mem[_6503 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6602 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6602 + 68] = mem[idx + _6503 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6602 + 68] = mem[_6602 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6602 + -mem[64] + 100
                        if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6552] = 26
                        mem[_6552 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * mintEndBlock - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6664 + 68] = mem[idx + _6552 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6664 + 68] = mem[_6664 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6664 + -mem[64] + 100
                    if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 2 * mintEndBlock - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                        _4913 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4913] = 26
                        mem[_4913 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5002 + 68] = mem[idx + _4913 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5002 + 68] = mem[_5002 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5002 + -mem[64] + 100
                        _5289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5289] = 26
                        mem[_5289 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6443] = 26
                            mem[_6443 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6549 + 68] = mem[idx + _6443 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6549 + 68] = mem[_6549 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6549 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6502] = 26
                        mem[_6502 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6599 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6599 + 68] = mem[idx + _6502 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6599 + 68] = mem[_6599 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6599 + -mem[64] + 100
                    if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4963 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4963] = 26
                        mem[_4963 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5047 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5047 + 68] = mem[idx + _4963 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5047 + 68] = mem[_5047 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5047 + -mem[64] + 100
                        _5384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5384] = 26
                        mem[_5384 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6501] = 26
                            mem[_6501 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6596 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6596 + 68] = mem[idx + _6501 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6596 + 68] = mem[_6596 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6596 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6548] = 26
                        mem[_6548 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6660 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6660 + 68] = mem[idx + _6548 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6660 + 68] = mem[_6660 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6660 + -mem[64] + 100
                    if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5001] = 26
                    mem[_5001 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5113 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5113 + 68] = mem[idx + _5001 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5113 + 68] = mem[_5113 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5113 + -mem[64] + 100
                    _5472 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5472] = 26
                    mem[_5472 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6547 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6547] = 26
                        mem[_6547 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6657 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6657 + 68] = mem[idx + _6547 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6657 + 68] = mem[_6657 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6657 + -mem[64] + 100
                    if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6595 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6595] = 26
                    mem[_6595 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6729 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6729 + 68] = mem[idx + _6595 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6729 + 68] = mem[_6729 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6729 + -mem[64] + 100
                _3753 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3753] = 30
                mem[_3753 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > mintEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3753 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not mintEndBlock - bonusEndBlock:
                    _3922 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3922] = 30
                    mem[_3922 + 32] = 'SafeMath: subtraction overflow'
                    if betaTestEndBlock > bonusEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3922 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - betaTestEndBlock:
                        _4151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4151] = 30
                        mem[_4151 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > betaTestEndBlock:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _4151 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not betaTestEndBlock - poolInfo[idx].field_512:
                            _5062 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5062] = 26
                            mem[_5062 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _5213 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5213 + 68] = mem[idx + _5062 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5213 + 68] = mem[_5213 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5213 + -mem[64] + 100
                            _5570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5570] = 26
                            mem[_5570 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6625 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6625] = 26
                                mem[_6625 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6766 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6766 + 68] = mem[idx + _6625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6766 + 68] = mem[_6766 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6766 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6692] = 26
                            mem[_6692 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6854 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6854 + 68] = mem[idx + _6692 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6854 + 68] = mem[_6854 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6854 + -mem[64] + 100
                        if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                            _5131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5131] = 26
                            mem[_5131 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _5308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5308 + 68] = mem[idx + _5131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5308 + 68] = mem[_5308 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _5308 + -mem[64] + 100
                            _5662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5662] = 26
                            mem[_5662 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / 10
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_c3c5a5acAddress)
                            call sub_c3c5a5acAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _6691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6691] = 26
                                mem[_6691 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _6851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _6851 + 68] = mem[idx + _6691 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6851 + 68] = mem[_6851 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _6851 + -mem[64] + 100
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6765] = 26
                            mem[_6765 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6952 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6952 + 68] = mem[idx + _6765 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6952 + 68] = mem[_6952 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6952 + -mem[64] + 100
                        if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5212] = 26
                        mem[_5212 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5400 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5400 + 68] = mem[idx + _5212 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5400 + 68] = mem[_5400 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5400 + -mem[64] + 100
                        _5768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5768] = 26
                        mem[_5768 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                            _6764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6764] = 26
                            mem[_6764 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6949 + 68] = mem[idx + _6764 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6949 + 68] = mem[_6949 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6949 + -mem[64] + 100
                        if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6850 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6850] = 26
                        mem[_6850 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7046 + 68] = mem[idx + _6850 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7046 + 68] = mem[_7046 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7046 + -mem[64] + 100
                    if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4175 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4175] = 30
                    mem[_4175 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _4175 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                        _5130 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5130] = 26
                        mem[_5130 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5305 + 68] = mem[idx + _5130 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5305 + 68] = mem[_5305 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5305 + -mem[64] + 100
                        _5658 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5658] = 26
                        mem[_5658 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6688] = 26
                            mem[_6688 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6847 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6847 + 68] = mem[idx + _6688 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6847 + 68] = mem[_6847 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6847 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6763] = 26
                        mem[_6763 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6946 + 68] = mem[idx + _6763 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6946 + 68] = mem[_6946 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6946 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _5211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5211] = 26
                        mem[_5211 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5397 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5397 + 68] = mem[idx + _5211 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5397 + 68] = mem[_5397 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5397 + -mem[64] + 100
                        _5766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5766] = 26
                        mem[_5766 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6762] = 26
                            mem[_6762 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6943 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6943 + 68] = mem[idx + _6762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6943 + 68] = mem[_6943 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6943 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6846] = 26
                        mem[_6846 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7042 + 68] = mem[idx + _6846 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7042 + 68] = mem[_7042 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7042 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5304] = 26
                    mem[_5304 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5481 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5481 + 68] = mem[idx + _5304 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5481 + 68] = mem[_5481 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5481 + -mem[64] + 100
                    _5881 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5881] = 26
                    mem[_5881 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6845] = 26
                        mem[_6845 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7039 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7039 + 68] = mem[idx + _6845 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7039 + 68] = mem[_7039 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7039 + -mem[64] + 100
                    if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6942 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6942] = 26
                    mem[_6942 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7122 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7122 + 68] = mem[idx + _6942 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7122 + 68] = mem[_7122 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7122 + -mem[64] + 100
                if 2 * mintEndBlock - bonusEndBlock / mintEndBlock - bonusEndBlock != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3935 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3935] = 30
                mem[_3935 + 32] = 'SafeMath: subtraction overflow'
                if betaTestEndBlock > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3935 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - betaTestEndBlock:
                    _4174 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4174] = 30
                    mem[_4174 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _4174 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 2 * mintEndBlock - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512:
                        _5127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5127] = 26
                        mem[_5127 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5301 + 68] = mem[idx + _5127 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5301 + 68] = mem[_5301 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5301 + -mem[64] + 100
                        _5653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5653] = 26
                        mem[_5653 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6685] = 26
                            mem[_6685 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6842 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6842 + 68] = mem[idx + _6685 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6842 + 68] = mem[_6842 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6842 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6759] = 26
                        mem[_6759 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6939 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6939 + 68] = mem[idx + _6759 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6939 + 68] = mem[_6939 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6939 + -mem[64] + 100
                    if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _5210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5210] = 26
                        mem[_5210 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5394 + 68] = mem[idx + _5210 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5394 + 68] = mem[_5394 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5394 + -mem[64] + 100
                        _5762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5762] = 26
                        mem[_5762 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6758] = 26
                            mem[_6758 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6936 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6936 + 68] = mem[idx + _6758 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6936 + 68] = mem[_6936 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6936 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6841 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6841] = 26
                        mem[_6841 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7035 + 68] = mem[idx + _6841 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7035 + 68] = mem[_7035 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7035 + -mem[64] + 100
                    if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5300 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5300] = 26
                    mem[_5300 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5477 + 68] = mem[idx + _5300 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5477 + 68] = mem[_5477 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5477 + -mem[64] + 100
                    _5879 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5879] = 26
                    mem[_5879 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6840] = 26
                        mem[_6840 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7032 + 68] = mem[idx + _6840 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7032 + 68] = mem[_7032 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7032 + -mem[64] + 100
                    if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6935 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6935] = 26
                    mem[_6935 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7115 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7115 + 68] = mem[idx + _6935 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7115 + 68] = mem[_7115 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7115 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4198 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4198] = 30
                mem[_4198 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4198 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if 2 * mintEndBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                    _5209 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5209] = 26
                    mem[_5209 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5391 + 68] = mem[idx + _5209 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5391 + 68] = mem[_5391 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5391 + -mem[64] + 100
                    _5758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5758] = 26
                    mem[_5758 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6755] = 26
                        mem[_6755 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6932 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6932 + 68] = mem[idx + _6755 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6932 + 68] = mem[_6932 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6932 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6839 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6839] = 26
                    mem[_6839 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7029 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7029 + 68] = mem[idx + _6839 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7029 + 68] = mem[_7029 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7029 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * mintEndBlock - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5299 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5299] = 26
                    mem[_5299 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5474 + 68] = mem[idx + _5299 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5474 + 68] = mem[_5474 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5474 + -mem[64] + 100
                    _5877 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5877] = 26
                    mem[_5877 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6838] = 26
                        mem[_6838 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7026 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7026 + 68] = mem[idx + _6838 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7026 + 68] = mem[_7026 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7026 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6931 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6931] = 26
                    mem[_6931 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7111 + 68] = mem[idx + _6931 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7111 + 68] = mem[_7111 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7111 + -mem[64] + 100
                if (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5390 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5390] = 26
                mem[_5390 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5557 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5557 + 68] = mem[idx + _5390 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5557 + 68] = mem[_5557 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5557 + -mem[64] + 100
                _5980 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5980] = 26
                mem[_5980 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6930 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6930] = 26
                    mem[_6930 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7108 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7108 + 68] = mem[idx + _6930 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7108 + 68] = mem[_7108 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7108 + -mem[64] + 100
                if 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _7025 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7025] = 26
                mem[_7025 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (2 * mintEndBlock - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7175 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7175 + 68] = mem[idx + _7025 + 32]
                    idx = idx + 32
                    continue 
                mem[_7175 + 68] = mem[_7175 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7175 + -mem[64] + 100
            if block.number <= betaTestEndBlock:
                _3746 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3746] = 30
                mem[_3746 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3746 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[idx].field_512:
                    _3994 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3994] = 26
                    mem[_3994 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4046 + 68] = mem[idx + _3994 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4046 + 68] = mem[_4046 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4046 + -mem[64] + 100
                    _4169 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4169] = 26
                    mem[_4169 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _4730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4730] = 26
                        mem[_4730 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4830 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4830 + 68] = mem[idx + _4730 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4830 + 68] = mem[_4830 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4830 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4776] = 26
                    mem[_4776 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4902 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4902 + 68] = mem[idx + _4776 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4902 + 68] = mem[_4902 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4902 + -mem[64] + 100
                if (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4014 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4014] = 26
                    mem[_4014 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4084 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4084 + 68] = mem[idx + _4014 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4084 + 68] = mem[_4084 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4084 + -mem[64] + 100
                    _4193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4193] = 26
                    mem[_4193 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _4775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4775] = 26
                        mem[_4775 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4899 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4899 + 68] = mem[idx + _4775 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4899 + 68] = mem[_4899 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4899 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4829] = 26
                    mem[_4829 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4955 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4955 + 68] = mem[idx + _4829 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4955 + 68] = mem[_4955 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4955 + -mem[64] + 100
                if (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (block.number * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4045 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4045] = 26
                mem[_4045 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4113 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4113 + 68] = mem[idx + _4045 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4113 + 68] = mem[_4113 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4113 + -mem[64] + 100
                _4217 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4217] = 26
                mem[_4217 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _4828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4828] = 26
                    mem[_4828 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4952 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4952 + 68] = mem[idx + _4828 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4952 + 68] = mem[_4952 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4952 + -mem[64] + 100
                if 10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4898 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4898] = 26
                mem[_4898 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4992 + 68] = mem[idx + _4898 + 32]
                    idx = idx + 32
                    continue 
                mem[_4992 + 68] = mem[_4992 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4992 + -mem[64] + 100
            if poolInfo[idx].field_512 >= mintEndBlock:
                _3916 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3916] = 26
                mem[_3916 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _3946 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3946 + 68] = mem[idx + _3916 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3946 + 68] = mem[_3946 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3946 + -mem[64] + 100
                _4043 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4043] = 26
                mem[_4043 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _4582 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4582] = 26
                    mem[_4582 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4658 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4658 + 68] = mem[idx + _4582 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4658 + 68] = mem[_4658 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4658 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4616 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4616] = 26
                mem[_4616 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4692 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4692 + 68] = mem[idx + _4616 + 32]
                    idx = idx + 32
                    continue 
                mem[_4692 + 68] = mem[_4692 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4692 + -mem[64] + 100
            if block.number <= bonusEndBlock:
                if poolInfo[idx].field_512 >= betaTestEndBlock:
                    _3758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3758] = 30
                    mem[_3758 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3758 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[idx].field_512:
                        _4188 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4188] = 26
                        mem[_4188 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4246 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4246 + 68] = mem[idx + _4188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4246 + 68] = mem[_4246 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4246 + -mem[64] + 100
                        _4443 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4443] = 26
                        mem[_4443 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5097 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5097] = 26
                            mem[_5097 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5265 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5265 + 68] = mem[idx + _5097 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5265 + 68] = mem[_5265 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5265 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5174 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5174] = 26
                        mem[_5174 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5362 + 68] = mem[idx + _5174 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5362 + 68] = mem[_5362 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5362 + -mem[64] + 100
                    if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                        _4216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4216] = 26
                        mem[_4216 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4280 + 68] = mem[idx + _4216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4280 + 68] = mem[_4280 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4280 + -mem[64] + 100
                        _4491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4491] = 26
                        mem[_4491 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5173] = 26
                            mem[_5173 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5359 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5359 + 68] = mem[idx + _5173 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5359 + 68] = mem[_5359 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5359 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5264] = 26
                        mem[_5264 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5451 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5451 + 68] = mem[idx + _5264 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5451 + 68] = mem[_5451 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5451 + -mem[64] + 100
                    if (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * block.number) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4245] = 26
                        mem[_4245 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4329 + 68] = mem[idx + _4245 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4329 + 68] = mem[_4329 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4329 + -mem[64] + 100
                        _4532 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4532] = 26
                        mem[_4532 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5263] = 26
                            mem[_5263 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5448 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5448 + 68] = mem[idx + _5263 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5448 + 68] = mem[_5448 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5448 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5358 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5358] = 26
                        mem[_5358 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5532 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5532 + 68] = mem[idx + _5358 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5532 + 68] = mem[_5532 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5532 + -mem[64] + 100
                    if (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * block.number * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4279] = 26
                    mem[_4279 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4385 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4385 + 68] = mem[idx + _4279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4385 + 68] = mem[_4385 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4385 + -mem[64] + 100
                    _4576 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4576] = 26
                    mem[_4576 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _5357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5357] = 26
                        mem[_5357 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5529 + 68] = mem[idx + _5357 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5529 + 68] = mem[_5529 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5529 + -mem[64] + 100
                    if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5447 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5447] = 26
                    mem[_5447 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5615 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5615 + 68] = mem[idx + _5447 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5615 + 68] = mem[_5615 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5615 + -mem[64] + 100
                _3759 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3759] = 30
                mem[_3759 + 32] = 'SafeMath: subtraction overflow'
                if betaTestEndBlock > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3759 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - betaTestEndBlock:
                    _3930 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3930] = 30
                    mem[_3930 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3930 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not betaTestEndBlock - poolInfo[idx].field_512:
                        _4536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4536] = 26
                        mem[_4536 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4613 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4613 + 68] = mem[idx + _4536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4613 + 68] = mem[_4613 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4613 + -mem[64] + 100
                        _4768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4768] = 26
                        mem[_4768 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5844] = 26
                            mem[_5844 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6038 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6038 + 68] = mem[idx + _5844 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6038 + 68] = mem[_6038 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6038 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5950 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5950] = 26
                        mem[_5950 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6120 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6120 + 68] = mem[idx + _5950 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6120 + 68] = mem[_6120 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6120 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4581] = 26
                        mem[_4581 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4655 + 68] = mem[idx + _4581 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4655 + 68] = mem[_4655 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4655 + -mem[64] + 100
                        _4823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4823] = 26
                        mem[_4823 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5949 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5949] = 26
                            mem[_5949 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6117 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6117 + 68] = mem[idx + _5949 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6117 + 68] = mem[_6117 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6117 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6037] = 26
                        mem[_6037 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6189 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6189 + 68] = mem[idx + _6037 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6189 + 68] = mem[_6189 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6189 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4612 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4612] = 26
                    mem[_4612 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4688 + 68] = mem[idx + _4612 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4688 + 68] = mem[_4688 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4688 + -mem[64] + 100
                    _4893 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4893] = 26
                    mem[_4893 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6036] = 26
                        mem[_6036 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6186 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6186 + 68] = mem[idx + _6036 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6186 + 68] = mem[_6186 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6186 + -mem[64] + 100
                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6116 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6116] = 26
                    mem[_6116 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6248 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6248 + 68] = mem[idx + _6116 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6248 + 68] = mem[_6248 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6248 + -mem[64] + 100
                if (10 * block.number) - (10 * betaTestEndBlock) / block.number - betaTestEndBlock != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3945 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3945] = 30
                mem[_3945 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3945 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if (10 * block.number) - (9 * betaTestEndBlock) < betaTestEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                    _4580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4580] = 26
                    mem[_4580 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4652 + 68] = mem[idx + _4580 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4652 + 68] = mem[_4652 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4652 + -mem[64] + 100
                    _4819 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4819] = 26
                    mem[_4819 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _5946 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5946] = 26
                        mem[_5946 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6113 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6113 + 68] = mem[idx + _5946 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6113 + 68] = mem[_6113 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6113 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6035 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6035] = 26
                    mem[_6035 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6183 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6183 + 68] = mem[idx + _6035 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6183 + 68] = mem[_6183 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6183 + -mem[64] + 100
                if (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * block.number) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4611 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4611] = 26
                    mem[_4611 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4685 + 68] = mem[idx + _4611 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4685 + 68] = mem[_4685 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4685 + -mem[64] + 100
                    _4891 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4891] = 26
                    mem[_4891 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6034] = 26
                        mem[_6034 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6180 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6180 + 68] = mem[idx + _6034 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6180 + 68] = mem[_6180 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6180 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6112 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6112] = 26
                    mem[_6112 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6244 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6244 + 68] = mem[idx + _6112 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6244 + 68] = mem[_6244 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6244 + -mem[64] + 100
                if (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * block.number * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4651 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4651] = 26
                mem[_4651 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _4720 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4720 + 68] = mem[idx + _4651 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4720 + 68] = mem[_4720 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4720 + -mem[64] + 100
                _4948 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4948] = 26
                mem[_4948 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6111] = 26
                    mem[_6111 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6241 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6241 + 68] = mem[idx + _6111 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6241 + 68] = mem[_6241 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6241 + -mem[64] + 100
                if 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6179 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6179] = 26
                mem[_6179 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * block.number * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6301 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6301 + 68] = mem[idx + _6179 + 32]
                    idx = idx + 32
                    continue 
                mem[_6301 + 68] = mem[_6301 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6301 + -mem[64] + 100
            if poolInfo[idx].field_512 >= betaTestEndBlock:
                if betaTestEndBlock > poolInfo[idx].field_512:
                    _3777 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3777] = 30
                    mem[_3777 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3777 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[idx].field_512:
                        _4235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4235] = 26
                        mem[_4235 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4312 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4312 + 68] = mem[idx + _4235 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4312 + 68] = mem[_4312 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4312 + -mem[64] + 100
                        _4521 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4521] = 26
                        mem[_4521 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5236] = 26
                            mem[_5236 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5418 + 68] = mem[idx + _5236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5418 + 68] = mem[_5418 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5418 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5328] = 26
                        mem[_5328 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5503 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5503 + 68] = mem[idx + _5328 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5503 + 68] = mem[_5503 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5503 + -mem[64] + 100
                    if 2 * block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 2:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * block.number - poolInfo[idx].field_512:
                        _4270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4270] = 26
                        mem[_4270 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4366 + 68] = mem[idx + _4270 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4366 + 68] = mem[_4366 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4366 + -mem[64] + 100
                        _4565 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4565] = 26
                        mem[_4565 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5327] = 26
                            mem[_5327 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5500 + 68] = mem[idx + _5327 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5500 + 68] = mem[_5500 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5500 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5417] = 26
                        mem[_5417 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5586 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5586 + 68] = mem[idx + _5417 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5586 + 68] = mem[_5586 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5586 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / 2 * block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512:
                        _4311 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4311] = 26
                        mem[_4311 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4421 + 68] = mem[idx + _4311 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4421 + 68] = mem[_4421 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4421 + -mem[64] + 100
                        _4602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4602] = 26
                        mem[_4602 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5416] = 26
                            mem[_5416 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5583 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5583 + 68] = mem[idx + _5416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5583 + 68] = mem[_5583 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5583 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5499] = 26
                        mem[_5499 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5679 + 68] = mem[idx + _5499 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5679 + 68] = mem[_5679 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5679 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4365 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4365] = 26
                    mem[_4365 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4472 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4472 + 68] = mem[idx + _4365 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4472 + 68] = mem[_4472 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4472 + -mem[64] + 100
                    _4639 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4639] = 26
                    mem[_4639 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint:
                        _5498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5498] = 26
                        mem[_5498 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5676 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5676 + 68] = mem[idx + _5498 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5676 + 68] = mem[_5676 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5676 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5582 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5582] = 26
                    mem[_5582 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5786 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5786 + 68] = mem[idx + _5582 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5786 + 68] = mem[_5786 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5786 + -mem[64] + 100
                if poolInfo[idx].field_512 >= bonusEndBlock:
                    _3796 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3796] = 30
                    mem[_3796 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3796 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[idx].field_512:
                        _4271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4271] = 26
                        mem[_4271 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4370 + 68] = mem[idx + _4271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4370 + 68] = mem[_4370 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4370 + -mem[64] + 100
                        _4570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4570] = 26
                        mem[_4570 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5331] = 26
                            mem[_5331 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5510 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5510 + 68] = mem[idx + _5331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5510 + 68] = mem[_5510 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5510 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5424] = 26
                        mem[_5424 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5595 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5595 + 68] = mem[idx + _5424 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5595 + 68] = mem[_5595 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5595 + -mem[64] + 100
                    if 2 * block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 2:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * block.number - poolInfo[idx].field_512:
                        _4317 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4317] = 26
                        mem[_4317 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4426 + 68] = mem[idx + _4317 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4426 + 68] = mem[_4426 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4426 + -mem[64] + 100
                        _4607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4607] = 26
                        mem[_4607 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5423] = 26
                            mem[_5423 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5592 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5592 + 68] = mem[idx + _5423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5592 + 68] = mem[_5592 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5592 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5509 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5509] = 26
                        mem[_5509 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5690 + 68] = mem[idx + _5509 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5690 + 68] = mem[_5690 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5690 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / 2 * block.number - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512:
                        _4369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4369] = 26
                        mem[_4369 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4478 + 68] = mem[idx + _4369 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4478 + 68] = mem[_4478 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4478 + -mem[64] + 100
                        _4643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4643] = 26
                        mem[_4643 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _5508 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5508] = 26
                            mem[_5508 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _5687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5687 + 68] = mem[idx + _5508 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5687 + 68] = mem[_5687 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5687 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5591] = 26
                        mem[_5591 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5799 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5799 + 68] = mem[idx + _5591 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5799 + 68] = mem[_5799 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5799 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4425 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4425] = 26
                    mem[_4425 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _4523 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4523 + 68] = mem[idx + _4425 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4523 + 68] = mem[_4523 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4523 + -mem[64] + 100
                    _4679 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4679] = 26
                    mem[_4679 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint:
                        _5590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5590] = 26
                        mem[_5590 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _5796 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5796 + 68] = mem[idx + _5590 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5796 + 68] = mem[_5796 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5796 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5686 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5686] = 26
                    mem[_5686 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - poolInfo[idx].field_512 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5908 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5908 + 68] = mem[idx + _5686 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5908 + 68] = mem[_5908 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5908 + -mem[64] + 100
                _3797 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3797] = 30
                mem[_3797 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3797 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - bonusEndBlock:
                    _3982 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3982] = 30
                    mem[_3982 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > bonusEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _3982 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[idx].field_512:
                        _4811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4811] = 26
                        mem[_4811 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4943 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4943 + 68] = mem[idx + _4811 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4943 + 68] = mem[_4943 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4943 + -mem[64] + 100
                        _5162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5162] = 26
                        mem[_5162 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6350] = 26
                            mem[_6350 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6481 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6481 + 68] = mem[idx + _6350 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6481 + 68] = mem[_6481 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6481 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6417] = 26
                        mem[_6417 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6537 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6537 + 68] = mem[idx + _6417 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6537 + 68] = mem[_6537 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6537 + -mem[64] + 100
                    if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                        _4882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4882] = 26
                        mem[_4882 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4989 + 68] = mem[idx + _4882 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4989 + 68] = mem[_4989 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4989 + -mem[64] + 100
                        _5250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5250] = 26
                        mem[_5250 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6416] = 26
                            mem[_6416 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6534 + 68] = mem[idx + _6416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6534 + 68] = mem[_6534 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6534 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6480] = 26
                        mem[_6480 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6587 + 68] = mem[idx + _6480 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6587 + 68] = mem[_6587 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6587 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                        _4942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4942] = 26
                        mem[_4942 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5032 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5032 + 68] = mem[idx + _4942 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5032 + 68] = mem[_5032 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5032 + -mem[64] + 100
                        _5343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5343] = 26
                        mem[_5343 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6479 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6479] = 26
                            mem[_6479 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6584 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6584 + 68] = mem[idx + _6479 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6584 + 68] = mem[_6584 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6584 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6533] = 26
                        mem[_6533 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6643 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6643 + 68] = mem[idx + _6533 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6643 + 68] = mem[_6643 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6643 + -mem[64] + 100
                    if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4988 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4988] = 26
                    mem[_4988 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5086 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5086 + 68] = mem[idx + _4988 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5086 + 68] = mem[_5086 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5086 + -mem[64] + 100
                    _5431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5431] = 26
                    mem[_5431 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6532 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6532] = 26
                        mem[_6532 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6640 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6640 + 68] = mem[idx + _6532 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6640 + 68] = mem[_6640 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6640 + -mem[64] + 100
                    if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6583] = 26
                    mem[_6583 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6707 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6707 + 68] = mem[idx + _6583 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6707 + 68] = mem[_6707 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6707 + -mem[64] + 100
                if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4005 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4005] = 30
                mem[_4005 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4005 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - poolInfo[idx].field_512:
                    if 2 * block.number - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not 2 * block.number - bonusEndBlock:
                        _4879 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4879] = 26
                        mem[_4879 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _4985 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4985 + 68] = mem[idx + _4879 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4985 + 68] = mem[_4985 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4985 + -mem[64] + 100
                        _5245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5245] = 26
                        mem[_5245 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6413 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6413] = 26
                            mem[_6413 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6529 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6529 + 68] = mem[idx + _6413 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6529 + 68] = mem[_6529 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6529 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6476 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6476] = 26
                        mem[_6476 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6580 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6580 + 68] = mem[idx + _6476 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6580 + 68] = mem[_6580 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6580 + -mem[64] + 100
                    if sub_9aae7b7d * 2 * block.number - bonusEndBlock / 2 * block.number - bonusEndBlock != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_9aae7b7d * 2 * block.number - bonusEndBlock:
                        _4941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4941] = 26
                        mem[_4941 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5029 + 68] = mem[idx + _4941 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5029 + 68] = mem[_5029 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5029 + -mem[64] + 100
                        _5339 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5339] = 26
                        mem[_5339 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6475] = 26
                            mem[_6475 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6577 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6577 + 68] = mem[idx + _6475 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6577 + 68] = mem[_6577 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6577 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6528 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6528] = 26
                        mem[_6528 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6636 + 68] = mem[idx + _6528 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6636 + 68] = mem[_6636 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6636 + -mem[64] + 100
                    if poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / sub_9aae7b7d * 2 * block.number - bonusEndBlock != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4984 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4984] = 26
                    mem[_4984 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5082 + 68] = mem[idx + _4984 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5082 + 68] = mem[_5082 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5082 + -mem[64] + 100
                    _5429 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5429] = 26
                    mem[_5429 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint:
                        _6527 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6527] = 26
                        mem[_6527 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6633 + 68] = mem[idx + _6527 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6633 + 68] = mem[_6633 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6633 + -mem[64] + 100
                    if 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6576 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6576] = 26
                    mem[_6576 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * poolInfo[idx].field_256 * sub_9aae7b7d * 2 * block.number - bonusEndBlock / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6700 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6700 + 68] = mem[idx + _6576 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6700 + 68] = mem[_6700 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6700 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 2 * block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                    _4940 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4940] = 26
                    mem[_4940 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5026 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5026 + 68] = mem[idx + _4940 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5026 + 68] = mem[_5026 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5026 + -mem[64] + 100
                    _5335 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5335] = 26
                    mem[_5335 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6472] = 26
                        mem[_6472 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6573 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6573 + 68] = mem[idx + _6472 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6573 + 68] = mem[_6573 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6573 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6526 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6526] = 26
                    mem[_6526 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6630 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6630 + 68] = mem[idx + _6526 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6630 + 68] = mem[_6630 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6630 + -mem[64] + 100
                if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d):
                    _4983 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4983] = 26
                    mem[_4983 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5079 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5079 + 68] = mem[idx + _4983 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5079 + 68] = mem[_5079 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5079 + -mem[64] + 100
                    _5427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5427] = 26
                    mem[_5427 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6525] = 26
                        mem[_6525 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6627 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6627 + 68] = mem[idx + _6525 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6627 + 68] = mem[_6627 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6627 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6572] = 26
                    mem[_6572 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6696 + 68] = mem[idx + _6572 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6696 + 68] = mem[_6696 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6696 + -mem[64] + 100
                if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5025 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5025] = 26
                mem[_5025 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5152 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5152 + 68] = mem[idx + _5025 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5152 + 68] = mem[_5152 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5152 + -mem[64] + 100
                _5513 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5513] = 26
                mem[_5513 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6571] = 26
                    mem[_6571 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6693 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6693 + 68] = mem[idx + _6571 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6693 + 68] = mem[_6693 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6693 + -mem[64] + 100
                if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6626 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6626] = 26
                mem[_6626 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _6769 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _6769 + 68] = mem[idx + _6626 + 32]
                    idx = idx + 32
                    continue 
                mem[_6769 + 68] = mem[_6769 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _6769 + -mem[64] + 100
            _3757 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3757] = 30
            mem[_3757 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3757 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - bonusEndBlock:
                _3929 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3929] = 30
                mem[_3929 + 32] = 'SafeMath: subtraction overflow'
                if betaTestEndBlock > bonusEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3929 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not bonusEndBlock - betaTestEndBlock:
                    _4165 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4165] = 30
                    mem[_4165 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > betaTestEndBlock:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _4165 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not betaTestEndBlock - poolInfo[idx].field_512:
                        _5094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5094] = 26
                        mem[_5094 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5258 + 68] = mem[idx + _5094 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5258 + 68] = mem[_5258 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5258 + -mem[64] + 100
                        _5613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5613] = 26
                        mem[_5613 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6656] = 26
                            mem[_6656 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6806 + 68] = mem[idx + _6656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6806 + 68] = mem[_6806 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6806 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6728] = 26
                        mem[_6728 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6902 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6902 + 68] = mem[idx + _6728 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6902 + 68] = mem[_6902 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6902 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                        _5170 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5170] = 26
                        mem[_5170 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _5354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5354 + 68] = mem[idx + _5170 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5354 + 68] = mem[_5354 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _5354 + -mem[64] + 100
                        _5713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5713] = 26
                        mem[_5713 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / 10
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_c3c5a5acAddress)
                        call sub_c3c5a5acAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _6727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6727] = 26
                            mem[_6727 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _6899 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6899 + 68] = mem[idx + _6727 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6899 + 68] = mem[_6899 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _6899 + -mem[64] + 100
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6805] = 26
                        mem[_6805 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7003 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7003 + 68] = mem[idx + _6805 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7003 + 68] = mem[_7003 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7003 + -mem[64] + 100
                    if (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _5257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5257] = 26
                    mem[_5257 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5443 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5443 + 68] = mem[idx + _5257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5443 + 68] = mem[_5443 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5443 + -mem[64] + 100
                    _5827 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5827] = 26
                    mem[_5827 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                        _6804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6804] = 26
                        mem[_6804 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _7000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7000 + 68] = mem[idx + _6804 + 32]
                            idx = idx + 32
                            continue 
                        mem[_7000 + 68] = mem[_7000 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _7000 + -mem[64] + 100
                    if 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6898 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6898] = 26
                    mem[_6898 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7092 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7092 + 68] = mem[idx + _6898 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7092 + 68] = mem[_7092 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7092 + -mem[64] + 100
                if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4187 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4187] = 30
                mem[_4187 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4187 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                    _5169 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5169] = 26
                    mem[_5169 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5351 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5351 + 68] = mem[idx + _5169 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5351 + 68] = mem[_5351 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5351 + -mem[64] + 100
                    _5709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5709] = 26
                    mem[_5709 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6724] = 26
                        mem[_6724 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6895 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6895 + 68] = mem[idx + _6724 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6895 + 68] = mem[_6895 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6895 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6803] = 26
                    mem[_6803 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6997 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6997 + 68] = mem[idx + _6803 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6997 + 68] = mem[_6997 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6997 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5256 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5256] = 26
                    mem[_5256 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5440 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5440 + 68] = mem[idx + _5256 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5440 + 68] = mem[_5440 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5440 + -mem[64] + 100
                    _5825 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5825] = 26
                    mem[_5825 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6802 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6802] = 26
                        mem[_6802 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6994 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6994 + 68] = mem[idx + _6802 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6994 + 68] = mem[_6994 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6994 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6894 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6894] = 26
                    mem[_6894 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7088 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7088 + 68] = mem[idx + _6894 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7088 + 68] = mem[_7088 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7088 + -mem[64] + 100
                if (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5350 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5350] = 26
                mem[_5350 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5522 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5522 + 68] = mem[idx + _5350 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5522 + 68] = mem[_5522 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5522 + -mem[64] + 100
                _5934 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5934] = 26
                mem[_5934 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6893 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6893] = 26
                    mem[_6893 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7085 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7085 + 68] = mem[idx + _6893 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7085 + 68] = mem[_7085 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7085 + -mem[64] + 100
                if 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6993 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6993] = 26
                mem[_6993 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7159 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7159 + 68] = mem[idx + _6993 + 32]
                    idx = idx + 32
                    continue 
                mem[_7159 + 68] = mem[_7159 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7159 + -mem[64] + 100
            if 2 * block.number - bonusEndBlock / block.number - bonusEndBlock != 2:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3944 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3944] = 30
            mem[_3944 + 32] = 'SafeMath: subtraction overflow'
            if betaTestEndBlock > bonusEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3944 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - betaTestEndBlock:
                _4186 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4186] = 30
                mem[_4186 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > betaTestEndBlock:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _4186 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if 2 * block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512:
                    _5166 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5166] = 26
                    mem[_5166 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5347 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5347 + 68] = mem[idx + _5166 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5347 + 68] = mem[_5347 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5347 + -mem[64] + 100
                    _5704 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5704] = 26
                    mem[_5704 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6721] = 26
                        mem[_6721 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6890 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6890 + 68] = mem[idx + _6721 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6890 + 68] = mem[_6890 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6890 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6799 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6799] = 26
                    mem[_6799 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6990 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6990 + 68] = mem[idx + _6799 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6990 + 68] = mem[_6990 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6990 + -mem[64] + 100
                if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + betaTestEndBlock - poolInfo[idx].field_512 != sub_9aae7b7d:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                    _5255 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5255] = 26
                    mem[_5255 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        _5437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5437 + 68] = mem[idx + _5255 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5437 + 68] = mem[_5437 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _5437 + -mem[64] + 100
                    _5821 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5821] = 26
                    mem[_5821 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / 10
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_c3c5a5acAddress)
                    call sub_c3c5a5acAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _6798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6798] = 26
                        mem[_6798 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _6987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6987 + 68] = mem[idx + _6798 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6987 + 68] = mem[_6987 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _6987 + -mem[64] + 100
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6889 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6889] = 26
                    mem[_6889 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7081 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7081 + 68] = mem[idx + _6889 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7081 + 68] = mem[_7081 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7081 + -mem[64] + 100
                if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5346 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5346] = 26
                mem[_5346 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5518 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5518 + 68] = mem[idx + _5346 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5518 + 68] = mem[_5518 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5518 + -mem[64] + 100
                _5932 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5932] = 26
                mem[_5932 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                    _6888 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6888] = 26
                    mem[_6888 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7078 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7078 + 68] = mem[idx + _6888 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7078 + 68] = mem[_7078 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7078 + -mem[64] + 100
                if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6986 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6986] = 26
                mem[_6986 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7152 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7152 + 68] = mem[idx + _6986 + 32]
                    idx = idx + 32
                    continue 
                mem[_7152 + 68] = mem[_7152 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7152 + -mem[64] + 100
            if (10 * bonusEndBlock) - (10 * betaTestEndBlock) / bonusEndBlock - betaTestEndBlock != 10:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4210 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4210] = 30
            mem[_4210 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > betaTestEndBlock:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _4210 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if (10 * bonusEndBlock) - (9 * betaTestEndBlock) < betaTestEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if 2 * block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512:
                _5254 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5254] = 26
                mem[_5254 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5434 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5434 + 68] = mem[idx + _5254 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5434 + 68] = mem[_5434 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5434 + -mem[64] + 100
                _5817 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5817] = 26
                mem[_5817 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6795] = 26
                    mem[_6795 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _6983 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _6983 + 68] = mem[idx + _6795 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6983 + 68] = mem[_6983 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _6983 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6887 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6887] = 26
                mem[_6887 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7075 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7075 + 68] = mem[idx + _6887 + 32]
                    idx = idx + 32
                    continue 
                mem[_7075 + 68] = mem[_7075 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7075 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) / (2 * block.number - bonusEndBlock) + (10 * bonusEndBlock) - (9 * betaTestEndBlock) - poolInfo[idx].field_512 != sub_9aae7b7d:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d):
                _5345 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5345] = 26
                mem[_5345 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _5515 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5515 + 68] = mem[idx + _5345 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5515 + 68] = mem[_5515 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5515 + -mem[64] + 100
                _5930 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5930] = 26
                mem[_5930 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / 10
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_c3c5a5acAddress)
                call sub_c3c5a5acAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _6886 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6886] = 26
                    mem[_6886 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _7072 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7072 + 68] = mem[idx + _6886 + 32]
                        idx = idx + 32
                        continue 
                    mem[_7072 + 68] = mem[_7072 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _7072 + -mem[64] + 100
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6982 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6982] = 26
                mem[_6982 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7148 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7148 + 68] = mem[idx + _6982 + 32]
                    idx = idx + 32
                    continue 
                mem[_7148 + 68] = mem[_7148 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7148 + -mem[64] + 100
            if (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / (2 * block.number - bonusEndBlock * sub_9aae7b7d) + (10 * bonusEndBlock * sub_9aae7b7d) - (9 * betaTestEndBlock * sub_9aae7b7d) - (poolInfo[idx].field_512 * sub_9aae7b7d) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5433 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5433] = 26
            mem[_5433 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _5600 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5600 + 68] = mem[idx + _5433 + 32]
                    idx = idx + 32
                    continue 
                mem[_5600 + 68] = mem[_5600 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5600 + -mem[64] + 100
            _6025 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6025] = 26
            mem[_6025 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / 10
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_c3c5a5acAddress)
            call sub_c3c5a5acAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint:
                _6981 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6981] = 26
                mem[_6981 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _7145 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7145 + 68] = mem[idx + _6981 + 32]
                    idx = idx + 32
                    continue 
                mem[_7145 + 68] = mem[_7145 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _7145 + -mem[64] + 100
            if 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x54536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _7071 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7071] = 26
            mem[_7071 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (2 * block.number - bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) + (10 * bonusEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (9 * betaTestEndBlock * sub_9aae7b7d * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_9aae7b7d * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _7207 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _7207 + 68] = mem[idx + _7071 + 32]
                idx = idx + 32
                continue 
            mem[_7207 + 68] = mem[_7207 + 74 len 26]
            revert with memory
              from mem[64]
               len _7207 + -mem[64] + 100
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = arg2 + totalAllocPoint - poolInfo[arg1].field_256
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
}



}

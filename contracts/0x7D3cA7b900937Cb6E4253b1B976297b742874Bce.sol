contract main {




// =====================  Runtime code  =====================


#
#  - sub_021b02ab(?)
#  - getPairInfoWithFarmTVL(address arg1, address arg2, address arg3)
#  - getPairInfoWithPrice(address arg1, address arg2)
#
address owner;
array of address sub_27d312da;
address busdAddress;
address usdtAddress;
address usdcAddress;
address daiAddress;
address sub_43b67e4cAddress;
address sub_f9896b88Address;
address wbnbAddress;
address sub_367a95bfAddress;

function usdcAddress() payable {
    return usdcAddress
}

function sub_27d312da(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_27d312da.length
    return sub_27d312da[arg1]
}

function daiAddress() payable {
    return daiAddress
}

function sub_367a95bf(?) payable {
    return sub_367a95bfAddress
}

function sub_43b67e4c(?) payable {
    return sub_43b67e4cAddress
}

function wbnbAddress() payable {
    return wbnbAddress
}

function busdAddress() payable {
    return busdAddress
}

function owner() payable {
    return owner
}

function usdtAddress() payable {
    return usdtAddress
}

function sub_f9896b88(?) payable {
    return sub_f9896b88Address
}

function _fallback() payable {
    revert
}

function getUserBalance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_5e6b57dd(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, '!owner'
    idx = 0
    while idx < sub_27d312da.length:
        mem[0] = 1
        if sub_27d312da[idx] == address(arg1):
            revert with 0, 'address exists!'
        idx = idx + 1
        continue 
    sub_27d312da.length++
    sub_27d312da[sub_27d312da.length] = address(arg1)
}

function sub_11f49a09(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 36).length) + 160 >= 128 and (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160 <= test266151307()
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    s = cd[36] + 36
    t = (32 * ('cd', 4).length) + 160
    idx = 0
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require ('cd', 4).length <= test266151307()
    mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160] = ('cd', 4).length
    mem[64] = (64 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            require idx < mem[96]
            _99 = mem[(32 * idx) + 128]
            require idx < mem[(32 * ('cd', 4).length) + 128]
            _105 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
            mem[mem[64] + 4] = mem[(32 * idx) + (32 * ('cd', 4).length) + 172 len 20]
            require ext_code.size(address(_99))
            staticcall address(_99).0x70a08231 with:
                    gas gas_remaining wei
                   args address(_105)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _116 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require idx < mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
            mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192] = mem[_116]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _104 = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[mem[64] + 64 len 32 * _104] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * _104]
        return 32, mem[mem[64] + 32 len (32 * _104) + 32]
    mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    idx = 0
    while idx < ('cd', 4).length:
        require idx < mem[96]
        _102 = mem[(32 * idx) + 128]
        require idx < mem[(32 * ('cd', 4).length) + 128]
        _107 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
        mem[mem[64] + 4] = mem[(32 * idx) + (32 * ('cd', 4).length) + 172 len 20]
        require ext_code.size(address(_102))
        staticcall address(_102).0x70a08231 with:
                gas gas_remaining wei
               args address(_107)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _117 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require idx < mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192] = mem[_117]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _106 = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
    mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
    mem[mem[64] + 64 len 32 * _106] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * _106]
    return 32, mem[mem[64] + 32 len (32 * _106) + 32]
}

function getTokenInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(arg1)
    staticcall arg1.name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[352 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _5 = mem[352]
    require mem[352] <= test266151307()
    require mem[352] + 383 < return_data.size + 352
    _6 = mem[mem[352] + 352]
    require mem[mem[352] + 352] <= test266151307()
    require ceil32(mem[mem[352] + 352]) + 32 >= 0 and ceil32(return_data.size) + ceil32(mem[mem[352] + 352]) + 384 <= test266151307()
    mem[64] = ceil32(return_data.size) + ceil32(mem[mem[352] + 352]) + 384
    mem[ceil32(return_data.size) + 352] = mem[mem[352] + 352]
    require _5 + _6 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 384 len ceil32(_6)] = mem[_5 + 384 len ceil32(_6)]
    if ceil32(_6) <= _6:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(arg1)
        staticcall arg1.0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _204 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _206 = mem[_204]
        require mem[_204] <= test266151307()
        require _204 + mem[_204] + 31 < _204 + return_data.size
        _208 = mem[_204 + mem[_204]]
        require mem[_204 + mem[_204]] <= test266151307()
        require ceil32(mem[_204 + mem[_204]]) + 32 >= 0 and _204 + ceil32(return_data.size) + ceil32(mem[_204 + mem[_204]]) + 32 <= test266151307()
        mem[64] = _204 + ceil32(return_data.size) + ceil32(mem[_204 + mem[_204]]) + 32
        mem[_204 + ceil32(return_data.size)] = _208
        require _206 + _208 + 32 <= return_data.size
        mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)] = mem[_204 + _206 + 32 len ceil32(_208)]
        if ceil32(_208) <= _208:
            require ext_code.size(arg1)
            staticcall arg1.0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _400 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _404 = mem[_400]
            require mem[_400] == mem[_400 + 31 len 1]
            require ext_code.size(arg1)
            staticcall arg1.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _416 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _420 = mem[_416]
            _422 = mem[64]
            mem[64] = mem[64] + 256
            mem[_422] = arg1
            mem[_422 + 32] = ceil32(return_data.size) + 352
            mem[_422 + 64] = _204 + ceil32(return_data.size)
            mem[_422 + 96] = uint8(_404)
            mem[_422 + 128] = 0
            mem[_422 + 160] = _420
            mem[_422 + 192] = 0
            mem[_422 + 224] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1
            mem[mem[64] + 64] = 256
            _436 = mem[ceil32(return_data.size) + 352]
            mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
            mem[mem[64] + 320 len ceil32(_436)] = mem[ceil32(return_data.size) + 384 len ceil32(_436)]
            if ceil32(_436) <= _436:
                mem[mem[64] + 96] = ceil32(_436) + 288
                mem[ceil32(_436) + mem[64] + 320] = _208
                mem[ceil32(_436) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
                if ceil32(_208) > _208:
                    mem[ceil32(_436) + mem[64] + _208 + 352] = 0
                return 32, address(arg1), 
                       256,
                       ceil32(_436) + 288,
                       _404 << 248,
                       0,
                       _420,
                       0,
                       0,
                       mem[mem[64] + 288 len ceil32(_436) + 32],
                       _208,
                       mem[mem[64] + ceil32(_436) + 352 len ceil32(_208)]
            mem[mem[64] + _436 + 320] = 0
            mem[mem[64] + 96] = ceil32(_436) + 288
            mem[ceil32(_436) + mem[64] + 320] = _208
            mem[ceil32(_436) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
            if ceil32(_208) > _208:
                mem[ceil32(_436) + mem[64] + _208 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_436) + 288,
                   _404 << 248,
                   0,
                   _420,
                   0,
                   0,
                   mem[mem[64] + 288 len _436 + 32],
                   0,
                   mem[mem[64] + _436 + 352 len ceil32(_208) + ceil32(_436) - _436]
        mem[_204 + ceil32(return_data.size) + _208 + 32] = 0
        require ext_code.size(arg1)
        staticcall arg1.0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _402 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _406 = mem[_402]
        require mem[_402] == mem[_402 + 31 len 1]
        require ext_code.size(arg1)
        staticcall arg1.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _418 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _423 = mem[_418]
        _427 = mem[64]
        mem[64] = mem[64] + 256
        mem[_427] = arg1
        mem[_427 + 32] = ceil32(return_data.size) + 352
        mem[_427 + 64] = _204 + ceil32(return_data.size)
        mem[_427 + 96] = uint8(_406)
        mem[_427 + 128] = 0
        mem[_427 + 160] = _423
        mem[_427 + 192] = 0
        mem[_427 + 224] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = arg1
        mem[mem[64] + 64] = 256
        _442 = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 320 len ceil32(_442)] = mem[ceil32(return_data.size) + 384 len ceil32(_442)]
        if ceil32(_442) <= _442:
            mem[mem[64] + 96] = ceil32(_442) + 288
            mem[ceil32(_442) + mem[64] + 320] = _208
            mem[ceil32(_442) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
            if ceil32(_208) > _208:
                mem[ceil32(_442) + mem[64] + _208 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_442) + 288,
                   _406 << 248,
                   0,
                   _423,
                   0,
                   0,
                   mem[mem[64] + 288 len ceil32(_442) + 32],
                   _208,
                   mem[mem[64] + ceil32(_442) + 352 len ceil32(_208)]
        mem[mem[64] + _442 + 320] = 0
        mem[mem[64] + 96] = ceil32(_442) + 288
        mem[ceil32(_442) + mem[64] + 320] = _208
        mem[ceil32(_442) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
        if ceil32(_208) > _208:
            mem[ceil32(_442) + mem[64] + _208 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_442) + 288,
               _406 << 248,
               0,
               _423,
               0,
               0,
               mem[mem[64] + 288 len _442 + 32],
               0,
               mem[mem[64] + _442 + 352 len ceil32(_208) + ceil32(_442) - _442]
    mem[ceil32(return_data.size) + _6 + 384] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(arg1)
    staticcall arg1.0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _205 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _207 = mem[_205]
    require mem[_205] <= test266151307()
    require _205 + mem[_205] + 31 < _205 + return_data.size
    _209 = mem[_205 + mem[_205]]
    require mem[_205 + mem[_205]] <= test266151307()
    require ceil32(mem[_205 + mem[_205]]) + 32 >= 0 and _205 + ceil32(return_data.size) + ceil32(mem[_205 + mem[_205]]) + 32 <= test266151307()
    mem[64] = _205 + ceil32(return_data.size) + ceil32(mem[_205 + mem[_205]]) + 32
    mem[_205 + ceil32(return_data.size)] = _209
    require _207 + _209 + 32 <= return_data.size
    mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)] = mem[_205 + _207 + 32 len ceil32(_209)]
    if ceil32(_209) <= _209:
        require ext_code.size(arg1)
        staticcall arg1.0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _401 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _405 = mem[_401]
        require mem[_401] == mem[_401 + 31 len 1]
        require ext_code.size(arg1)
        staticcall arg1.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _417 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _421 = mem[_417]
        _424 = mem[64]
        mem[64] = mem[64] + 256
        mem[_424] = arg1
        mem[_424 + 32] = ceil32(return_data.size) + 352
        mem[_424 + 64] = _205 + ceil32(return_data.size)
        mem[_424 + 96] = uint8(_405)
        mem[_424 + 128] = 0
        mem[_424 + 160] = _421
        mem[_424 + 192] = 0
        mem[_424 + 224] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = arg1
        mem[mem[64] + 64] = 256
        _439 = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 320 len ceil32(_439)] = mem[ceil32(return_data.size) + 384 len ceil32(_439)]
        if ceil32(_439) <= _439:
            mem[mem[64] + 96] = ceil32(_439) + 288
            mem[ceil32(_439) + mem[64] + 320] = _209
            mem[ceil32(_439) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
            if ceil32(_209) > _209:
                mem[ceil32(_439) + mem[64] + _209 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_439) + 288,
                   _405 << 248,
                   0,
                   _421,
                   0,
                   0,
                   mem[mem[64] + 288 len ceil32(_439) + 32],
                   _209,
                   mem[mem[64] + ceil32(_439) + 352 len ceil32(_209)]
        mem[mem[64] + _439 + 320] = 0
        mem[mem[64] + 96] = ceil32(_439) + 288
        mem[ceil32(_439) + mem[64] + 320] = _209
        mem[ceil32(_439) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
        if ceil32(_209) > _209:
            mem[ceil32(_439) + mem[64] + _209 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_439) + 288,
               _405 << 248,
               0,
               _421,
               0,
               0,
               mem[mem[64] + 288 len _439 + 32],
               0,
               mem[mem[64] + _439 + 352 len ceil32(_209) + ceil32(_439) - _439]
    mem[_205 + ceil32(return_data.size) + _209 + 32] = 0
    require ext_code.size(arg1)
    staticcall arg1.0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _403 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _407 = mem[_403]
    require mem[_403] == mem[_403 + 31 len 1]
    require ext_code.size(arg1)
    staticcall arg1.0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _419 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _425 = mem[_419]
    _429 = mem[64]
    mem[64] = mem[64] + 256
    mem[_429] = arg1
    mem[_429 + 32] = ceil32(return_data.size) + 352
    mem[_429 + 64] = _205 + ceil32(return_data.size)
    mem[_429 + 96] = uint8(_407)
    mem[_429 + 128] = 0
    mem[_429 + 160] = _425
    mem[_429 + 192] = 0
    mem[_429 + 224] = 0
    mem[mem[64]] = 32
    mem[mem[64] + 32] = arg1
    mem[mem[64] + 64] = 256
    _443 = mem[ceil32(return_data.size) + 352]
    mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
    mem[mem[64] + 320 len ceil32(_443)] = mem[ceil32(return_data.size) + 384 len ceil32(_443)]
    if ceil32(_443) <= _443:
        mem[mem[64] + 96] = ceil32(_443) + 288
        mem[ceil32(_443) + mem[64] + 320] = _209
        mem[ceil32(_443) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
        if ceil32(_209) > _209:
            mem[ceil32(_443) + mem[64] + _209 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_443) + 288,
               _407 << 248,
               0,
               _425,
               0,
               0,
               mem[mem[64] + 288 len ceil32(_443) + 32],
               _209,
               mem[mem[64] + ceil32(_443) + 352 len ceil32(_209)]
    mem[mem[64] + _443 + 320] = 0
    mem[mem[64] + 96] = ceil32(_443) + 288
    mem[ceil32(_443) + mem[64] + 320] = _209
    mem[ceil32(_443) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
    if ceil32(_209) > _209:
        mem[ceil32(_443) + mem[64] + _209 + 352] = 0
    return 32, address(arg1), 
           256,
           ceil32(_443) + 288,
           _407 << 248,
           0,
           _425,
           0,
           0,
           mem[mem[64] + 288 len _443 + 32],
           0,
           mem[mem[64] + _443 + 352 len ceil32(_209) + ceil32(_443) - _443]
}

function sub_bb17e444(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require ('cd', 4).length <= test266151307()
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 4).length
    mem[64] = (64 * ('cd', 4).length) + 160
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            require idx < mem[96]
            _408 = mem[(32 * idx) + 128]
            _410 = mem[64]
            mem[64] = mem[64] + 256
            mem[_410] = 0
            mem[_410 + 32] = 96
            mem[_410 + 64] = 96
            mem[_410 + 96] = 0
            mem[_410 + 128] = 0
            mem[_410 + 160] = 0
            mem[_410 + 192] = 0
            mem[_410 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_408))
            staticcall address(_408).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _420 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _424 = mem[_420]
            require mem[_420] <= test266151307()
            require _420 + mem[_420] + 31 < _420 + return_data.size
            _430 = mem[_420 + mem[_420]]
            require mem[_420 + mem[_420]] <= test266151307()
            require ceil32(mem[_420 + mem[_420]]) + 32 >= 0 and _420 + ceil32(return_data.size) + ceil32(mem[_420 + mem[_420]]) + 32 <= test266151307()
            mem[64] = _420 + ceil32(return_data.size) + ceil32(mem[_420 + mem[_420]]) + 32
            mem[_420 + ceil32(return_data.size)] = _430
            require _424 + _430 + 32 <= return_data.size
            s = 0
            while s < _430:
                mem[s + _420 + ceil32(return_data.size) + 32] = mem[s + _420 + _424 + 32]
                s = s + 32
                continue 
            if ceil32(_430) <= _430:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_408))
                staticcall address(_408).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _617 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _622 = mem[_617]
                require mem[_617] <= test266151307()
                require _617 + mem[_617] + 31 < _617 + return_data.size
                _631 = mem[_617 + mem[_617]]
                require mem[_617 + mem[_617]] <= test266151307()
                require ceil32(mem[_617 + mem[_617]]) + 32 >= 0 and _617 + ceil32(return_data.size) + ceil32(mem[_617 + mem[_617]]) + 32 <= test266151307()
                mem[64] = _617 + ceil32(return_data.size) + ceil32(mem[_617 + mem[_617]]) + 32
                mem[_617 + ceil32(return_data.size)] = _631
                require _622 + _631 + 32 <= return_data.size
                s = 0
                while s < _631:
                    mem[s + _617 + ceil32(return_data.size) + 32] = mem[s + _617 + _622 + 32]
                    s = s + 32
                    continue 
                if ceil32(_631) <= _631:
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _814 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _824 = mem[_814]
                    require mem[_814] == mem[_814 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _860 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _868 = mem[_860]
                    _871 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_871] = address(_408)
                    mem[_871 + 32] = _420 + ceil32(return_data.size)
                    mem[_871 + 64] = _617 + ceil32(return_data.size)
                    mem[_871 + 96] = uint8(_824)
                    mem[_871 + 128] = 0
                    mem[_871 + 160] = _868
                    mem[_871 + 192] = 0
                    mem[_871 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _871
                else:
                    mem[_617 + ceil32(return_data.size) + _631 + 32] = 0
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _819 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _827 = mem[_819]
                    require mem[_819] == mem[_819 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _864 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _872 = mem[_864]
                    _876 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_876] = address(_408)
                    mem[_876 + 32] = _420 + ceil32(return_data.size)
                    mem[_876 + 64] = _617 + ceil32(return_data.size)
                    mem[_876 + 96] = uint8(_827)
                    mem[_876 + 128] = 0
                    mem[_876 + 160] = _872
                    mem[_876 + 192] = 0
                    mem[_876 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _876
            else:
                mem[_420 + ceil32(return_data.size) + _430 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_408))
                staticcall address(_408).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _620 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _625 = mem[_620]
                require mem[_620] <= test266151307()
                require _620 + mem[_620] + 31 < _620 + return_data.size
                _636 = mem[_620 + mem[_620]]
                require mem[_620 + mem[_620]] <= test266151307()
                require ceil32(mem[_620 + mem[_620]]) + 32 >= 0 and _620 + ceil32(return_data.size) + ceil32(mem[_620 + mem[_620]]) + 32 <= test266151307()
                mem[64] = _620 + ceil32(return_data.size) + ceil32(mem[_620 + mem[_620]]) + 32
                mem[_620 + ceil32(return_data.size)] = _636
                require _625 + _636 + 32 <= return_data.size
                s = 0
                while s < _636:
                    mem[s + _620 + ceil32(return_data.size) + 32] = mem[s + _620 + _625 + 32]
                    s = s + 32
                    continue 
                if ceil32(_636) <= _636:
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _815 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _825 = mem[_815]
                    require mem[_815] == mem[_815 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _861 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _869 = mem[_861]
                    _873 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_873] = address(_408)
                    mem[_873 + 32] = _420 + ceil32(return_data.size)
                    mem[_873 + 64] = _620 + ceil32(return_data.size)
                    mem[_873 + 96] = uint8(_825)
                    mem[_873 + 128] = 0
                    mem[_873 + 160] = _869
                    mem[_873 + 192] = 0
                    mem[_873 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _873
                else:
                    mem[_620 + ceil32(return_data.size) + _636 + 32] = 0
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _828 = mem[_820]
                    require mem[_820] == mem[_820 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _865 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _874 = mem[_865]
                    _878 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_878] = address(_408)
                    mem[_878 + 32] = _420 + ceil32(return_data.size)
                    mem[_878 + 64] = _620 + ceil32(return_data.size)
                    mem[_878 + 96] = uint8(_828)
                    mem[_878 + 128] = 0
                    mem[_878 + 160] = _874
                    mem[_878 + 192] = 0
                    mem[_878 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _878
            idx = idx + 1
            continue 
        _407 = mem[64]
        mem[mem[64]] = 32
        _409 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + 128]
        idx = 0
        s = (32 * ('cd', 4).length) + 160
        t = mem[64] + 64
        u = mem[64] + (32 * _409) + 64
        while idx < _409:
            mem[t] = u + -_407 - 64
            _604 = mem[s]
            mem[u] = mem[mem[s] + 12 len 20]
            _608 = mem[_604 + 32]
            mem[u + 32] = 256
            _609 = mem[_608]
            mem[u + 256] = mem[_608]
            v = 0
            while v < _609:
                mem[v + u + 288] = mem[v + _608 + 32]
                v = v + 32
                continue 
            if ceil32(_609) <= _609:
                _798 = mem[_604 + 64]
                mem[u + 64] = ceil32(_609) + 288
                _804 = mem[_798]
                mem[ceil32(_609) + u + 288] = mem[_798]
                v = 0
                while v < _804:
                    mem[v + ceil32(_609) + u + 320] = mem[v + _798 + 32]
                    v = v + 32
                    continue 
                if ceil32(_804) > _804:
                    mem[ceil32(_609) + u + _804 + 320] = 0
                mem[u + 96] = mem[_604 + 96]
                mem[u + 128] = mem[_604 + 128]
                mem[u + 160] = mem[_604 + 160]
                mem[u + 192] = mem[_604 + 192]
                mem[u + 224] = mem[_604 + 224]
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_804) + ceil32(_609) + u + 320
                continue 
            mem[u + _609 + 288] = 0
            _805 = mem[_604 + 64]
            mem[u + 64] = ceil32(_609) + 288
            _813 = mem[_805]
            mem[ceil32(_609) + u + 288] = mem[_805]
            v = 0
            while v < _813:
                mem[v + ceil32(_609) + u + 320] = mem[v + _805 + 32]
                v = v + 32
                continue 
            if ceil32(_813) > _813:
                mem[ceil32(_609) + u + _813 + 320] = 0
            mem[u + 96] = mem[_604 + 96]
            mem[u + 128] = mem[_604 + 128]
            mem[u + 160] = mem[_604 + 160]
            mem[u + 192] = mem[_604 + 192]
            mem[u + 224] = mem[_604 + 224]
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_813) + ceil32(_609) + u + 320
            continue 
    else:
        mem[64] = (64 * ('cd', 4).length) + 416
        mem[(64 * ('cd', 4).length) + 160] = 0
        mem[(64 * ('cd', 4).length) + 192] = 96
        mem[(64 * ('cd', 4).length) + 224] = 96
        mem[(64 * ('cd', 4).length) + 256] = 0
        mem[(64 * ('cd', 4).length) + 288] = 0
        mem[(64 * ('cd', 4).length) + 320] = 0
        mem[(64 * ('cd', 4).length) + 352] = 0
        mem[(64 * ('cd', 4).length) + 384] = 0
        mem[var23001] = (64 * ('cd', 4).length) + 160
        s = var23001
        idx = var23002
        while idx - 1:
            mem[64] = mem[64] + 256
            mem[(64 * ('cd', 4).length) + 160] = 0
            mem[(64 * ('cd', 4).length) + 192] = 96
            mem[(64 * ('cd', 4).length) + 224] = 96
            mem[(64 * ('cd', 4).length) + 256] = 0
            mem[(64 * ('cd', 4).length) + 288] = 0
            mem[(64 * ('cd', 4).length) + 320] = 0
            mem[(64 * ('cd', 4).length) + 352] = 0
            mem[(64 * ('cd', 4).length) + 384] = 0
            mem[s + 32] = (64 * ('cd', 4).length) + 160
            s = s + 32
            idx = idx - 1
            continue 
        _790 = mem[96]
        idx = 0
        while idx < _790:
            require idx < mem[96]
            _796 = mem[(32 * idx) + 128]
            _803 = mem[64]
            mem[64] = mem[64] + 256
            mem[_803] = 0
            mem[_803 + 32] = 96
            mem[_803 + 64] = 96
            mem[_803 + 96] = 0
            mem[_803 + 128] = 0
            mem[_803 + 160] = 0
            mem[_803 + 192] = 0
            mem[_803 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_796))
            staticcall address(_796).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _822 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _829 = mem[_822]
            require mem[_822] <= test266151307()
            require _822 + mem[_822] + 31 < _822 + return_data.size
            _840 = mem[_822 + mem[_822]]
            require mem[_822 + mem[_822]] <= test266151307()
            require ceil32(mem[_822 + mem[_822]]) + 32 >= 0 and _822 + ceil32(return_data.size) + ceil32(mem[_822 + mem[_822]]) + 32 <= test266151307()
            mem[64] = _822 + ceil32(return_data.size) + ceil32(mem[_822 + mem[_822]]) + 32
            mem[_822 + ceil32(return_data.size)] = _840
            require _829 + _840 + 32 <= return_data.size
            s = 0
            while s < _840:
                mem[s + _822 + ceil32(return_data.size) + 32] = mem[s + _822 + _829 + 32]
                _790 = mem[96]
                s = s + 32
                continue 
            if ceil32(_840) <= _840:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_796))
                staticcall address(_796).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _991 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _993 = mem[_991]
                require mem[_991] <= test266151307()
                require _991 + mem[_991] + 31 < _991 + return_data.size
                _998 = mem[_991 + mem[_991]]
                require mem[_991 + mem[_991]] <= test266151307()
                require ceil32(mem[_991 + mem[_991]]) + 32 >= 0 and _991 + ceil32(return_data.size) + ceil32(mem[_991 + mem[_991]]) + 32 <= test266151307()
                mem[64] = _991 + ceil32(return_data.size) + ceil32(mem[_991 + mem[_991]]) + 32
                mem[_991 + ceil32(return_data.size)] = _998
                require _993 + _998 + 32 <= return_data.size
                s = 0
                while s < _998:
                    mem[s + _991 + ceil32(return_data.size) + 32] = mem[s + _991 + _993 + 32]
                    _790 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_998) <= _998:
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1082 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1087 = mem[_1082]
                    require mem[_1082] == mem[_1082 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1120 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1124 = mem[_1120]
                    _1126 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1126] = address(_796)
                    mem[_1126 + 32] = _822 + ceil32(return_data.size)
                    mem[_1126 + 64] = _991 + ceil32(return_data.size)
                    mem[_1126 + 96] = uint8(_1087)
                    mem[_1126 + 128] = 0
                    mem[_1126 + 160] = _1124
                    mem[_1126 + 192] = 0
                    mem[_1126 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1126
                else:
                    mem[_991 + ceil32(return_data.size) + _998 + 32] = 0
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1084 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1090 = mem[_1084]
                    require mem[_1084] == mem[_1084 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1122 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1127 = mem[_1122]
                    _1131 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1131] = address(_796)
                    mem[_1131 + 32] = _822 + ceil32(return_data.size)
                    mem[_1131 + 64] = _991 + ceil32(return_data.size)
                    mem[_1131 + 96] = uint8(_1090)
                    mem[_1131 + 128] = 0
                    mem[_1131 + 160] = _1127
                    mem[_1131 + 192] = 0
                    mem[_1131 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1131
            else:
                mem[_822 + ceil32(return_data.size) + _840 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_796))
                staticcall address(_796).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _992 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _995 = mem[_992]
                require mem[_992] <= test266151307()
                require _992 + mem[_992] + 31 < _992 + return_data.size
                _1000 = mem[_992 + mem[_992]]
                require mem[_992 + mem[_992]] <= test266151307()
                require ceil32(mem[_992 + mem[_992]]) + 32 >= 0 and _992 + ceil32(return_data.size) + ceil32(mem[_992 + mem[_992]]) + 32 <= test266151307()
                mem[64] = _992 + ceil32(return_data.size) + ceil32(mem[_992 + mem[_992]]) + 32
                mem[_992 + ceil32(return_data.size)] = _1000
                require _995 + _1000 + 32 <= return_data.size
                s = 0
                while s < _1000:
                    mem[s + _992 + ceil32(return_data.size) + 32] = mem[s + _992 + _995 + 32]
                    _790 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_1000) <= _1000:
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1083 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1088 = mem[_1083]
                    require mem[_1083] == mem[_1083 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1121 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1125 = mem[_1121]
                    _1128 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1128] = address(_796)
                    mem[_1128 + 32] = _822 + ceil32(return_data.size)
                    mem[_1128 + 64] = _992 + ceil32(return_data.size)
                    mem[_1128 + 96] = uint8(_1088)
                    mem[_1128 + 128] = 0
                    mem[_1128 + 160] = _1125
                    mem[_1128 + 192] = 0
                    mem[_1128 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1128
                else:
                    mem[_992 + ceil32(return_data.size) + _1000 + 32] = 0
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1085 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1091 = mem[_1085]
                    require mem[_1085] == mem[_1085 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1123 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1129 = mem[_1123]
                    _1133 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1133] = address(_796)
                    mem[_1133 + 32] = _822 + ceil32(return_data.size)
                    mem[_1133 + 64] = _992 + ceil32(return_data.size)
                    mem[_1133 + 96] = uint8(_1091)
                    mem[_1133 + 128] = 0
                    mem[_1133 + 160] = _1129
                    mem[_1133 + 192] = 0
                    mem[_1133 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1133
            _790 = mem[96]
            idx = idx + 1
            continue 
        _795 = mem[64]
        mem[mem[64]] = 32
        _797 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + 128]
        idx = 0
        s = (32 * ('cd', 4).length) + 160
        t = mem[64] + 64
        u = mem[64] + (32 * _797) + 64
        while idx < _797:
            mem[t] = u + -_795 - 64
            _960 = mem[s]
            mem[u] = mem[mem[s] + 12 len 20]
            _964 = mem[_960 + 32]
            mem[u + 32] = 256
            _965 = mem[_964]
            mem[u + 256] = mem[_964]
            v = 0
            while v < _965:
                mem[v + u + 288] = mem[v + _964 + 32]
                v = v + 32
                continue 
            if ceil32(_965) <= _965:
                _1070 = mem[_960 + 64]
                mem[u + 64] = ceil32(_965) + 288
                _1075 = mem[_1070]
                mem[ceil32(_965) + u + 288] = mem[_1070]
                v = 0
                while v < _1075:
                    mem[v + ceil32(_965) + u + 320] = mem[v + _1070 + 32]
                    v = v + 32
                    continue 
                if ceil32(_1075) > _1075:
                    mem[ceil32(_965) + u + _1075 + 320] = 0
                mem[u + 96] = mem[_960 + 96]
                mem[u + 128] = mem[_960 + 128]
                mem[u + 160] = mem[_960 + 160]
                mem[u + 192] = mem[_960 + 192]
                mem[u + 224] = mem[_960 + 224]
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_1075) + ceil32(_965) + u + 320
                continue 
            mem[u + _965 + 288] = 0
            _1076 = mem[_960 + 64]
            mem[u + 64] = ceil32(_965) + 288
            _1081 = mem[_1076]
            mem[ceil32(_965) + u + 288] = mem[_1076]
            v = 0
            while v < _1081:
                mem[v + ceil32(_965) + u + 320] = mem[v + _1076 + 32]
                v = v + 32
                continue 
            if ceil32(_1081) > _1081:
                mem[ceil32(_965) + u + _1081 + 320] = 0
            mem[u + 96] = mem[_960 + 96]
            mem[u + 128] = mem[_960 + 128]
            mem[u + 160] = mem[_960 + 160]
            mem[u + 192] = mem[_960 + 192]
            mem[u + 224] = mem[_960 + 224]
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_1081) + ceil32(_965) + u + 320
            continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function getPairTokenInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[352] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 352] = 0
    mem[ceil32(return_data.size) + 384] = 96
    mem[ceil32(return_data.size) + 416] = 96
    mem[ceil32(return_data.size) + 448] = 0
    mem[ceil32(return_data.size) + 480] = 0
    mem[ceil32(return_data.size) + 512] = 0
    mem[ceil32(return_data.size) + 544] = 0
    mem[ceil32(return_data.size) + 576] = 0
    mem[ceil32(return_data.size) + 608] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 608 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 608
    require return_data.size >= 32
    _10 = mem[ceil32(return_data.size) + 608]
    require mem[ceil32(return_data.size) + 608] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 639 < ceil32(return_data.size) + return_data.size + 608
    _11 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608] <= test266151307()
    require ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 32 >= 0 and (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640
    mem[(2 * ceil32(return_data.size)) + 608] = _11
    require _10 + _11 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 640 len ceil32(_11)] = mem[ceil32(return_data.size) + _10 + 640 len ceil32(_11)]
    if ceil32(_11) <= _11:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _609 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _611 = mem[_609]
        require mem[_609] <= test266151307()
        require _609 + mem[_609] + 31 < _609 + return_data.size
        _613 = mem[_609 + mem[_609]]
        require mem[_609 + mem[_609]] <= test266151307()
        require ceil32(mem[_609 + mem[_609]]) + 32 >= 0 and _609 + ceil32(return_data.size) + ceil32(mem[_609 + mem[_609]]) + 32 <= test266151307()
        mem[64] = _609 + ceil32(return_data.size) + ceil32(mem[_609 + mem[_609]]) + 32
        mem[_609 + ceil32(return_data.size)] = _613
        require _611 + _613 + 32 <= return_data.size
        mem[_609 + ceil32(return_data.size) + 32 len ceil32(_613)] = mem[_609 + _611 + 32 len ceil32(_613)]
        if ceil32(_613) <= _613:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1205 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1209 = mem[_1205]
            require mem[_1205] == mem[_1205 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1221 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1225 = mem[_1221]
            _1227 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1227] = address(ext_call.return_data[0])
            mem[_1227 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1227 + 64] = _609 + ceil32(return_data.size)
            mem[_1227 + 96] = uint8(_1209)
            mem[_1227 + 128] = 0
            mem[_1227 + 160] = _1225
            mem[_1227 + 192] = 0
            mem[_1227 + 224] = 0
            _1233 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1233] = 0
            mem[_1233 + 32] = 96
            mem[_1233 + 64] = 96
            mem[_1233 + 96] = 0
            mem[_1233 + 128] = 0
            mem[_1233 + 160] = 0
            mem[_1233 + 192] = 0
            mem[_1233 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1245 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1249 = mem[_1245]
            require mem[_1245] == mem[_1245 + 12 len 20]
            _1253 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1253] = 0
            mem[_1253 + 32] = 96
            mem[_1253 + 64] = 96
            mem[_1253 + 96] = 0
            mem[_1253 + 128] = 0
            mem[_1253 + 160] = 0
            mem[_1253 + 192] = 0
            mem[_1253 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1249))
            staticcall address(_1249).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1265 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1269 = mem[_1265]
            require mem[_1265] <= test266151307()
            require _1265 + mem[_1265] + 31 < _1265 + return_data.size
            _1273 = mem[_1265 + mem[_1265]]
            require mem[_1265 + mem[_1265]] <= test266151307()
            require ceil32(mem[_1265 + mem[_1265]]) + 32 >= 0 and _1265 + ceil32(return_data.size) + ceil32(mem[_1265 + mem[_1265]]) + 32 <= test266151307()
            mem[64] = _1265 + ceil32(return_data.size) + ceil32(mem[_1265 + mem[_1265]]) + 32
            mem[_1265 + ceil32(return_data.size)] = _1273
            require _1269 + _1273 + 32 <= return_data.size
            mem[_1265 + ceil32(return_data.size) + 32 len ceil32(_1273)] = mem[_1265 + _1269 + 32 len ceil32(_1273)]
            if ceil32(_1273) <= _1273:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1249))
                staticcall address(_1249).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1793 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1801 = mem[_1793]
                require mem[_1793] <= test266151307()
                require _1793 + mem[_1793] + 31 < _1793 + return_data.size
                _1809 = mem[_1793 + mem[_1793]]
                require mem[_1793 + mem[_1793]] <= test266151307()
                require ceil32(mem[_1793 + mem[_1793]]) + 32 >= 0 and _1793 + ceil32(return_data.size) + ceil32(mem[_1793 + mem[_1793]]) + 32 <= test266151307()
                mem[64] = _1793 + ceil32(return_data.size) + ceil32(mem[_1793 + mem[_1793]]) + 32
                mem[_1793 + ceil32(return_data.size)] = _1809
                require _1801 + _1809 + 32 <= return_data.size
                mem[_1793 + ceil32(return_data.size) + 32 len ceil32(_1809)] = mem[_1793 + _1801 + 32 len ceil32(_1809)]
                if ceil32(_1809) <= _1809:
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2305 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2321 = mem[_2305]
                    require mem[_2305] == mem[_2305 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2369 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2385 = mem[_2369]
                    _2393 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2393] = address(_1249)
                    mem[_2393 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2393 + 64] = _1793 + ceil32(return_data.size)
                    mem[_2393 + 96] = uint8(_2321)
                    mem[_2393 + 128] = 0
                    mem[_2393 + 160] = _2385
                    mem[_2393 + 192] = 0
                    mem[_2393 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2449 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2465 = mem[_2449]
                    require mem[_2449] == mem[_2449 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2465))
                    staticcall address(_2465).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2513 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2513]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2577 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2593 = mem[_2577]
                    require mem[_2577] == mem[_2577 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2593))
                    staticcall address(_2593).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2641 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2393 + 128] = mem[_2641]
                    _2665 = mem[64]
                    mem[mem[64]] = 2
                    _3297 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3297] = 0
                    mem[_3297 + 32] = 96
                    mem[_3297 + 64] = 96
                    mem[_3297 + 96] = 0
                    mem[_3297 + 128] = 0
                    mem[_3297 + 160] = 0
                    mem[_3297 + 192] = 0
                    mem[_3297 + 224] = 0
                    mem[var171001] = _3297
                    s = var171001
                    idx = var171002
                    while idx - 1:
                        _3297 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3297] = 0
                        mem[_3297 + 32] = 96
                        mem[_3297 + 64] = 96
                        mem[_3297 + 96] = 0
                        mem[_3297 + 128] = 0
                        mem[_3297 + 160] = 0
                        mem[_3297 + 192] = 0
                        mem[_3297 + 224] = 0
                        mem[s + 32] = _3297
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2665]
                    mem[_2665 + 32] = _1227
                    require 1 < mem[_2665]
                    mem[_2665 + 64] = _2393
                    _3345 = mem[64]
                    mem[mem[64]] = 32
                    _3361 = mem[_2665]
                    mem[mem[64] + 32] = mem[_2665]
                    idx = 0
                    s = _2665 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3361) + 64
                    while idx < _3361:
                        mem[t] = u + -_3345 - 64
                        _3889 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3907 = mem[_3889 + 32]
                        mem[u + 32] = 256
                        _3953 = mem[_3907]
                        mem[u + 256] = mem[_3907]
                        v = 0
                        while v < _3953:
                            mem[v + u + 288] = mem[v + _3907 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3953) <= _3953:
                            _4417 = mem[_3889 + 64]
                            mem[u + 64] = ceil32(_3953) + 288
                            _4433 = mem[_4417]
                            mem[ceil32(_3953) + u + 288] = mem[_4417]
                            v = 0
                            while v < _4433:
                                mem[v + ceil32(_3953) + u + 320] = mem[v + _4417 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4433) > _4433:
                                mem[ceil32(_3953) + u + _4433 + 320] = 0
                            mem[u + 96] = mem[_3889 + 96]
                            mem[u + 128] = mem[_3889 + 128]
                            mem[u + 160] = mem[_3889 + 160]
                            mem[u + 192] = mem[_3889 + 192]
                            mem[u + 224] = mem[_3889 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4433) + ceil32(_3953) + u + 320
                            continue 
                        mem[u + _3953 + 288] = 0
                        _4434 = mem[_3889 + 64]
                        mem[u + 64] = ceil32(_3953) + 288
                        _4465 = mem[_4434]
                        mem[ceil32(_3953) + u + 288] = mem[_4434]
                        v = 0
                        while v < _4465:
                            mem[v + ceil32(_3953) + u + 320] = mem[v + _4434 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4465) > _4465:
                            mem[ceil32(_3953) + u + _4465 + 320] = 0
                        mem[u + 96] = mem[_3889 + 96]
                        mem[u + 128] = mem[_3889 + 128]
                        mem[u + 160] = mem[_3889 + 160]
                        mem[u + 192] = mem[_3889 + 192]
                        mem[u + 224] = mem[_3889 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4465) + ceil32(_3953) + u + 320
                        continue 
                else:
                    mem[_1793 + ceil32(return_data.size) + _1809 + 32] = 0
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2313 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2329 = mem[_2313]
                    require mem[_2313] == mem[_2313 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2377 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2394 = mem[_2377]
                    _2411 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2411] = address(_1249)
                    mem[_2411 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2411 + 64] = _1793 + ceil32(return_data.size)
                    mem[_2411 + 96] = uint8(_2329)
                    mem[_2411 + 128] = 0
                    mem[_2411 + 160] = _2394
                    mem[_2411 + 192] = 0
                    mem[_2411 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2457 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2473 = mem[_2457]
                    require mem[_2457] == mem[_2457 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2473))
                    staticcall address(_2473).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2521 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2521]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2585 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2601 = mem[_2585]
                    require mem[_2585] == mem[_2585 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2601))
                    staticcall address(_2601).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2649 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2411 + 128] = mem[_2649]
                    _2681 = mem[64]
                    mem[mem[64]] = 2
                    _3298 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3298] = 0
                    mem[_3298 + 32] = 96
                    mem[_3298 + 64] = 96
                    mem[_3298 + 96] = 0
                    mem[_3298 + 128] = 0
                    mem[_3298 + 160] = 0
                    mem[_3298 + 192] = 0
                    mem[_3298 + 224] = 0
                    mem[var172001] = _3298
                    s = var172001
                    idx = var172002
                    while idx - 1:
                        _3298 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3298] = 0
                        mem[_3298 + 32] = 96
                        mem[_3298 + 64] = 96
                        mem[_3298 + 96] = 0
                        mem[_3298 + 128] = 0
                        mem[_3298 + 160] = 0
                        mem[_3298 + 192] = 0
                        mem[_3298 + 224] = 0
                        mem[s + 32] = _3298
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2681]
                    mem[_2681 + 32] = _1227
                    require 1 < mem[_2681]
                    mem[_2681 + 64] = _2411
                    _3346 = mem[64]
                    mem[mem[64]] = 32
                    _3362 = mem[_2681]
                    mem[mem[64] + 32] = mem[_2681]
                    idx = 0
                    s = _2681 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3362) + 64
                    while idx < _3362:
                        mem[t] = u + -_3346 - 64
                        _3890 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3910 = mem[_3890 + 32]
                        mem[u + 32] = 256
                        _3954 = mem[_3910]
                        mem[u + 256] = mem[_3910]
                        v = 0
                        while v < _3954:
                            mem[v + u + 288] = mem[v + _3910 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3954) <= _3954:
                            _4418 = mem[_3890 + 64]
                            mem[u + 64] = ceil32(_3954) + 288
                            _4435 = mem[_4418]
                            mem[ceil32(_3954) + u + 288] = mem[_4418]
                            v = 0
                            while v < _4435:
                                mem[v + ceil32(_3954) + u + 320] = mem[v + _4418 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4435) > _4435:
                                mem[ceil32(_3954) + u + _4435 + 320] = 0
                            mem[u + 96] = mem[_3890 + 96]
                            mem[u + 128] = mem[_3890 + 128]
                            mem[u + 160] = mem[_3890 + 160]
                            mem[u + 192] = mem[_3890 + 192]
                            mem[u + 224] = mem[_3890 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4435) + ceil32(_3954) + u + 320
                            continue 
                        mem[u + _3954 + 288] = 0
                        _4436 = mem[_3890 + 64]
                        mem[u + 64] = ceil32(_3954) + 288
                        _4466 = mem[_4436]
                        mem[ceil32(_3954) + u + 288] = mem[_4436]
                        v = 0
                        while v < _4466:
                            mem[v + ceil32(_3954) + u + 320] = mem[v + _4436 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4466) > _4466:
                            mem[ceil32(_3954) + u + _4466 + 320] = 0
                        mem[u + 96] = mem[_3890 + 96]
                        mem[u + 128] = mem[_3890 + 128]
                        mem[u + 160] = mem[_3890 + 160]
                        mem[u + 192] = mem[_3890 + 192]
                        mem[u + 224] = mem[_3890 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4466) + ceil32(_3954) + u + 320
                        continue 
            else:
                mem[_1265 + ceil32(return_data.size) + _1273 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1249))
                staticcall address(_1249).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1797 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1805 = mem[_1797]
                require mem[_1797] <= test266151307()
                require _1797 + mem[_1797] + 31 < _1797 + return_data.size
                _1813 = mem[_1797 + mem[_1797]]
                require mem[_1797 + mem[_1797]] <= test266151307()
                require ceil32(mem[_1797 + mem[_1797]]) + 32 >= 0 and _1797 + ceil32(return_data.size) + ceil32(mem[_1797 + mem[_1797]]) + 32 <= test266151307()
                mem[64] = _1797 + ceil32(return_data.size) + ceil32(mem[_1797 + mem[_1797]]) + 32
                mem[_1797 + ceil32(return_data.size)] = _1813
                require _1805 + _1813 + 32 <= return_data.size
                mem[_1797 + ceil32(return_data.size) + 32 len ceil32(_1813)] = mem[_1797 + _1805 + 32 len ceil32(_1813)]
                if ceil32(_1813) <= _1813:
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2322 = mem[_2306]
                    require mem[_2306] == mem[_2306 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2370 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2386 = mem[_2370]
                    _2395 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2395] = address(_1249)
                    mem[_2395 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2395 + 64] = _1797 + ceil32(return_data.size)
                    mem[_2395 + 96] = uint8(_2322)
                    mem[_2395 + 128] = 0
                    mem[_2395 + 160] = _2386
                    mem[_2395 + 192] = 0
                    mem[_2395 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2450 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2466 = mem[_2450]
                    require mem[_2450] == mem[_2450 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2466))
                    staticcall address(_2466).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2514 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2514]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2594 = mem[_2578]
                    require mem[_2578] == mem[_2578 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2594))
                    staticcall address(_2594).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2642 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2395 + 128] = mem[_2642]
                    _2667 = mem[64]
                    mem[mem[64]] = 2
                    _3299 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3299] = 0
                    mem[_3299 + 32] = 96
                    mem[_3299 + 64] = 96
                    mem[_3299 + 96] = 0
                    mem[_3299 + 128] = 0
                    mem[_3299 + 160] = 0
                    mem[_3299 + 192] = 0
                    mem[_3299 + 224] = 0
                    mem[var172001] = _3299
                    s = var172001
                    idx = var172002
                    while idx - 1:
                        _3299 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3299] = 0
                        mem[_3299 + 32] = 96
                        mem[_3299 + 64] = 96
                        mem[_3299 + 96] = 0
                        mem[_3299 + 128] = 0
                        mem[_3299 + 160] = 0
                        mem[_3299 + 192] = 0
                        mem[_3299 + 224] = 0
                        mem[s + 32] = _3299
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2667]
                    mem[_2667 + 32] = _1227
                    require 1 < mem[_2667]
                    mem[_2667 + 64] = _2395
                    _3347 = mem[64]
                    mem[mem[64]] = 32
                    _3363 = mem[_2667]
                    mem[mem[64] + 32] = mem[_2667]
                    idx = 0
                    s = _2667 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3363) + 64
                    while idx < _3363:
                        mem[t] = u + -_3347 - 64
                        _3891 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3913 = mem[_3891 + 32]
                        mem[u + 32] = 256
                        _3955 = mem[_3913]
                        mem[u + 256] = mem[_3913]
                        v = 0
                        while v < _3955:
                            mem[v + u + 288] = mem[v + _3913 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3955) <= _3955:
                            _4419 = mem[_3891 + 64]
                            mem[u + 64] = ceil32(_3955) + 288
                            _4437 = mem[_4419]
                            mem[ceil32(_3955) + u + 288] = mem[_4419]
                            v = 0
                            while v < _4437:
                                mem[v + ceil32(_3955) + u + 320] = mem[v + _4419 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4437) > _4437:
                                mem[ceil32(_3955) + u + _4437 + 320] = 0
                            mem[u + 96] = mem[_3891 + 96]
                            mem[u + 128] = mem[_3891 + 128]
                            mem[u + 160] = mem[_3891 + 160]
                            mem[u + 192] = mem[_3891 + 192]
                            mem[u + 224] = mem[_3891 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4437) + ceil32(_3955) + u + 320
                            continue 
                        mem[u + _3955 + 288] = 0
                        _4438 = mem[_3891 + 64]
                        mem[u + 64] = ceil32(_3955) + 288
                        _4467 = mem[_4438]
                        mem[ceil32(_3955) + u + 288] = mem[_4438]
                        v = 0
                        while v < _4467:
                            mem[v + ceil32(_3955) + u + 320] = mem[v + _4438 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4467) > _4467:
                            mem[ceil32(_3955) + u + _4467 + 320] = 0
                        mem[u + 96] = mem[_3891 + 96]
                        mem[u + 128] = mem[_3891 + 128]
                        mem[u + 160] = mem[_3891 + 160]
                        mem[u + 192] = mem[_3891 + 192]
                        mem[u + 224] = mem[_3891 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4467) + ceil32(_3955) + u + 320
                        continue 
                else:
                    mem[_1797 + ceil32(return_data.size) + _1813 + 32] = 0
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2314 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2330 = mem[_2314]
                    require mem[_2314] == mem[_2314 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2378 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2396 = mem[_2378]
                    _2414 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2414] = address(_1249)
                    mem[_2414 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2414 + 64] = _1797 + ceil32(return_data.size)
                    mem[_2414 + 96] = uint8(_2330)
                    mem[_2414 + 128] = 0
                    mem[_2414 + 160] = _2396
                    mem[_2414 + 192] = 0
                    mem[_2414 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2458 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2474 = mem[_2458]
                    require mem[_2458] == mem[_2458 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2474))
                    staticcall address(_2474).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2522 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2522]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2586 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2602 = mem[_2586]
                    require mem[_2586] == mem[_2586 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2602))
                    staticcall address(_2602).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2650 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2414 + 128] = mem[_2650]
                    _2682 = mem[64]
                    mem[mem[64]] = 2
                    _3300 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3300] = 0
                    mem[_3300 + 32] = 96
                    mem[_3300 + 64] = 96
                    mem[_3300 + 96] = 0
                    mem[_3300 + 128] = 0
                    mem[_3300 + 160] = 0
                    mem[_3300 + 192] = 0
                    mem[_3300 + 224] = 0
                    mem[var173001] = _3300
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3300 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3300] = 0
                        mem[_3300 + 32] = 96
                        mem[_3300 + 64] = 96
                        mem[_3300 + 96] = 0
                        mem[_3300 + 128] = 0
                        mem[_3300 + 160] = 0
                        mem[_3300 + 192] = 0
                        mem[_3300 + 224] = 0
                        mem[s + 32] = _3300
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2682]
                    mem[_2682 + 32] = _1227
                    require 1 < mem[_2682]
                    mem[_2682 + 64] = _2414
                    _3348 = mem[64]
                    mem[mem[64]] = 32
                    _3364 = mem[_2682]
                    mem[mem[64] + 32] = mem[_2682]
                    idx = 0
                    s = _2682 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3364) + 64
                    while idx < _3364:
                        mem[t] = u + -_3348 - 64
                        _3892 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3916 = mem[_3892 + 32]
                        mem[u + 32] = 256
                        _3956 = mem[_3916]
                        mem[u + 256] = mem[_3916]
                        v = 0
                        while v < _3956:
                            mem[v + u + 288] = mem[v + _3916 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3956) <= _3956:
                            _4420 = mem[_3892 + 64]
                            mem[u + 64] = ceil32(_3956) + 288
                            _4439 = mem[_4420]
                            mem[ceil32(_3956) + u + 288] = mem[_4420]
                            v = 0
                            while v < _4439:
                                mem[v + ceil32(_3956) + u + 320] = mem[v + _4420 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4439) > _4439:
                                mem[ceil32(_3956) + u + _4439 + 320] = 0
                            mem[u + 96] = mem[_3892 + 96]
                            mem[u + 128] = mem[_3892 + 128]
                            mem[u + 160] = mem[_3892 + 160]
                            mem[u + 192] = mem[_3892 + 192]
                            mem[u + 224] = mem[_3892 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4439) + ceil32(_3956) + u + 320
                            continue 
                        mem[u + _3956 + 288] = 0
                        _4440 = mem[_3892 + 64]
                        mem[u + 64] = ceil32(_3956) + 288
                        _4468 = mem[_4440]
                        mem[ceil32(_3956) + u + 288] = mem[_4440]
                        v = 0
                        while v < _4468:
                            mem[v + ceil32(_3956) + u + 320] = mem[v + _4440 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4468) > _4468:
                            mem[ceil32(_3956) + u + _4468 + 320] = 0
                        mem[u + 96] = mem[_3892 + 96]
                        mem[u + 128] = mem[_3892 + 128]
                        mem[u + 160] = mem[_3892 + 160]
                        mem[u + 192] = mem[_3892 + 192]
                        mem[u + 224] = mem[_3892 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4468) + ceil32(_3956) + u + 320
                        continue 
        else:
            mem[_609 + ceil32(return_data.size) + _613 + 32] = 0
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1207 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1211 = mem[_1207]
            require mem[_1207] == mem[_1207 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1223 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1228 = mem[_1223]
            _1231 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1231] = address(ext_call.return_data[0])
            mem[_1231 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1231 + 64] = _609 + ceil32(return_data.size)
            mem[_1231 + 96] = uint8(_1211)
            mem[_1231 + 128] = 0
            mem[_1231 + 160] = _1228
            mem[_1231 + 192] = 0
            mem[_1231 + 224] = 0
            _1237 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1237] = 0
            mem[_1237 + 32] = 96
            mem[_1237 + 64] = 96
            mem[_1237 + 96] = 0
            mem[_1237 + 128] = 0
            mem[_1237 + 160] = 0
            mem[_1237 + 192] = 0
            mem[_1237 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1247 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1251 = mem[_1247]
            require mem[_1247] == mem[_1247 + 12 len 20]
            _1257 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1257] = 0
            mem[_1257 + 32] = 96
            mem[_1257 + 64] = 96
            mem[_1257 + 96] = 0
            mem[_1257 + 128] = 0
            mem[_1257 + 160] = 0
            mem[_1257 + 192] = 0
            mem[_1257 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1251))
            staticcall address(_1251).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1267 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1271 = mem[_1267]
            require mem[_1267] <= test266151307()
            require _1267 + mem[_1267] + 31 < _1267 + return_data.size
            _1275 = mem[_1267 + mem[_1267]]
            require mem[_1267 + mem[_1267]] <= test266151307()
            require ceil32(mem[_1267 + mem[_1267]]) + 32 >= 0 and _1267 + ceil32(return_data.size) + ceil32(mem[_1267 + mem[_1267]]) + 32 <= test266151307()
            mem[64] = _1267 + ceil32(return_data.size) + ceil32(mem[_1267 + mem[_1267]]) + 32
            mem[_1267 + ceil32(return_data.size)] = _1275
            require _1271 + _1275 + 32 <= return_data.size
            mem[_1267 + ceil32(return_data.size) + 32 len ceil32(_1275)] = mem[_1267 + _1271 + 32 len ceil32(_1275)]
            if ceil32(_1275) <= _1275:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1251))
                staticcall address(_1251).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1794 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1802 = mem[_1794]
                require mem[_1794] <= test266151307()
                require _1794 + mem[_1794] + 31 < _1794 + return_data.size
                _1810 = mem[_1794 + mem[_1794]]
                require mem[_1794 + mem[_1794]] <= test266151307()
                require ceil32(mem[_1794 + mem[_1794]]) + 32 >= 0 and _1794 + ceil32(return_data.size) + ceil32(mem[_1794 + mem[_1794]]) + 32 <= test266151307()
                mem[64] = _1794 + ceil32(return_data.size) + ceil32(mem[_1794 + mem[_1794]]) + 32
                mem[_1794 + ceil32(return_data.size)] = _1810
                require _1802 + _1810 + 32 <= return_data.size
                mem[_1794 + ceil32(return_data.size) + 32 len ceil32(_1810)] = mem[_1794 + _1802 + 32 len ceil32(_1810)]
                if ceil32(_1810) <= _1810:
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2323 = mem[_2307]
                    require mem[_2307] == mem[_2307 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2371 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2387 = mem[_2371]
                    _2397 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2397] = address(_1251)
                    mem[_2397 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2397 + 64] = _1794 + ceil32(return_data.size)
                    mem[_2397 + 96] = uint8(_2323)
                    mem[_2397 + 128] = 0
                    mem[_2397 + 160] = _2387
                    mem[_2397 + 192] = 0
                    mem[_2397 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2451 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2467 = mem[_2451]
                    require mem[_2451] == mem[_2451 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2467))
                    staticcall address(_2467).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2515 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2515]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2579 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2595 = mem[_2579]
                    require mem[_2579] == mem[_2579 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2595))
                    staticcall address(_2595).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2643 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2397 + 128] = mem[_2643]
                    _2669 = mem[64]
                    mem[mem[64]] = 2
                    _3301 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3301] = 0
                    mem[_3301 + 32] = 96
                    mem[_3301 + 64] = 96
                    mem[_3301 + 96] = 0
                    mem[_3301 + 128] = 0
                    mem[_3301 + 160] = 0
                    mem[_3301 + 192] = 0
                    mem[_3301 + 224] = 0
                    mem[var172001] = _3301
                    s = var172001
                    idx = var172002
                    while idx - 1:
                        _3301 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3301] = 0
                        mem[_3301 + 32] = 96
                        mem[_3301 + 64] = 96
                        mem[_3301 + 96] = 0
                        mem[_3301 + 128] = 0
                        mem[_3301 + 160] = 0
                        mem[_3301 + 192] = 0
                        mem[_3301 + 224] = 0
                        mem[s + 32] = _3301
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2669]
                    mem[_2669 + 32] = _1231
                    require 1 < mem[_2669]
                    mem[_2669 + 64] = _2397
                    _3349 = mem[64]
                    mem[mem[64]] = 32
                    _3365 = mem[_2669]
                    mem[mem[64] + 32] = mem[_2669]
                    idx = 0
                    s = _2669 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3365) + 64
                    while idx < _3365:
                        mem[t] = u + -_3349 - 64
                        _3893 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3919 = mem[_3893 + 32]
                        mem[u + 32] = 256
                        _3957 = mem[_3919]
                        mem[u + 256] = mem[_3919]
                        v = 0
                        while v < _3957:
                            mem[v + u + 288] = mem[v + _3919 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3957) <= _3957:
                            _4421 = mem[_3893 + 64]
                            mem[u + 64] = ceil32(_3957) + 288
                            _4441 = mem[_4421]
                            mem[ceil32(_3957) + u + 288] = mem[_4421]
                            v = 0
                            while v < _4441:
                                mem[v + ceil32(_3957) + u + 320] = mem[v + _4421 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4441) > _4441:
                                mem[ceil32(_3957) + u + _4441 + 320] = 0
                            mem[u + 96] = mem[_3893 + 96]
                            mem[u + 128] = mem[_3893 + 128]
                            mem[u + 160] = mem[_3893 + 160]
                            mem[u + 192] = mem[_3893 + 192]
                            mem[u + 224] = mem[_3893 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4441) + ceil32(_3957) + u + 320
                            continue 
                        mem[u + _3957 + 288] = 0
                        _4442 = mem[_3893 + 64]
                        mem[u + 64] = ceil32(_3957) + 288
                        _4469 = mem[_4442]
                        mem[ceil32(_3957) + u + 288] = mem[_4442]
                        v = 0
                        while v < _4469:
                            mem[v + ceil32(_3957) + u + 320] = mem[v + _4442 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4469) > _4469:
                            mem[ceil32(_3957) + u + _4469 + 320] = 0
                        mem[u + 96] = mem[_3893 + 96]
                        mem[u + 128] = mem[_3893 + 128]
                        mem[u + 160] = mem[_3893 + 160]
                        mem[u + 192] = mem[_3893 + 192]
                        mem[u + 224] = mem[_3893 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4469) + ceil32(_3957) + u + 320
                        continue 
                else:
                    mem[_1794 + ceil32(return_data.size) + _1810 + 32] = 0
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2315 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2331 = mem[_2315]
                    require mem[_2315] == mem[_2315 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2379 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2398 = mem[_2379]
                    _2417 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2417] = address(_1251)
                    mem[_2417 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2417 + 64] = _1794 + ceil32(return_data.size)
                    mem[_2417 + 96] = uint8(_2331)
                    mem[_2417 + 128] = 0
                    mem[_2417 + 160] = _2398
                    mem[_2417 + 192] = 0
                    mem[_2417 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2459 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2475 = mem[_2459]
                    require mem[_2459] == mem[_2459 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2475))
                    staticcall address(_2475).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2523 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2523]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2587 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2603 = mem[_2587]
                    require mem[_2587] == mem[_2587 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2603))
                    staticcall address(_2603).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2651 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2417 + 128] = mem[_2651]
                    _2683 = mem[64]
                    mem[mem[64]] = 2
                    _3302 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3302] = 0
                    mem[_3302 + 32] = 96
                    mem[_3302 + 64] = 96
                    mem[_3302 + 96] = 0
                    mem[_3302 + 128] = 0
                    mem[_3302 + 160] = 0
                    mem[_3302 + 192] = 0
                    mem[_3302 + 224] = 0
                    mem[var173001] = _3302
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3302 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3302] = 0
                        mem[_3302 + 32] = 96
                        mem[_3302 + 64] = 96
                        mem[_3302 + 96] = 0
                        mem[_3302 + 128] = 0
                        mem[_3302 + 160] = 0
                        mem[_3302 + 192] = 0
                        mem[_3302 + 224] = 0
                        mem[s + 32] = _3302
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2683]
                    mem[_2683 + 32] = _1231
                    require 1 < mem[_2683]
                    mem[_2683 + 64] = _2417
                    _3350 = mem[64]
                    mem[mem[64]] = 32
                    _3366 = mem[_2683]
                    mem[mem[64] + 32] = mem[_2683]
                    idx = 0
                    s = _2683 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3366) + 64
                    while idx < _3366:
                        mem[t] = u + -_3350 - 64
                        _3894 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3922 = mem[_3894 + 32]
                        mem[u + 32] = 256
                        _3958 = mem[_3922]
                        mem[u + 256] = mem[_3922]
                        v = 0
                        while v < _3958:
                            mem[v + u + 288] = mem[v + _3922 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3958) <= _3958:
                            _4422 = mem[_3894 + 64]
                            mem[u + 64] = ceil32(_3958) + 288
                            _4443 = mem[_4422]
                            mem[ceil32(_3958) + u + 288] = mem[_4422]
                            v = 0
                            while v < _4443:
                                mem[v + ceil32(_3958) + u + 320] = mem[v + _4422 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4443) > _4443:
                                mem[ceil32(_3958) + u + _4443 + 320] = 0
                            mem[u + 96] = mem[_3894 + 96]
                            mem[u + 128] = mem[_3894 + 128]
                            mem[u + 160] = mem[_3894 + 160]
                            mem[u + 192] = mem[_3894 + 192]
                            mem[u + 224] = mem[_3894 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4443) + ceil32(_3958) + u + 320
                            continue 
                        mem[u + _3958 + 288] = 0
                        _4444 = mem[_3894 + 64]
                        mem[u + 64] = ceil32(_3958) + 288
                        _4470 = mem[_4444]
                        mem[ceil32(_3958) + u + 288] = mem[_4444]
                        v = 0
                        while v < _4470:
                            mem[v + ceil32(_3958) + u + 320] = mem[v + _4444 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4470) > _4470:
                            mem[ceil32(_3958) + u + _4470 + 320] = 0
                        mem[u + 96] = mem[_3894 + 96]
                        mem[u + 128] = mem[_3894 + 128]
                        mem[u + 160] = mem[_3894 + 160]
                        mem[u + 192] = mem[_3894 + 192]
                        mem[u + 224] = mem[_3894 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4470) + ceil32(_3958) + u + 320
                        continue 
            else:
                mem[_1267 + ceil32(return_data.size) + _1275 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1251))
                staticcall address(_1251).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1798 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1806 = mem[_1798]
                require mem[_1798] <= test266151307()
                require _1798 + mem[_1798] + 31 < _1798 + return_data.size
                _1814 = mem[_1798 + mem[_1798]]
                require mem[_1798 + mem[_1798]] <= test266151307()
                require ceil32(mem[_1798 + mem[_1798]]) + 32 >= 0 and _1798 + ceil32(return_data.size) + ceil32(mem[_1798 + mem[_1798]]) + 32 <= test266151307()
                mem[64] = _1798 + ceil32(return_data.size) + ceil32(mem[_1798 + mem[_1798]]) + 32
                mem[_1798 + ceil32(return_data.size)] = _1814
                require _1806 + _1814 + 32 <= return_data.size
                mem[_1798 + ceil32(return_data.size) + 32 len ceil32(_1814)] = mem[_1798 + _1806 + 32 len ceil32(_1814)]
                if ceil32(_1814) <= _1814:
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2308 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2324 = mem[_2308]
                    require mem[_2308] == mem[_2308 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2372 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2388 = mem[_2372]
                    _2399 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2399] = address(_1251)
                    mem[_2399 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2399 + 64] = _1798 + ceil32(return_data.size)
                    mem[_2399 + 96] = uint8(_2324)
                    mem[_2399 + 128] = 0
                    mem[_2399 + 160] = _2388
                    mem[_2399 + 192] = 0
                    mem[_2399 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2452 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2468 = mem[_2452]
                    require mem[_2452] == mem[_2452 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2468))
                    staticcall address(_2468).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2516 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2516]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2580 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2596 = mem[_2580]
                    require mem[_2580] == mem[_2580 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2596))
                    staticcall address(_2596).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2644 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2399 + 128] = mem[_2644]
                    _2671 = mem[64]
                    mem[mem[64]] = 2
                    _3303 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3303] = 0
                    mem[_3303 + 32] = 96
                    mem[_3303 + 64] = 96
                    mem[_3303 + 96] = 0
                    mem[_3303 + 128] = 0
                    mem[_3303 + 160] = 0
                    mem[_3303 + 192] = 0
                    mem[_3303 + 224] = 0
                    mem[var173001] = _3303
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3303 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3303] = 0
                        mem[_3303 + 32] = 96
                        mem[_3303 + 64] = 96
                        mem[_3303 + 96] = 0
                        mem[_3303 + 128] = 0
                        mem[_3303 + 160] = 0
                        mem[_3303 + 192] = 0
                        mem[_3303 + 224] = 0
                        mem[s + 32] = _3303
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2671]
                    mem[_2671 + 32] = _1231
                    require 1 < mem[_2671]
                    mem[_2671 + 64] = _2399
                    _3351 = mem[64]
                    mem[mem[64]] = 32
                    _3367 = mem[_2671]
                    mem[mem[64] + 32] = mem[_2671]
                    idx = 0
                    s = _2671 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3367) + 64
                    while idx < _3367:
                        mem[t] = u + -_3351 - 64
                        _3895 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3925 = mem[_3895 + 32]
                        mem[u + 32] = 256
                        _3959 = mem[_3925]
                        mem[u + 256] = mem[_3925]
                        v = 0
                        while v < _3959:
                            mem[v + u + 288] = mem[v + _3925 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3959) <= _3959:
                            _4423 = mem[_3895 + 64]
                            mem[u + 64] = ceil32(_3959) + 288
                            _4445 = mem[_4423]
                            mem[ceil32(_3959) + u + 288] = mem[_4423]
                            v = 0
                            while v < _4445:
                                mem[v + ceil32(_3959) + u + 320] = mem[v + _4423 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4445) > _4445:
                                mem[ceil32(_3959) + u + _4445 + 320] = 0
                            mem[u + 96] = mem[_3895 + 96]
                            mem[u + 128] = mem[_3895 + 128]
                            mem[u + 160] = mem[_3895 + 160]
                            mem[u + 192] = mem[_3895 + 192]
                            mem[u + 224] = mem[_3895 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4445) + ceil32(_3959) + u + 320
                            continue 
                        mem[u + _3959 + 288] = 0
                        _4446 = mem[_3895 + 64]
                        mem[u + 64] = ceil32(_3959) + 288
                        _4471 = mem[_4446]
                        mem[ceil32(_3959) + u + 288] = mem[_4446]
                        v = 0
                        while v < _4471:
                            mem[v + ceil32(_3959) + u + 320] = mem[v + _4446 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4471) > _4471:
                            mem[ceil32(_3959) + u + _4471 + 320] = 0
                        mem[u + 96] = mem[_3895 + 96]
                        mem[u + 128] = mem[_3895 + 128]
                        mem[u + 160] = mem[_3895 + 160]
                        mem[u + 192] = mem[_3895 + 192]
                        mem[u + 224] = mem[_3895 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4471) + ceil32(_3959) + u + 320
                        continue 
                else:
                    mem[_1798 + ceil32(return_data.size) + _1814 + 32] = 0
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2316 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2332 = mem[_2316]
                    require mem[_2316] == mem[_2316 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2380 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2400 = mem[_2380]
                    _2420 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2420] = address(_1251)
                    mem[_2420 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2420 + 64] = _1798 + ceil32(return_data.size)
                    mem[_2420 + 96] = uint8(_2332)
                    mem[_2420 + 128] = 0
                    mem[_2420 + 160] = _2400
                    mem[_2420 + 192] = 0
                    mem[_2420 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2460 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2476 = mem[_2460]
                    require mem[_2460] == mem[_2460 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2476))
                    staticcall address(_2476).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2524 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2524]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2588 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2604 = mem[_2588]
                    require mem[_2588] == mem[_2588 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2604))
                    staticcall address(_2604).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2420 + 128] = mem[_2652]
                    _2684 = mem[64]
                    mem[mem[64]] = 2
                    _3304 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3304] = 0
                    mem[_3304 + 32] = 96
                    mem[_3304 + 64] = 96
                    mem[_3304 + 96] = 0
                    mem[_3304 + 128] = 0
                    mem[_3304 + 160] = 0
                    mem[_3304 + 192] = 0
                    mem[_3304 + 224] = 0
                    mem[var174001] = _3304
                    s = var174001
                    idx = var174002
                    while idx - 1:
                        _3304 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3304] = 0
                        mem[_3304 + 32] = 96
                        mem[_3304 + 64] = 96
                        mem[_3304 + 96] = 0
                        mem[_3304 + 128] = 0
                        mem[_3304 + 160] = 0
                        mem[_3304 + 192] = 0
                        mem[_3304 + 224] = 0
                        mem[s + 32] = _3304
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2684]
                    mem[_2684 + 32] = _1231
                    require 1 < mem[_2684]
                    mem[_2684 + 64] = _2420
                    _3352 = mem[64]
                    mem[mem[64]] = 32
                    _3368 = mem[_2684]
                    mem[mem[64] + 32] = mem[_2684]
                    idx = 0
                    s = _2684 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3368) + 64
                    while idx < _3368:
                        mem[t] = u + -_3352 - 64
                        _3896 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3928 = mem[_3896 + 32]
                        mem[u + 32] = 256
                        _3960 = mem[_3928]
                        mem[u + 256] = mem[_3928]
                        v = 0
                        while v < _3960:
                            mem[v + u + 288] = mem[v + _3928 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3960) <= _3960:
                            _4424 = mem[_3896 + 64]
                            mem[u + 64] = ceil32(_3960) + 288
                            _4447 = mem[_4424]
                            mem[ceil32(_3960) + u + 288] = mem[_4424]
                            v = 0
                            while v < _4447:
                                mem[v + ceil32(_3960) + u + 320] = mem[v + _4424 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4447) > _4447:
                                mem[ceil32(_3960) + u + _4447 + 320] = 0
                            mem[u + 96] = mem[_3896 + 96]
                            mem[u + 128] = mem[_3896 + 128]
                            mem[u + 160] = mem[_3896 + 160]
                            mem[u + 192] = mem[_3896 + 192]
                            mem[u + 224] = mem[_3896 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4447) + ceil32(_3960) + u + 320
                            continue 
                        mem[u + _3960 + 288] = 0
                        _4448 = mem[_3896 + 64]
                        mem[u + 64] = ceil32(_3960) + 288
                        _4472 = mem[_4448]
                        mem[ceil32(_3960) + u + 288] = mem[_4448]
                        v = 0
                        while v < _4472:
                            mem[v + ceil32(_3960) + u + 320] = mem[v + _4448 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4472) > _4472:
                            mem[ceil32(_3960) + u + _4472 + 320] = 0
                        mem[u + 96] = mem[_3896 + 96]
                        mem[u + 128] = mem[_3896 + 128]
                        mem[u + 160] = mem[_3896 + 160]
                        mem[u + 192] = mem[_3896 + 192]
                        mem[u + 224] = mem[_3896 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4472) + ceil32(_3960) + u + 320
                        continue 
    else:
        mem[(2 * ceil32(return_data.size)) + _11 + 640] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _610 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _612 = mem[_610]
        require mem[_610] <= test266151307()
        require _610 + mem[_610] + 31 < _610 + return_data.size
        _614 = mem[_610 + mem[_610]]
        require mem[_610 + mem[_610]] <= test266151307()
        require ceil32(mem[_610 + mem[_610]]) + 32 >= 0 and _610 + ceil32(return_data.size) + ceil32(mem[_610 + mem[_610]]) + 32 <= test266151307()
        mem[64] = _610 + ceil32(return_data.size) + ceil32(mem[_610 + mem[_610]]) + 32
        mem[_610 + ceil32(return_data.size)] = _614
        require _612 + _614 + 32 <= return_data.size
        mem[_610 + ceil32(return_data.size) + 32 len ceil32(_614)] = mem[_610 + _612 + 32 len ceil32(_614)]
        if ceil32(_614) <= _614:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1206 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1210 = mem[_1206]
            require mem[_1206] == mem[_1206 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1222 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1226 = mem[_1222]
            _1229 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1229] = address(ext_call.return_data[0])
            mem[_1229 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1229 + 64] = _610 + ceil32(return_data.size)
            mem[_1229 + 96] = uint8(_1210)
            mem[_1229 + 128] = 0
            mem[_1229 + 160] = _1226
            mem[_1229 + 192] = 0
            mem[_1229 + 224] = 0
            _1234 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1234] = 0
            mem[_1234 + 32] = 96
            mem[_1234 + 64] = 96
            mem[_1234 + 96] = 0
            mem[_1234 + 128] = 0
            mem[_1234 + 160] = 0
            mem[_1234 + 192] = 0
            mem[_1234 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1246 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1250 = mem[_1246]
            require mem[_1246] == mem[_1246 + 12 len 20]
            _1254 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1254] = 0
            mem[_1254 + 32] = 96
            mem[_1254 + 64] = 96
            mem[_1254 + 96] = 0
            mem[_1254 + 128] = 0
            mem[_1254 + 160] = 0
            mem[_1254 + 192] = 0
            mem[_1254 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1250))
            staticcall address(_1250).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1266 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1270 = mem[_1266]
            require mem[_1266] <= test266151307()
            require _1266 + mem[_1266] + 31 < _1266 + return_data.size
            _1274 = mem[_1266 + mem[_1266]]
            require mem[_1266 + mem[_1266]] <= test266151307()
            require ceil32(mem[_1266 + mem[_1266]]) + 32 >= 0 and _1266 + ceil32(return_data.size) + ceil32(mem[_1266 + mem[_1266]]) + 32 <= test266151307()
            mem[64] = _1266 + ceil32(return_data.size) + ceil32(mem[_1266 + mem[_1266]]) + 32
            mem[_1266 + ceil32(return_data.size)] = _1274
            require _1270 + _1274 + 32 <= return_data.size
            mem[_1266 + ceil32(return_data.size) + 32 len ceil32(_1274)] = mem[_1266 + _1270 + 32 len ceil32(_1274)]
            if ceil32(_1274) <= _1274:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1250))
                staticcall address(_1250).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1795 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1803 = mem[_1795]
                require mem[_1795] <= test266151307()
                require _1795 + mem[_1795] + 31 < _1795 + return_data.size
                _1811 = mem[_1795 + mem[_1795]]
                require mem[_1795 + mem[_1795]] <= test266151307()
                require ceil32(mem[_1795 + mem[_1795]]) + 32 >= 0 and _1795 + ceil32(return_data.size) + ceil32(mem[_1795 + mem[_1795]]) + 32 <= test266151307()
                mem[64] = _1795 + ceil32(return_data.size) + ceil32(mem[_1795 + mem[_1795]]) + 32
                mem[_1795 + ceil32(return_data.size)] = _1811
                require _1803 + _1811 + 32 <= return_data.size
                mem[_1795 + ceil32(return_data.size) + 32 len ceil32(_1811)] = mem[_1795 + _1803 + 32 len ceil32(_1811)]
                if ceil32(_1811) <= _1811:
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2309 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2325 = mem[_2309]
                    require mem[_2309] == mem[_2309 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2373 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2389 = mem[_2373]
                    _2401 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2401] = address(_1250)
                    mem[_2401 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2401 + 64] = _1795 + ceil32(return_data.size)
                    mem[_2401 + 96] = uint8(_2325)
                    mem[_2401 + 128] = 0
                    mem[_2401 + 160] = _2389
                    mem[_2401 + 192] = 0
                    mem[_2401 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2453 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2469 = mem[_2453]
                    require mem[_2453] == mem[_2453 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2469))
                    staticcall address(_2469).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2517 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2517]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2581 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2597 = mem[_2581]
                    require mem[_2581] == mem[_2581 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2597))
                    staticcall address(_2597).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2645 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2401 + 128] = mem[_2645]
                    _2673 = mem[64]
                    mem[mem[64]] = 2
                    _3305 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3305] = 0
                    mem[_3305 + 32] = 96
                    mem[_3305 + 64] = 96
                    mem[_3305 + 96] = 0
                    mem[_3305 + 128] = 0
                    mem[_3305 + 160] = 0
                    mem[_3305 + 192] = 0
                    mem[_3305 + 224] = 0
                    mem[var172001] = _3305
                    s = var172001
                    idx = var172002
                    while idx - 1:
                        _3305 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3305] = 0
                        mem[_3305 + 32] = 96
                        mem[_3305 + 64] = 96
                        mem[_3305 + 96] = 0
                        mem[_3305 + 128] = 0
                        mem[_3305 + 160] = 0
                        mem[_3305 + 192] = 0
                        mem[_3305 + 224] = 0
                        mem[s + 32] = _3305
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2673]
                    mem[_2673 + 32] = _1229
                    require 1 < mem[_2673]
                    mem[_2673 + 64] = _2401
                    _3353 = mem[64]
                    mem[mem[64]] = 32
                    _3369 = mem[_2673]
                    mem[mem[64] + 32] = mem[_2673]
                    idx = 0
                    s = _2673 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3369) + 64
                    while idx < _3369:
                        mem[t] = u + -_3353 - 64
                        _3897 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3931 = mem[_3897 + 32]
                        mem[u + 32] = 256
                        _3961 = mem[_3931]
                        mem[u + 256] = mem[_3931]
                        v = 0
                        while v < _3961:
                            mem[v + u + 288] = mem[v + _3931 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3961) <= _3961:
                            _4425 = mem[_3897 + 64]
                            mem[u + 64] = ceil32(_3961) + 288
                            _4449 = mem[_4425]
                            mem[ceil32(_3961) + u + 288] = mem[_4425]
                            v = 0
                            while v < _4449:
                                mem[v + ceil32(_3961) + u + 320] = mem[v + _4425 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4449) > _4449:
                                mem[ceil32(_3961) + u + _4449 + 320] = 0
                            mem[u + 96] = mem[_3897 + 96]
                            mem[u + 128] = mem[_3897 + 128]
                            mem[u + 160] = mem[_3897 + 160]
                            mem[u + 192] = mem[_3897 + 192]
                            mem[u + 224] = mem[_3897 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4449) + ceil32(_3961) + u + 320
                            continue 
                        mem[u + _3961 + 288] = 0
                        _4450 = mem[_3897 + 64]
                        mem[u + 64] = ceil32(_3961) + 288
                        _4473 = mem[_4450]
                        mem[ceil32(_3961) + u + 288] = mem[_4450]
                        v = 0
                        while v < _4473:
                            mem[v + ceil32(_3961) + u + 320] = mem[v + _4450 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4473) > _4473:
                            mem[ceil32(_3961) + u + _4473 + 320] = 0
                        mem[u + 96] = mem[_3897 + 96]
                        mem[u + 128] = mem[_3897 + 128]
                        mem[u + 160] = mem[_3897 + 160]
                        mem[u + 192] = mem[_3897 + 192]
                        mem[u + 224] = mem[_3897 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4473) + ceil32(_3961) + u + 320
                        continue 
                else:
                    mem[_1795 + ceil32(return_data.size) + _1811 + 32] = 0
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2317 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2333 = mem[_2317]
                    require mem[_2317] == mem[_2317 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2381 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2402 = mem[_2381]
                    _2423 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2423] = address(_1250)
                    mem[_2423 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2423 + 64] = _1795 + ceil32(return_data.size)
                    mem[_2423 + 96] = uint8(_2333)
                    mem[_2423 + 128] = 0
                    mem[_2423 + 160] = _2402
                    mem[_2423 + 192] = 0
                    mem[_2423 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2461 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2477 = mem[_2461]
                    require mem[_2461] == mem[_2461 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2477))
                    staticcall address(_2477).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2525 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2525]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2589 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2605 = mem[_2589]
                    require mem[_2589] == mem[_2589 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2605))
                    staticcall address(_2605).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2653 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2423 + 128] = mem[_2653]
                    _2685 = mem[64]
                    mem[mem[64]] = 2
                    _3306 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3306] = 0
                    mem[_3306 + 32] = 96
                    mem[_3306 + 64] = 96
                    mem[_3306 + 96] = 0
                    mem[_3306 + 128] = 0
                    mem[_3306 + 160] = 0
                    mem[_3306 + 192] = 0
                    mem[_3306 + 224] = 0
                    mem[var173001] = _3306
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3306 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3306] = 0
                        mem[_3306 + 32] = 96
                        mem[_3306 + 64] = 96
                        mem[_3306 + 96] = 0
                        mem[_3306 + 128] = 0
                        mem[_3306 + 160] = 0
                        mem[_3306 + 192] = 0
                        mem[_3306 + 224] = 0
                        mem[s + 32] = _3306
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2685]
                    mem[_2685 + 32] = _1229
                    require 1 < mem[_2685]
                    mem[_2685 + 64] = _2423
                    _3354 = mem[64]
                    mem[mem[64]] = 32
                    _3370 = mem[_2685]
                    mem[mem[64] + 32] = mem[_2685]
                    idx = 0
                    s = _2685 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3370) + 64
                    while idx < _3370:
                        mem[t] = u + -_3354 - 64
                        _3898 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3934 = mem[_3898 + 32]
                        mem[u + 32] = 256
                        _3962 = mem[_3934]
                        mem[u + 256] = mem[_3934]
                        v = 0
                        while v < _3962:
                            mem[v + u + 288] = mem[v + _3934 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3962) <= _3962:
                            _4426 = mem[_3898 + 64]
                            mem[u + 64] = ceil32(_3962) + 288
                            _4451 = mem[_4426]
                            mem[ceil32(_3962) + u + 288] = mem[_4426]
                            v = 0
                            while v < _4451:
                                mem[v + ceil32(_3962) + u + 320] = mem[v + _4426 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4451) > _4451:
                                mem[ceil32(_3962) + u + _4451 + 320] = 0
                            mem[u + 96] = mem[_3898 + 96]
                            mem[u + 128] = mem[_3898 + 128]
                            mem[u + 160] = mem[_3898 + 160]
                            mem[u + 192] = mem[_3898 + 192]
                            mem[u + 224] = mem[_3898 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4451) + ceil32(_3962) + u + 320
                            continue 
                        mem[u + _3962 + 288] = 0
                        _4452 = mem[_3898 + 64]
                        mem[u + 64] = ceil32(_3962) + 288
                        _4474 = mem[_4452]
                        mem[ceil32(_3962) + u + 288] = mem[_4452]
                        v = 0
                        while v < _4474:
                            mem[v + ceil32(_3962) + u + 320] = mem[v + _4452 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4474) > _4474:
                            mem[ceil32(_3962) + u + _4474 + 320] = 0
                        mem[u + 96] = mem[_3898 + 96]
                        mem[u + 128] = mem[_3898 + 128]
                        mem[u + 160] = mem[_3898 + 160]
                        mem[u + 192] = mem[_3898 + 192]
                        mem[u + 224] = mem[_3898 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4474) + ceil32(_3962) + u + 320
                        continue 
            else:
                mem[_1266 + ceil32(return_data.size) + _1274 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1250))
                staticcall address(_1250).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1799 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1807 = mem[_1799]
                require mem[_1799] <= test266151307()
                require _1799 + mem[_1799] + 31 < _1799 + return_data.size
                _1815 = mem[_1799 + mem[_1799]]
                require mem[_1799 + mem[_1799]] <= test266151307()
                require ceil32(mem[_1799 + mem[_1799]]) + 32 >= 0 and _1799 + ceil32(return_data.size) + ceil32(mem[_1799 + mem[_1799]]) + 32 <= test266151307()
                mem[64] = _1799 + ceil32(return_data.size) + ceil32(mem[_1799 + mem[_1799]]) + 32
                mem[_1799 + ceil32(return_data.size)] = _1815
                require _1807 + _1815 + 32 <= return_data.size
                mem[_1799 + ceil32(return_data.size) + 32 len ceil32(_1815)] = mem[_1799 + _1807 + 32 len ceil32(_1815)]
                if ceil32(_1815) <= _1815:
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2310 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2326 = mem[_2310]
                    require mem[_2310] == mem[_2310 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2374 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2390 = mem[_2374]
                    _2403 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2403] = address(_1250)
                    mem[_2403 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2403 + 64] = _1799 + ceil32(return_data.size)
                    mem[_2403 + 96] = uint8(_2326)
                    mem[_2403 + 128] = 0
                    mem[_2403 + 160] = _2390
                    mem[_2403 + 192] = 0
                    mem[_2403 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2454 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2470 = mem[_2454]
                    require mem[_2454] == mem[_2454 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2470))
                    staticcall address(_2470).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2518 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2518]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2582 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2598 = mem[_2582]
                    require mem[_2582] == mem[_2582 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2598))
                    staticcall address(_2598).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2646 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2403 + 128] = mem[_2646]
                    _2675 = mem[64]
                    mem[mem[64]] = 2
                    _3307 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3307] = 0
                    mem[_3307 + 32] = 96
                    mem[_3307 + 64] = 96
                    mem[_3307 + 96] = 0
                    mem[_3307 + 128] = 0
                    mem[_3307 + 160] = 0
                    mem[_3307 + 192] = 0
                    mem[_3307 + 224] = 0
                    mem[var173001] = _3307
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3307 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3307] = 0
                        mem[_3307 + 32] = 96
                        mem[_3307 + 64] = 96
                        mem[_3307 + 96] = 0
                        mem[_3307 + 128] = 0
                        mem[_3307 + 160] = 0
                        mem[_3307 + 192] = 0
                        mem[_3307 + 224] = 0
                        mem[s + 32] = _3307
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2675]
                    mem[_2675 + 32] = _1229
                    require 1 < mem[_2675]
                    mem[_2675 + 64] = _2403
                    _3355 = mem[64]
                    mem[mem[64]] = 32
                    _3371 = mem[_2675]
                    mem[mem[64] + 32] = mem[_2675]
                    idx = 0
                    s = _2675 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3371) + 64
                    while idx < _3371:
                        mem[t] = u + -_3355 - 64
                        _3899 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3937 = mem[_3899 + 32]
                        mem[u + 32] = 256
                        _3963 = mem[_3937]
                        mem[u + 256] = mem[_3937]
                        v = 0
                        while v < _3963:
                            mem[v + u + 288] = mem[v + _3937 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3963) <= _3963:
                            _4427 = mem[_3899 + 64]
                            mem[u + 64] = ceil32(_3963) + 288
                            _4453 = mem[_4427]
                            mem[ceil32(_3963) + u + 288] = mem[_4427]
                            v = 0
                            while v < _4453:
                                mem[v + ceil32(_3963) + u + 320] = mem[v + _4427 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4453) > _4453:
                                mem[ceil32(_3963) + u + _4453 + 320] = 0
                            mem[u + 96] = mem[_3899 + 96]
                            mem[u + 128] = mem[_3899 + 128]
                            mem[u + 160] = mem[_3899 + 160]
                            mem[u + 192] = mem[_3899 + 192]
                            mem[u + 224] = mem[_3899 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4453) + ceil32(_3963) + u + 320
                            continue 
                        mem[u + _3963 + 288] = 0
                        _4454 = mem[_3899 + 64]
                        mem[u + 64] = ceil32(_3963) + 288
                        _4475 = mem[_4454]
                        mem[ceil32(_3963) + u + 288] = mem[_4454]
                        v = 0
                        while v < _4475:
                            mem[v + ceil32(_3963) + u + 320] = mem[v + _4454 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4475) > _4475:
                            mem[ceil32(_3963) + u + _4475 + 320] = 0
                        mem[u + 96] = mem[_3899 + 96]
                        mem[u + 128] = mem[_3899 + 128]
                        mem[u + 160] = mem[_3899 + 160]
                        mem[u + 192] = mem[_3899 + 192]
                        mem[u + 224] = mem[_3899 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4475) + ceil32(_3963) + u + 320
                        continue 
                else:
                    mem[_1799 + ceil32(return_data.size) + _1815 + 32] = 0
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2318 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2334 = mem[_2318]
                    require mem[_2318] == mem[_2318 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2382 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2404 = mem[_2382]
                    _2426 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2426] = address(_1250)
                    mem[_2426 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2426 + 64] = _1799 + ceil32(return_data.size)
                    mem[_2426 + 96] = uint8(_2334)
                    mem[_2426 + 128] = 0
                    mem[_2426 + 160] = _2404
                    mem[_2426 + 192] = 0
                    mem[_2426 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2462 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2478 = mem[_2462]
                    require mem[_2462] == mem[_2462 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2478))
                    staticcall address(_2478).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2526 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2526]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2590 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2606 = mem[_2590]
                    require mem[_2590] == mem[_2590 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2606))
                    staticcall address(_2606).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2654 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2426 + 128] = mem[_2654]
                    _2686 = mem[64]
                    mem[mem[64]] = 2
                    _3308 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3308] = 0
                    mem[_3308 + 32] = 96
                    mem[_3308 + 64] = 96
                    mem[_3308 + 96] = 0
                    mem[_3308 + 128] = 0
                    mem[_3308 + 160] = 0
                    mem[_3308 + 192] = 0
                    mem[_3308 + 224] = 0
                    mem[var174001] = _3308
                    s = var174001
                    idx = var174002
                    while idx - 1:
                        _3308 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3308] = 0
                        mem[_3308 + 32] = 96
                        mem[_3308 + 64] = 96
                        mem[_3308 + 96] = 0
                        mem[_3308 + 128] = 0
                        mem[_3308 + 160] = 0
                        mem[_3308 + 192] = 0
                        mem[_3308 + 224] = 0
                        mem[s + 32] = _3308
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2686]
                    mem[_2686 + 32] = _1229
                    require 1 < mem[_2686]
                    mem[_2686 + 64] = _2426
                    _3356 = mem[64]
                    mem[mem[64]] = 32
                    _3372 = mem[_2686]
                    mem[mem[64] + 32] = mem[_2686]
                    idx = 0
                    s = _2686 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3372) + 64
                    while idx < _3372:
                        mem[t] = u + -_3356 - 64
                        _3900 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3940 = mem[_3900 + 32]
                        mem[u + 32] = 256
                        _3964 = mem[_3940]
                        mem[u + 256] = mem[_3940]
                        v = 0
                        while v < _3964:
                            mem[v + u + 288] = mem[v + _3940 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3964) <= _3964:
                            _4428 = mem[_3900 + 64]
                            mem[u + 64] = ceil32(_3964) + 288
                            _4455 = mem[_4428]
                            mem[ceil32(_3964) + u + 288] = mem[_4428]
                            v = 0
                            while v < _4455:
                                mem[v + ceil32(_3964) + u + 320] = mem[v + _4428 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4455) > _4455:
                                mem[ceil32(_3964) + u + _4455 + 320] = 0
                            mem[u + 96] = mem[_3900 + 96]
                            mem[u + 128] = mem[_3900 + 128]
                            mem[u + 160] = mem[_3900 + 160]
                            mem[u + 192] = mem[_3900 + 192]
                            mem[u + 224] = mem[_3900 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4455) + ceil32(_3964) + u + 320
                            continue 
                        mem[u + _3964 + 288] = 0
                        _4456 = mem[_3900 + 64]
                        mem[u + 64] = ceil32(_3964) + 288
                        _4476 = mem[_4456]
                        mem[ceil32(_3964) + u + 288] = mem[_4456]
                        v = 0
                        while v < _4476:
                            mem[v + ceil32(_3964) + u + 320] = mem[v + _4456 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4476) > _4476:
                            mem[ceil32(_3964) + u + _4476 + 320] = 0
                        mem[u + 96] = mem[_3900 + 96]
                        mem[u + 128] = mem[_3900 + 128]
                        mem[u + 160] = mem[_3900 + 160]
                        mem[u + 192] = mem[_3900 + 192]
                        mem[u + 224] = mem[_3900 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4476) + ceil32(_3964) + u + 320
                        continue 
        else:
            mem[_610 + ceil32(return_data.size) + _614 + 32] = 0
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1208 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1212 = mem[_1208]
            require mem[_1208] == mem[_1208 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1224 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1230 = mem[_1224]
            _1232 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1232] = address(ext_call.return_data[0])
            mem[_1232 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1232 + 64] = _610 + ceil32(return_data.size)
            mem[_1232 + 96] = uint8(_1212)
            mem[_1232 + 128] = 0
            mem[_1232 + 160] = _1230
            mem[_1232 + 192] = 0
            mem[_1232 + 224] = 0
            _1240 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1240] = 0
            mem[_1240 + 32] = 96
            mem[_1240 + 64] = 96
            mem[_1240 + 96] = 0
            mem[_1240 + 128] = 0
            mem[_1240 + 160] = 0
            mem[_1240 + 192] = 0
            mem[_1240 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1252 = mem[_1248]
            require mem[_1248] == mem[_1248 + 12 len 20]
            _1260 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1260] = 0
            mem[_1260 + 32] = 96
            mem[_1260 + 64] = 96
            mem[_1260 + 96] = 0
            mem[_1260 + 128] = 0
            mem[_1260 + 160] = 0
            mem[_1260 + 192] = 0
            mem[_1260 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1252))
            staticcall address(_1252).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1268 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1272 = mem[_1268]
            require mem[_1268] <= test266151307()
            require _1268 + mem[_1268] + 31 < _1268 + return_data.size
            _1276 = mem[_1268 + mem[_1268]]
            require mem[_1268 + mem[_1268]] <= test266151307()
            require ceil32(mem[_1268 + mem[_1268]]) + 32 >= 0 and _1268 + ceil32(return_data.size) + ceil32(mem[_1268 + mem[_1268]]) + 32 <= test266151307()
            mem[64] = _1268 + ceil32(return_data.size) + ceil32(mem[_1268 + mem[_1268]]) + 32
            mem[_1268 + ceil32(return_data.size)] = _1276
            require _1272 + _1276 + 32 <= return_data.size
            mem[_1268 + ceil32(return_data.size) + 32 len ceil32(_1276)] = mem[_1268 + _1272 + 32 len ceil32(_1276)]
            if ceil32(_1276) <= _1276:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1252))
                staticcall address(_1252).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1796 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1804 = mem[_1796]
                require mem[_1796] <= test266151307()
                require _1796 + mem[_1796] + 31 < _1796 + return_data.size
                _1812 = mem[_1796 + mem[_1796]]
                require mem[_1796 + mem[_1796]] <= test266151307()
                require ceil32(mem[_1796 + mem[_1796]]) + 32 >= 0 and _1796 + ceil32(return_data.size) + ceil32(mem[_1796 + mem[_1796]]) + 32 <= test266151307()
                mem[64] = _1796 + ceil32(return_data.size) + ceil32(mem[_1796 + mem[_1796]]) + 32
                mem[_1796 + ceil32(return_data.size)] = _1812
                require _1804 + _1812 + 32 <= return_data.size
                mem[_1796 + ceil32(return_data.size) + 32 len ceil32(_1812)] = mem[_1796 + _1804 + 32 len ceil32(_1812)]
                if ceil32(_1812) <= _1812:
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2311 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2327 = mem[_2311]
                    require mem[_2311] == mem[_2311 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2375 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2391 = mem[_2375]
                    _2405 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2405] = address(_1252)
                    mem[_2405 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2405 + 64] = _1796 + ceil32(return_data.size)
                    mem[_2405 + 96] = uint8(_2327)
                    mem[_2405 + 128] = 0
                    mem[_2405 + 160] = _2391
                    mem[_2405 + 192] = 0
                    mem[_2405 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2455 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2471 = mem[_2455]
                    require mem[_2455] == mem[_2455 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2471))
                    staticcall address(_2471).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2519 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2519]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2583 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2599 = mem[_2583]
                    require mem[_2583] == mem[_2583 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2599))
                    staticcall address(_2599).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2647 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2405 + 128] = mem[_2647]
                    _2677 = mem[64]
                    mem[mem[64]] = 2
                    _3309 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3309] = 0
                    mem[_3309 + 32] = 96
                    mem[_3309 + 64] = 96
                    mem[_3309 + 96] = 0
                    mem[_3309 + 128] = 0
                    mem[_3309 + 160] = 0
                    mem[_3309 + 192] = 0
                    mem[_3309 + 224] = 0
                    mem[var173001] = _3309
                    s = var173001
                    idx = var173002
                    while idx - 1:
                        _3309 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3309] = 0
                        mem[_3309 + 32] = 96
                        mem[_3309 + 64] = 96
                        mem[_3309 + 96] = 0
                        mem[_3309 + 128] = 0
                        mem[_3309 + 160] = 0
                        mem[_3309 + 192] = 0
                        mem[_3309 + 224] = 0
                        mem[s + 32] = _3309
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2677]
                    mem[_2677 + 32] = _1232
                    require 1 < mem[_2677]
                    mem[_2677 + 64] = _2405
                    _3357 = mem[64]
                    mem[mem[64]] = 32
                    _3373 = mem[_2677]
                    mem[mem[64] + 32] = mem[_2677]
                    idx = 0
                    s = _2677 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3373) + 64
                    while idx < _3373:
                        mem[t] = u + -_3357 - 64
                        _3901 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3943 = mem[_3901 + 32]
                        mem[u + 32] = 256
                        _3965 = mem[_3943]
                        mem[u + 256] = mem[_3943]
                        v = 0
                        while v < _3965:
                            mem[v + u + 288] = mem[v + _3943 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3965) <= _3965:
                            _4429 = mem[_3901 + 64]
                            mem[u + 64] = ceil32(_3965) + 288
                            _4457 = mem[_4429]
                            mem[ceil32(_3965) + u + 288] = mem[_4429]
                            v = 0
                            while v < _4457:
                                mem[v + ceil32(_3965) + u + 320] = mem[v + _4429 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4457) > _4457:
                                mem[ceil32(_3965) + u + _4457 + 320] = 0
                            mem[u + 96] = mem[_3901 + 96]
                            mem[u + 128] = mem[_3901 + 128]
                            mem[u + 160] = mem[_3901 + 160]
                            mem[u + 192] = mem[_3901 + 192]
                            mem[u + 224] = mem[_3901 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4457) + ceil32(_3965) + u + 320
                            continue 
                        mem[u + _3965 + 288] = 0
                        _4458 = mem[_3901 + 64]
                        mem[u + 64] = ceil32(_3965) + 288
                        _4477 = mem[_4458]
                        mem[ceil32(_3965) + u + 288] = mem[_4458]
                        v = 0
                        while v < _4477:
                            mem[v + ceil32(_3965) + u + 320] = mem[v + _4458 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4477) > _4477:
                            mem[ceil32(_3965) + u + _4477 + 320] = 0
                        mem[u + 96] = mem[_3901 + 96]
                        mem[u + 128] = mem[_3901 + 128]
                        mem[u + 160] = mem[_3901 + 160]
                        mem[u + 192] = mem[_3901 + 192]
                        mem[u + 224] = mem[_3901 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4477) + ceil32(_3965) + u + 320
                        continue 
                else:
                    mem[_1796 + ceil32(return_data.size) + _1812 + 32] = 0
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2319 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2335 = mem[_2319]
                    require mem[_2319] == mem[_2319 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2383 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2406 = mem[_2383]
                    _2429 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2429] = address(_1252)
                    mem[_2429 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2429 + 64] = _1796 + ceil32(return_data.size)
                    mem[_2429 + 96] = uint8(_2335)
                    mem[_2429 + 128] = 0
                    mem[_2429 + 160] = _2406
                    mem[_2429 + 192] = 0
                    mem[_2429 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2463 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2479 = mem[_2463]
                    require mem[_2463] == mem[_2463 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2479))
                    staticcall address(_2479).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2527 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2527]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2591 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2607 = mem[_2591]
                    require mem[_2591] == mem[_2591 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2607))
                    staticcall address(_2607).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2655 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2429 + 128] = mem[_2655]
                    _2687 = mem[64]
                    mem[mem[64]] = 2
                    _3310 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3310] = 0
                    mem[_3310 + 32] = 96
                    mem[_3310 + 64] = 96
                    mem[_3310 + 96] = 0
                    mem[_3310 + 128] = 0
                    mem[_3310 + 160] = 0
                    mem[_3310 + 192] = 0
                    mem[_3310 + 224] = 0
                    mem[var174001] = _3310
                    s = var174001
                    idx = var174002
                    while idx - 1:
                        _3310 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3310] = 0
                        mem[_3310 + 32] = 96
                        mem[_3310 + 64] = 96
                        mem[_3310 + 96] = 0
                        mem[_3310 + 128] = 0
                        mem[_3310 + 160] = 0
                        mem[_3310 + 192] = 0
                        mem[_3310 + 224] = 0
                        mem[s + 32] = _3310
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2687]
                    mem[_2687 + 32] = _1232
                    require 1 < mem[_2687]
                    mem[_2687 + 64] = _2429
                    _3358 = mem[64]
                    mem[mem[64]] = 32
                    _3374 = mem[_2687]
                    mem[mem[64] + 32] = mem[_2687]
                    idx = 0
                    s = _2687 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3374) + 64
                    while idx < _3374:
                        mem[t] = u + -_3358 - 64
                        _3902 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3946 = mem[_3902 + 32]
                        mem[u + 32] = 256
                        _3966 = mem[_3946]
                        mem[u + 256] = mem[_3946]
                        v = 0
                        while v < _3966:
                            mem[v + u + 288] = mem[v + _3946 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3966) <= _3966:
                            _4430 = mem[_3902 + 64]
                            mem[u + 64] = ceil32(_3966) + 288
                            _4459 = mem[_4430]
                            mem[ceil32(_3966) + u + 288] = mem[_4430]
                            v = 0
                            while v < _4459:
                                mem[v + ceil32(_3966) + u + 320] = mem[v + _4430 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4459) > _4459:
                                mem[ceil32(_3966) + u + _4459 + 320] = 0
                            mem[u + 96] = mem[_3902 + 96]
                            mem[u + 128] = mem[_3902 + 128]
                            mem[u + 160] = mem[_3902 + 160]
                            mem[u + 192] = mem[_3902 + 192]
                            mem[u + 224] = mem[_3902 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4459) + ceil32(_3966) + u + 320
                            continue 
                        mem[u + _3966 + 288] = 0
                        _4460 = mem[_3902 + 64]
                        mem[u + 64] = ceil32(_3966) + 288
                        _4478 = mem[_4460]
                        mem[ceil32(_3966) + u + 288] = mem[_4460]
                        v = 0
                        while v < _4478:
                            mem[v + ceil32(_3966) + u + 320] = mem[v + _4460 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4478) > _4478:
                            mem[ceil32(_3966) + u + _4478 + 320] = 0
                        mem[u + 96] = mem[_3902 + 96]
                        mem[u + 128] = mem[_3902 + 128]
                        mem[u + 160] = mem[_3902 + 160]
                        mem[u + 192] = mem[_3902 + 192]
                        mem[u + 224] = mem[_3902 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4478) + ceil32(_3966) + u + 320
                        continue 
            else:
                mem[_1268 + ceil32(return_data.size) + _1276 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1252))
                staticcall address(_1252).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1800 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1808 = mem[_1800]
                require mem[_1800] <= test266151307()
                require _1800 + mem[_1800] + 31 < _1800 + return_data.size
                _1816 = mem[_1800 + mem[_1800]]
                require mem[_1800 + mem[_1800]] <= test266151307()
                require ceil32(mem[_1800 + mem[_1800]]) + 32 >= 0 and _1800 + ceil32(return_data.size) + ceil32(mem[_1800 + mem[_1800]]) + 32 <= test266151307()
                mem[64] = _1800 + ceil32(return_data.size) + ceil32(mem[_1800 + mem[_1800]]) + 32
                mem[_1800 + ceil32(return_data.size)] = _1816
                require _1808 + _1816 + 32 <= return_data.size
                mem[_1800 + ceil32(return_data.size) + 32 len ceil32(_1816)] = mem[_1800 + _1808 + 32 len ceil32(_1816)]
                if ceil32(_1816) <= _1816:
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2312 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2328 = mem[_2312]
                    require mem[_2312] == mem[_2312 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2376 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2392 = mem[_2376]
                    _2407 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2407] = address(_1252)
                    mem[_2407 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2407 + 64] = _1800 + ceil32(return_data.size)
                    mem[_2407 + 96] = uint8(_2328)
                    mem[_2407 + 128] = 0
                    mem[_2407 + 160] = _2392
                    mem[_2407 + 192] = 0
                    mem[_2407 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2456 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2472 = mem[_2456]
                    require mem[_2456] == mem[_2456 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2472))
                    staticcall address(_2472).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2520 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2520]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2584 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2600 = mem[_2584]
                    require mem[_2584] == mem[_2584 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2600))
                    staticcall address(_2600).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2648 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2407 + 128] = mem[_2648]
                    _2679 = mem[64]
                    mem[mem[64]] = 2
                    _3311 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3311] = 0
                    mem[_3311 + 32] = 96
                    mem[_3311 + 64] = 96
                    mem[_3311 + 96] = 0
                    mem[_3311 + 128] = 0
                    mem[_3311 + 160] = 0
                    mem[_3311 + 192] = 0
                    mem[_3311 + 224] = 0
                    mem[var174001] = _3311
                    s = var174001
                    idx = var174002
                    while idx - 1:
                        _3311 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3311] = 0
                        mem[_3311 + 32] = 96
                        mem[_3311 + 64] = 96
                        mem[_3311 + 96] = 0
                        mem[_3311 + 128] = 0
                        mem[_3311 + 160] = 0
                        mem[_3311 + 192] = 0
                        mem[_3311 + 224] = 0
                        mem[s + 32] = _3311
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2679]
                    mem[_2679 + 32] = _1232
                    require 1 < mem[_2679]
                    mem[_2679 + 64] = _2407
                    _3359 = mem[64]
                    mem[mem[64]] = 32
                    _3375 = mem[_2679]
                    mem[mem[64] + 32] = mem[_2679]
                    idx = 0
                    s = _2679 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3375) + 64
                    while idx < _3375:
                        mem[t] = u + -_3359 - 64
                        _3903 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3949 = mem[_3903 + 32]
                        mem[u + 32] = 256
                        _3967 = mem[_3949]
                        mem[u + 256] = mem[_3949]
                        v = 0
                        while v < _3967:
                            mem[v + u + 288] = mem[v + _3949 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3967) <= _3967:
                            _4431 = mem[_3903 + 64]
                            mem[u + 64] = ceil32(_3967) + 288
                            _4461 = mem[_4431]
                            mem[ceil32(_3967) + u + 288] = mem[_4431]
                            v = 0
                            while v < _4461:
                                mem[v + ceil32(_3967) + u + 320] = mem[v + _4431 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4461) > _4461:
                                mem[ceil32(_3967) + u + _4461 + 320] = 0
                            mem[u + 96] = mem[_3903 + 96]
                            mem[u + 128] = mem[_3903 + 128]
                            mem[u + 160] = mem[_3903 + 160]
                            mem[u + 192] = mem[_3903 + 192]
                            mem[u + 224] = mem[_3903 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4461) + ceil32(_3967) + u + 320
                            continue 
                        mem[u + _3967 + 288] = 0
                        _4462 = mem[_3903 + 64]
                        mem[u + 64] = ceil32(_3967) + 288
                        _4479 = mem[_4462]
                        mem[ceil32(_3967) + u + 288] = mem[_4462]
                        v = 0
                        while v < _4479:
                            mem[v + ceil32(_3967) + u + 320] = mem[v + _4462 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4479) > _4479:
                            mem[ceil32(_3967) + u + _4479 + 320] = 0
                        mem[u + 96] = mem[_3903 + 96]
                        mem[u + 128] = mem[_3903 + 128]
                        mem[u + 160] = mem[_3903 + 160]
                        mem[u + 192] = mem[_3903 + 192]
                        mem[u + 224] = mem[_3903 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4479) + ceil32(_3967) + u + 320
                        continue 
                else:
                    mem[_1800 + ceil32(return_data.size) + _1816 + 32] = 0
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2320 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2336 = mem[_2320]
                    require mem[_2320] == mem[_2320 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2384 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2408 = mem[_2384]
                    _2432 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2432] = address(_1252)
                    mem[_2432 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2432 + 64] = _1800 + ceil32(return_data.size)
                    mem[_2432 + 96] = uint8(_2336)
                    mem[_2432 + 128] = 0
                    mem[_2432 + 160] = _2408
                    mem[_2432 + 192] = 0
                    mem[_2432 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2464 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2480 = mem[_2464]
                    require mem[_2464] == mem[_2464 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2480))
                    staticcall address(_2480).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2528 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2528]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2592 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2608 = mem[_2592]
                    require mem[_2592] == mem[_2592 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2608))
                    staticcall address(_2608).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2656 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2432 + 128] = mem[_2656]
                    _2688 = mem[64]
                    mem[mem[64]] = 2
                    _3312 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3312] = 0
                    mem[_3312 + 32] = 96
                    mem[_3312 + 64] = 96
                    mem[_3312 + 96] = 0
                    mem[_3312 + 128] = 0
                    mem[_3312 + 160] = 0
                    mem[_3312 + 192] = 0
                    mem[_3312 + 224] = 0
                    mem[var175001] = _3312
                    s = var175001
                    idx = var175002
                    while idx - 1:
                        _3312 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3312] = 0
                        mem[_3312 + 32] = 96
                        mem[_3312 + 64] = 96
                        mem[_3312 + 96] = 0
                        mem[_3312 + 128] = 0
                        mem[_3312 + 160] = 0
                        mem[_3312 + 192] = 0
                        mem[_3312 + 224] = 0
                        mem[s + 32] = _3312
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2688]
                    mem[_2688 + 32] = _1232
                    require 1 < mem[_2688]
                    mem[_2688 + 64] = _2432
                    _3360 = mem[64]
                    mem[mem[64]] = 32
                    _3376 = mem[_2688]
                    mem[mem[64] + 32] = mem[_2688]
                    idx = 0
                    s = _2688 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3376) + 64
                    while idx < _3376:
                        mem[t] = u + -_3360 - 64
                        _3904 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3952 = mem[_3904 + 32]
                        mem[u + 32] = 256
                        _3968 = mem[_3952]
                        mem[u + 256] = mem[_3952]
                        v = 0
                        while v < _3968:
                            mem[v + u + 288] = mem[v + _3952 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3968) <= _3968:
                            _4432 = mem[_3904 + 64]
                            mem[u + 64] = ceil32(_3968) + 288
                            _4463 = mem[_4432]
                            mem[ceil32(_3968) + u + 288] = mem[_4432]
                            v = 0
                            while v < _4463:
                                mem[v + ceil32(_3968) + u + 320] = mem[v + _4432 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4463) > _4463:
                                mem[ceil32(_3968) + u + _4463 + 320] = 0
                            mem[u + 96] = mem[_3904 + 96]
                            mem[u + 128] = mem[_3904 + 128]
                            mem[u + 160] = mem[_3904 + 160]
                            mem[u + 192] = mem[_3904 + 192]
                            mem[u + 224] = mem[_3904 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4463) + ceil32(_3968) + u + 320
                            continue 
                        mem[u + _3968 + 288] = 0
                        _4464 = mem[_3904 + 64]
                        mem[u + 64] = ceil32(_3968) + 288
                        _4480 = mem[_4464]
                        mem[ceil32(_3968) + u + 288] = mem[_4464]
                        v = 0
                        while v < _4480:
                            mem[v + ceil32(_3968) + u + 320] = mem[v + _4464 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4480) > _4480:
                            mem[ceil32(_3968) + u + _4480 + 320] = 0
                        mem[u + 96] = mem[_3904 + 96]
                        mem[u + 128] = mem[_3904 + 128]
                        mem[u + 160] = mem[_3904 + 160]
                        mem[u + 192] = mem[_3904 + 192]
                        mem[u + 224] = mem[_3904 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4480) + ceil32(_3968) + u + 320
                        continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function getBnbPrice(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[352] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 352] = 0
    mem[ceil32(return_data.size) + 384] = 96
    mem[ceil32(return_data.size) + 416] = 96
    mem[ceil32(return_data.size) + 448] = 0
    mem[ceil32(return_data.size) + 480] = 0
    mem[ceil32(return_data.size) + 512] = 0
    mem[ceil32(return_data.size) + 544] = 0
    mem[ceil32(return_data.size) + 576] = 0
    mem[ceil32(return_data.size) + 608] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 608 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 608
    require return_data.size >= 32
    _10 = mem[ceil32(return_data.size) + 608]
    require mem[ceil32(return_data.size) + 608] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 639 < ceil32(return_data.size) + return_data.size + 608
    _11 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608] <= test266151307()
    require ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 32 >= 0 and (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640
    mem[(2 * ceil32(return_data.size)) + 608] = _11
    require _10 + _11 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 640 len ceil32(_11)] = mem[ceil32(return_data.size) + _10 + 640 len ceil32(_11)]
    if ceil32(_11) <= _11:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _897 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _899 = mem[_897]
        require mem[_897] <= test266151307()
        require _897 + mem[_897] + 31 < _897 + return_data.size
        _901 = mem[_897 + mem[_897]]
        require mem[_897 + mem[_897]] <= test266151307()
        require ceil32(mem[_897 + mem[_897]]) + 32 >= 0 and _897 + ceil32(return_data.size) + ceil32(mem[_897 + mem[_897]]) + 32 <= test266151307()
        mem[64] = _897 + ceil32(return_data.size) + ceil32(mem[_897 + mem[_897]]) + 32
        mem[_897 + ceil32(return_data.size)] = _901
        require _899 + _901 + 32 <= return_data.size
        mem[_897 + ceil32(return_data.size) + 32 len ceil32(_901)] = mem[_897 + _899 + 32 len ceil32(_901)]
        if ceil32(_901) <= _901:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1781 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1785 = mem[_1781]
            require mem[_1781] == mem[_1781 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1797 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1801 = mem[_1797]
            _1803 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1803] = address(ext_call.return_data[0])
            mem[_1803 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1803 + 64] = _897 + ceil32(return_data.size)
            mem[_1803 + 96] = uint8(_1785)
            mem[_1803 + 128] = 0
            mem[_1803 + 160] = _1801
            mem[_1803 + 192] = 0
            mem[_1803 + 224] = 0
            _1809 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1809] = 0
            mem[_1809 + 32] = 96
            mem[_1809 + 64] = 96
            mem[_1809 + 96] = 0
            mem[_1809 + 128] = 0
            mem[_1809 + 160] = 0
            mem[_1809 + 192] = 0
            mem[_1809 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1821 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1825 = mem[_1821]
            require mem[_1821] == mem[_1821 + 12 len 20]
            _1829 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1829] = 0
            mem[_1829 + 32] = 96
            mem[_1829 + 64] = 96
            mem[_1829 + 96] = 0
            mem[_1829 + 128] = 0
            mem[_1829 + 160] = 0
            mem[_1829 + 192] = 0
            mem[_1829 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1825))
            staticcall address(_1825).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1841 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1845 = mem[_1841]
            require mem[_1841] <= test266151307()
            require _1841 + mem[_1841] + 31 < _1841 + return_data.size
            _1849 = mem[_1841 + mem[_1841]]
            require mem[_1841 + mem[_1841]] <= test266151307()
            require ceil32(mem[_1841 + mem[_1841]]) + 32 >= 0 and _1841 + ceil32(return_data.size) + ceil32(mem[_1841 + mem[_1841]]) + 32 <= test266151307()
            mem[64] = _1841 + ceil32(return_data.size) + ceil32(mem[_1841 + mem[_1841]]) + 32
            mem[_1841 + ceil32(return_data.size)] = _1849
            require _1845 + _1849 + 32 <= return_data.size
            mem[_1841 + ceil32(return_data.size) + 32 len ceil32(_1849)] = mem[_1841 + _1845 + 32 len ceil32(_1849)]
            if ceil32(_1849) <= _1849:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1825))
                staticcall address(_1825).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2657 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2665 = mem[_2657]
                require mem[_2657] <= test266151307()
                require _2657 + mem[_2657] + 31 < _2657 + return_data.size
                _2673 = mem[_2657 + mem[_2657]]
                require mem[_2657 + mem[_2657]] <= test266151307()
                require ceil32(mem[_2657 + mem[_2657]]) + 32 >= 0 and _2657 + ceil32(return_data.size) + ceil32(mem[_2657 + mem[_2657]]) + 32 <= test266151307()
                mem[64] = _2657 + ceil32(return_data.size) + ceil32(mem[_2657 + mem[_2657]]) + 32
                mem[_2657 + ceil32(return_data.size)] = _2673
                require _2665 + _2673 + 32 <= return_data.size
                mem[_2657 + ceil32(return_data.size) + 32 len ceil32(_2673)] = mem[_2657 + _2665 + 32 len ceil32(_2673)]
                if ceil32(_2673) <= _2673:
                    require ext_code.size(address(_1825))
                    staticcall address(_1825).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3457 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3473 = mem[_3457]
                    require mem[_3457] == mem[_3457 + 31 len 1]
                    require ext_code.size(address(_1825))
                    staticcall address(_1825).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3521 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3537 = mem[_3521]
                    _3545 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3545] = address(_1825)
                    mem[_3545 + 32] = _1841 + ceil32(return_data.size)
                    mem[_3545 + 64] = _2657 + ceil32(return_data.size)
                    mem[_3545 + 96] = uint8(_3473)
                    mem[_3545 + 128] = 0
                    mem[_3545 + 160] = _3537
                    mem[_3545 + 192] = 0
                    mem[_3545 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3601 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3617 = mem[_3601]
                    require mem[_3601] == mem[_3601 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_3617))
                    staticcall address(_3617).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3665 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1803 + 128] = mem[_3665]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3729 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3745 = mem[_3729]
                    require mem[_3729] == mem[_3729 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_3745))
                    staticcall address(_3745).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3793 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_3545 + 128] = mem[_3793]
                    _3825 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3825] = 0
                    mem[_3825 + 32] = 96
                    mem[_3825 + 64] = 96
                    mem[_3825 + 96] = 0
                    mem[_3825 + 128] = 0
                    mem[_3825 + 160] = 0
                    mem[_3825 + 192] = 0
                    mem[_3825 + 224] = 0
                    _3841 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3841] = 0
                    mem[_3841 + 32] = 96
                    mem[_3841 + 64] = 96
                    mem[_3841 + 96] = 0
                    mem[_3841 + 128] = 0
                    mem[_3841 + 160] = 0
                    mem[_3841 + 192] = 0
                    mem[_3841 + 224] = 0
                    if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                        _3881 = mem[64]
                        mem[mem[64]] = 2
                        _4932 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4932] = 0
                        mem[_4932 + 32] = 96
                        mem[_4932 + 64] = 96
                        mem[_4932 + 96] = 0
                        mem[_4932 + 128] = 0
                        mem[_4932 + 160] = 0
                        mem[_4932 + 192] = 0
                        mem[_4932 + 224] = 0
                        mem[var180001] = _4932
                        s = var180001
                        idx = var180002
                        while idx - 1:
                            _4932 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4932] = 0
                            mem[_4932 + 32] = 96
                            mem[_4932 + 64] = 96
                            mem[_4932 + 96] = 0
                            mem[_4932 + 128] = 0
                            mem[_4932 + 160] = 0
                            mem[_4932 + 192] = 0
                            mem[_4932 + 224] = 0
                            mem[s + 32] = _4932
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3881]
                        mem[_3881 + 32] = _3545
                        require 1 < mem[_3881]
                        mem[_3881 + 64] = _1803
                        _5220 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5220] = 0
                        mem[_5220 + 32] = 96
                        mem[_5220 + 64] = 96
                        mem[_5220 + 96] = 0
                        mem[_5220 + 128] = 0
                        mem[_5220 + 160] = 0
                        mem[_5220 + 192] = 0
                        mem[_5220 + 224] = 0
                        require 0 < mem[_3881]
                        _5478 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5478] = 0
                        mem[_5478 + 32] = 96
                        mem[_5478 + 64] = 96
                        mem[_5478 + 96] = 0
                        mem[_5478 + 128] = 0
                        mem[_5478 + 160] = 0
                        mem[_5478 + 192] = 0
                        mem[_5478 + 224] = 0
                        require 1 < mem[_3881]
                        if mem[_3545 + 96] <= mem[_1803 + 96]:
                            idx = 12
                            s = mem[_3545 + 96]
                            while idx >= 4:
                                if not mem[_3545 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3545 + 96] - idx
                                continue 
                            _6063 = mem[_3545 + 96]
                            _6064 = mem[_3545 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_6063 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1803 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                                if not _6064 / 10^(_6063 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6064 / 10^(_6063 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6064 / 10^(_6063 - s))
                            if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6064 / 10^(_6063 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6064 / 10^(_6063 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6064 / 10^(_6063 - s))
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _6065 = mem[_3545 + 96]
                        _6066 = mem[_3545 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6065 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6066 / 10^(_6065 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6066 / 10^(_6065 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6066 / 10^(_6065 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6066 / 10^(_6065 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6066 / 10^(_6065 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6066 / 10^(_6065 - s))
                    if wbnbAddress == address(_1825):
                        _3921 = mem[64]
                        mem[mem[64]] = 2
                        _4931 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4931] = 0
                        mem[_4931 + 32] = 96
                        mem[_4931 + 64] = 96
                        mem[_4931 + 96] = 0
                        mem[_4931 + 128] = 0
                        mem[_4931 + 160] = 0
                        mem[_4931 + 192] = 0
                        mem[_4931 + 224] = 0
                        mem[var183001] = _4931
                        s = var183001
                        idx = var183002
                        while idx - 1:
                            _4931 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4931] = 0
                            mem[_4931 + 32] = 96
                            mem[_4931 + 64] = 96
                            mem[_4931 + 96] = 0
                            mem[_4931 + 128] = 0
                            mem[_4931 + 160] = 0
                            mem[_4931 + 192] = 0
                            mem[_4931 + 224] = 0
                            mem[s + 32] = _4931
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3921]
                        mem[_3921 + 32] = _1803
                        require 1 < mem[_3921]
                        mem[_3921 + 64] = _3545
                        _5219 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5219] = 0
                        mem[_5219 + 32] = 96
                        mem[_5219 + 64] = 96
                        mem[_5219 + 96] = 0
                        mem[_5219 + 128] = 0
                        mem[_5219 + 160] = 0
                        mem[_5219 + 192] = 0
                        mem[_5219 + 224] = 0
                        require 0 < mem[_3921]
                        _5477 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5477] = 0
                        mem[_5477 + 32] = 96
                        mem[_5477 + 64] = 96
                        mem[_5477 + 96] = 0
                        mem[_5477 + 128] = 0
                        mem[_5477 + 160] = 0
                        mem[_5477 + 192] = 0
                        mem[_5477 + 224] = 0
                        require 1 < mem[_3921]
                        if mem[_1803 + 96] <= mem[_3545 + 96]:
                            idx = 12
                            s = mem[_1803 + 96]
                            while idx >= 4:
                                if not mem[_1803 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_1803 + 96] - idx
                                continue 
                            _6059 = mem[_1803 + 96]
                            _6060 = mem[_1803 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_6059 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_3545 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_3545 + 128] / 10^(mem[_3545 + 96] - s):
                                if not _6060 / 10^(_6059 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6060 / 10^(_6059 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6060 / 10^(_6059 - s))
                            if 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6060 / 10^(_6059 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _6060 / 10^(_6059 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _6060 / 10^(_6059 - s))
                        idx = 12
                        s = mem[_3545 + 96]
                        while idx >= 4:
                            if not mem[_3545 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3545 + 96] - idx
                            continue 
                        _6061 = mem[_1803 + 96]
                        _6062 = mem[_1803 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6061 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3545 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3545 + 128] / 10^(mem[_3545 + 96] - s):
                            if not _6062 / 10^(_6061 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6062 / 10^(_6061 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6062 / 10^(_6061 - s))
                        if 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6062 / 10^(_6061 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _6062 / 10^(_6061 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _6062 / 10^(_6061 - s))
                    if busdAddress == uint64(ext_call.return_data[0]) << 96:
                        _3969 = mem[64]
                        mem[mem[64]] = 2
                        _4930 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4930] = 0
                        mem[_4930 + 32] = 96
                        mem[_4930 + 64] = 96
                        mem[_4930 + 96] = 0
                        mem[_4930 + 128] = 0
                        mem[_4930 + 160] = 0
                        mem[_4930 + 192] = 0
                        mem[_4930 + 224] = 0
                        mem[var186001] = _4930
                        s = var186001
                        idx = var186002
                        while idx - 1:
                            _4930 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4930] = 0
                            mem[_4930 + 32] = 96
                            mem[_4930 + 64] = 96
                            mem[_4930 + 96] = 0
                            mem[_4930 + 128] = 0
                            mem[_4930 + 160] = 0
                            mem[_4930 + 192] = 0
                            mem[_4930 + 224] = 0
                            mem[s + 32] = _4930
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3969]
                        mem[_3969 + 32] = _3545
                        require 1 < mem[_3969]
                        mem[_3969 + 64] = _1803
                        _5218 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5218] = 0
                        mem[_5218 + 32] = 96
                        mem[_5218 + 64] = 96
                        mem[_5218 + 96] = 0
                        mem[_5218 + 128] = 0
                        mem[_5218 + 160] = 0
                        mem[_5218 + 192] = 0
                        mem[_5218 + 224] = 0
                        require 0 < mem[_3969]
                        _5476 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5476] = 0
                        mem[_5476 + 32] = 96
                        mem[_5476 + 64] = 96
                        mem[_5476 + 96] = 0
                        mem[_5476 + 128] = 0
                        mem[_5476 + 160] = 0
                        mem[_5476 + 192] = 0
                        mem[_5476 + 224] = 0
                        require 1 < mem[_3969]
                        if mem[_3545 + 96] <= mem[_1803 + 96]:
                            idx = 12
                            s = mem[_3545 + 96]
                            while idx >= 4:
                                if not mem[_3545 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3545 + 96] - idx
                                continue 
                            _6055 = mem[_3545 + 96]
                            _6056 = mem[_3545 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_6055 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1803 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                                if not _6056 / 10^(_6055 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6056 / 10^(_6055 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6056 / 10^(_6055 - s))
                            if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6056 / 10^(_6055 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6056 / 10^(_6055 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6056 / 10^(_6055 - s))
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _6057 = mem[_3545 + 96]
                        _6058 = mem[_3545 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6058 / 10^(_6057 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6058 / 10^(_6057 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6058 / 10^(_6057 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6058 / 10^(_6057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6058 / 10^(_6057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6058 / 10^(_6057 - s))
                    if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                        _4017 = mem[64]
                        mem[mem[64]] = 2
                        _4929 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4929] = 0
                        mem[_4929 + 32] = 96
                        mem[_4929 + 64] = 96
                        mem[_4929 + 96] = 0
                        mem[_4929 + 128] = 0
                        mem[_4929 + 160] = 0
                        mem[_4929 + 192] = 0
                        mem[_4929 + 224] = 0
                        mem[var189001] = _4929
                        s = var189001
                        idx = var189002
                        while idx - 1:
                            _4929 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4929] = 0
                            mem[_4929 + 32] = 96
                            mem[_4929 + 64] = 96
                            mem[_4929 + 96] = 0
                            mem[_4929 + 128] = 0
                            mem[_4929 + 160] = 0
                            mem[_4929 + 192] = 0
                            mem[_4929 + 224] = 0
                            mem[s + 32] = _4929
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_4017]
                        mem[_4017 + 32] = _3545
                        require 1 < mem[_4017]
                        mem[_4017 + 64] = _1803
                        _5217 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5217] = 0
                        mem[_5217 + 32] = 96
                        mem[_5217 + 64] = 96
                        mem[_5217 + 96] = 0
                        mem[_5217 + 128] = 0
                        mem[_5217 + 160] = 0
                        mem[_5217 + 192] = 0
                        mem[_5217 + 224] = 0
                        require 0 < mem[_4017]
                        _5475 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5475] = 0
                        mem[_5475 + 32] = 96
                        mem[_5475 + 64] = 96
                        mem[_5475 + 96] = 0
                        mem[_5475 + 128] = 0
                        mem[_5475 + 160] = 0
                        mem[_5475 + 192] = 0
                        mem[_5475 + 224] = 0
                        require 1 < mem[_4017]
                        if mem[_3545 + 96] <= mem[_1803 + 96]:
                            idx = 12
                            s = mem[_3545 + 96]
                            while idx >= 4:
                                if not mem[_3545 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3545 + 96] - idx
                                continue 
                            _6051 = mem[_3545 + 96]
                            _6052 = mem[_3545 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_6051 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1803 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                                if not _6052 / 10^(_6051 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6052 / 10^(_6051 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6052 / 10^(_6051 - s))
                            if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6052 / 10^(_6051 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6052 / 10^(_6051 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6052 / 10^(_6051 - s))
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _6053 = mem[_3545 + 96]
                        _6054 = mem[_3545 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6053 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6054 / 10^(_6053 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6054 / 10^(_6053 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6054 / 10^(_6053 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6054 / 10^(_6053 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6054 / 10^(_6053 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6054 / 10^(_6053 - s))
                    idx = 0
                    while idx < sub_27d312da.length:
                        mem[0] = 1
                        if sub_27d312da[idx] != address(ext_call.return_data[0]):
                            idx = idx + 1
                            continue 
                        _4385 = mem[64]
                        mem[mem[64]] = 2
                        _5986 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_5986] = 0
                        mem[_5986 + 32] = 96
                        mem[_5986 + 64] = 96
                        mem[_5986 + 96] = 0
                        mem[_5986 + 128] = 0
                        mem[_5986 + 160] = 0
                        mem[_5986 + 192] = 0
                        mem[_5986 + 224] = 0
                        mem[var198001] = _5986
                        s = var198001
                        idx = var198002
                        while idx - 1:
                            _5986 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_5986] = 0
                            mem[_5986 + 32] = 96
                            mem[_5986 + 64] = 96
                            mem[_5986 + 96] = 0
                            mem[_5986 + 128] = 0
                            mem[_5986 + 160] = 0
                            mem[_5986 + 192] = 0
                            mem[_5986 + 224] = 0
                            mem[s + 32] = _5986
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_4385]
                        mem[_4385 + 32] = _3545
                        require 1 < mem[_4385]
                        mem[_4385 + 64] = _1803
                        _6466 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_6466] = 0
                        mem[_6466 + 32] = 96
                        mem[_6466 + 64] = 96
                        mem[_6466 + 96] = 0
                        mem[_6466 + 128] = 0
                        mem[_6466 + 160] = 0
                        mem[_6466 + 192] = 0
                        mem[_6466 + 224] = 0
                        require 0 < mem[_4385]
                        _6818 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_6818] = 0
                        mem[_6818 + 32] = 96
                        mem[_6818 + 64] = 96
                        mem[_6818 + 96] = 0
                        mem[_6818 + 128] = 0
                        mem[_6818 + 160] = 0
                        mem[_6818 + 192] = 0
                        mem[_6818 + 224] = 0
                        require 1 < mem[_4385]
                        if mem[_3545 + 96] <= mem[_1803 + 96]:
                            idx = 12
                            s = mem[_3545 + 96]
                            while idx >= 4:
                                if not mem[_3545 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3545 + 96] - idx
                                continue 
                            _12997 = mem[_3545 + 96]
                            _12998 = mem[_3545 + 128]
                            _13123 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13123] = 26
                            mem[_13123 + 32] = 'SafeMath: division by zero'
                            if not 10^(_12997 - s):
                                _13187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _13187 + 68] = mem[idx + _13123 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13187 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _13187 + -mem[64] + 100
                            _14853 = mem[_1803 + 96]
                            _14854 = mem[_1803 + 128]
                            _14981 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14981] = 26
                            mem[_14981 + 32] = 'SafeMath: division by zero'
                            if not 10^(_14853 - s):
                                _15107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15107 + 68] = mem[idx + _14981 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15107 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15107 + -mem[64] + 100
                            if not _14854 / 10^(_14853 - s):
                                _15491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15491] = 26
                                mem[_15491 + 32] = 'SafeMath: division by zero'
                                if not _12998 / 10^(_12997 - s):
                                    _15688 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _15688 + 68] = mem[idx + _15491 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15688 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15688 + -mem[64] + 100
                                _16261 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16261] = 26
                                mem[_16261 + 32] = 'SafeMath: division by zero'
                                if 0 / _12998 / 10^(_12997 - s):
                                    return (1000000 * 10^18 / 0 / _12998 / 10^(_12997 - s))
                                _16457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16457 + 68] = mem[idx + _16261 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16457 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16457 + -mem[64] + 100
                            if 10^12 * _14854 / 10^(_14853 - s) / _14854 / 10^(_14853 - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _15687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15687] = 26
                            mem[_15687 + 32] = 'SafeMath: division by zero'
                            if not _12998 / 10^(_12997 - s):
                                _15877 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15877 + 68] = mem[idx + _15687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15877 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15877 + -mem[64] + 100
                            _16455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16455] = 26
                            mem[_16455 + 32] = 'SafeMath: division by zero'
                            if 10^12 * _14854 / 10^(_14853 - s) / _12998 / 10^(_12997 - s):
                                return (1000000 * 10^18 / 10^12 * _14854 / 10^(_14853 - s) / _12998 / 10^(_12997 - s))
                            _16645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16645 + 68] = mem[idx + _16455 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16645 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16645 + -mem[64] + 100
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _12999 = mem[_3545 + 96]
                        _13000 = mem[_3545 + 128]
                        _13124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13124] = 26
                        mem[_13124 + 32] = 'SafeMath: division by zero'
                        if not 10^(_12999 - s):
                            _13188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13188 + 68] = mem[idx + _13124 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13188 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13188 + -mem[64] + 100
                        _14855 = mem[_1803 + 96]
                        _14856 = mem[_1803 + 128]
                        _14983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14983] = 26
                        mem[_14983 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14855 - s):
                            _15108 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15108 + 68] = mem[idx + _14983 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15108 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15108 + -mem[64] + 100
                        if not _14856 / 10^(_14855 - s):
                            _15492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15492] = 26
                            mem[_15492 + 32] = 'SafeMath: division by zero'
                            if not _13000 / 10^(_12999 - s):
                                _15691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15691 + 68] = mem[idx + _15492 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15691 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15691 + -mem[64] + 100
                            _16263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16263] = 26
                            mem[_16263 + 32] = 'SafeMath: division by zero'
                            if 0 / _13000 / 10^(_12999 - s):
                                return (1000000 * 10^18 / 0 / _13000 / 10^(_12999 - s))
                            _16460 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16460 + 68] = mem[idx + _16263 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16460 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16460 + -mem[64] + 100
                        if 10^12 * _14856 / 10^(_14855 - s) / _14856 / 10^(_14855 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15690 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15690] = 26
                        mem[_15690 + 32] = 'SafeMath: division by zero'
                        if not _13000 / 10^(_12999 - s):
                            _15879 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15879 + 68] = mem[idx + _15690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15879 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15879 + -mem[64] + 100
                        _16458 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16458] = 26
                        mem[_16458 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14856 / 10^(_14855 - s) / _13000 / 10^(_12999 - s):
                            return (1000000 * 10^18 / 10^12 * _14856 / 10^(_14855 - s) / _13000 / 10^(_12999 - s))
                        _16647 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16647 + 68] = mem[idx + _16458 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16647 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16647 + -mem[64] + 100
                    _4225 = mem[64]
                    mem[mem[64]] = 2
                    _5985 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5985] = 0
                    mem[_5985 + 32] = 96
                    mem[_5985 + 64] = 96
                    mem[_5985 + 96] = 0
                    mem[_5985 + 128] = 0
                    mem[_5985 + 160] = 0
                    mem[_5985 + 192] = 0
                    mem[_5985 + 224] = 0
                    mem[var194001] = _5985
                    s = var194001
                    idx = var194002
                    while idx - 1:
                        _5985 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5985] = 0
                        mem[_5985 + 32] = 96
                        mem[_5985 + 64] = 96
                        mem[_5985 + 96] = 0
                        mem[_5985 + 128] = 0
                        mem[_5985 + 160] = 0
                        mem[_5985 + 192] = 0
                        mem[_5985 + 224] = 0
                        mem[s + 32] = _5985
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4225]
                    mem[_4225 + 32] = _1803
                    require 1 < mem[_4225]
                    mem[_4225 + 64] = _3545
                    _6465 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6465] = 0
                    mem[_6465 + 32] = 96
                    mem[_6465 + 64] = 96
                    mem[_6465 + 96] = 0
                    mem[_6465 + 128] = 0
                    mem[_6465 + 160] = 0
                    mem[_6465 + 192] = 0
                    mem[_6465 + 224] = 0
                    require 0 < mem[_4225]
                    _6817 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6817] = 0
                    mem[_6817 + 32] = 96
                    mem[_6817 + 64] = 96
                    mem[_6817 + 96] = 0
                    mem[_6817 + 128] = 0
                    mem[_6817 + 160] = 0
                    mem[_6817 + 192] = 0
                    mem[_6817 + 224] = 0
                    require 1 < mem[_4225]
                    if mem[_1803 + 96] <= mem[_3545 + 96]:
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _12993 = mem[_1803 + 96]
                        _12994 = mem[_1803 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_12993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3545 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3545 + 128] / 10^(mem[_3545 + 96] - s):
                            if not _12994 / 10^(_12993 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _12994 / 10^(_12993 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _12994 / 10^(_12993 - s))
                        if 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _12994 / 10^(_12993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _12994 / 10^(_12993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _12994 / 10^(_12993 - s))
                    idx = 12
                    s = mem[_3545 + 96]
                    while idx >= 4:
                        if not mem[_3545 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3545 + 96] - idx
                        continue 
                    _12995 = mem[_1803 + 96]
                    _12996 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_12995 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3545 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3545 + 128] / 10^(mem[_3545 + 96] - s):
                        if not _12996 / 10^(_12995 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _12996 / 10^(_12995 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _12996 / 10^(_12995 - s))
                    if 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _12996 / 10^(_12995 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _12996 / 10^(_12995 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3545 + 128] / 10^(mem[_3545 + 96] - s) / _12996 / 10^(_12995 - s))
                mem[_2657 + ceil32(return_data.size) + _2673 + 32] = 0
                require ext_code.size(address(_1825))
                staticcall address(_1825).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3465 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3481 = mem[_3465]
                require mem[_3465] == mem[_3465 + 31 len 1]
                require ext_code.size(address(_1825))
                staticcall address(_1825).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3529 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3546 = mem[_3529]
                _3563 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3563] = address(_1825)
                mem[_3563 + 32] = _1841 + ceil32(return_data.size)
                mem[_3563 + 64] = _2657 + ceil32(return_data.size)
                mem[_3563 + 96] = uint8(_3481)
                mem[_3563 + 128] = 0
                mem[_3563 + 160] = _3546
                mem[_3563 + 192] = 0
                mem[_3563 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3609 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3625 = mem[_3609]
                require mem[_3609] == mem[_3609 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3625))
                staticcall address(_3625).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3673 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1803 + 128] = mem[_3673]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3737 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3753 = mem[_3737]
                require mem[_3737] == mem[_3737 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3753))
                staticcall address(_3753).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3801 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3563 + 128] = mem[_3801]
                _3833 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3833] = 0
                mem[_3833 + 32] = 96
                mem[_3833 + 64] = 96
                mem[_3833 + 96] = 0
                mem[_3833 + 128] = 0
                mem[_3833 + 160] = 0
                mem[_3833 + 192] = 0
                mem[_3833 + 224] = 0
                _3850 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3850] = 0
                mem[_3850 + 32] = 96
                mem[_3850 + 64] = 96
                mem[_3850 + 96] = 0
                mem[_3850 + 128] = 0
                mem[_3850 + 160] = 0
                mem[_3850 + 192] = 0
                mem[_3850 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3897 = mem[64]
                    mem[mem[64]] = 2
                    _4936 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4936] = 0
                    mem[_4936 + 32] = 96
                    mem[_4936 + 64] = 96
                    mem[_4936 + 96] = 0
                    mem[_4936 + 128] = 0
                    mem[_4936 + 160] = 0
                    mem[_4936 + 192] = 0
                    mem[_4936 + 224] = 0
                    mem[var181001] = _4936
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _4936 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4936] = 0
                        mem[_4936 + 32] = 96
                        mem[_4936 + 64] = 96
                        mem[_4936 + 96] = 0
                        mem[_4936 + 128] = 0
                        mem[_4936 + 160] = 0
                        mem[_4936 + 192] = 0
                        mem[_4936 + 224] = 0
                        mem[s + 32] = _4936
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3897]
                    mem[_3897 + 32] = _3563
                    require 1 < mem[_3897]
                    mem[_3897 + 64] = _1803
                    _5224 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5224] = 0
                    mem[_5224 + 32] = 96
                    mem[_5224 + 64] = 96
                    mem[_5224 + 96] = 0
                    mem[_5224 + 128] = 0
                    mem[_5224 + 160] = 0
                    mem[_5224 + 192] = 0
                    mem[_5224 + 224] = 0
                    require 0 < mem[_3897]
                    _5484 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5484] = 0
                    mem[_5484 + 32] = 96
                    mem[_5484 + 64] = 96
                    mem[_5484 + 96] = 0
                    mem[_5484 + 128] = 0
                    mem[_5484 + 160] = 0
                    mem[_5484 + 192] = 0
                    mem[_5484 + 224] = 0
                    require 1 < mem[_3897]
                    if mem[_3563 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3563 + 96]
                        while idx >= 4:
                            if not mem[_3563 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3563 + 96] - idx
                            continue 
                        _6081 = mem[_3563 + 96]
                        _6082 = mem[_3563 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6081 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6082 / 10^(_6081 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6082 / 10^(_6081 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6082 / 10^(_6081 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6082 / 10^(_6081 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6082 / 10^(_6081 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6082 / 10^(_6081 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6083 = mem[_3563 + 96]
                    _6084 = mem[_3563 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6083 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6084 / 10^(_6083 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6084 / 10^(_6083 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6084 / 10^(_6083 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6084 / 10^(_6083 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6084 / 10^(_6083 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6084 / 10^(_6083 - s))
                if wbnbAddress == address(_1825):
                    _3945 = mem[64]
                    mem[mem[64]] = 2
                    _4935 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4935] = 0
                    mem[_4935 + 32] = 96
                    mem[_4935 + 64] = 96
                    mem[_4935 + 96] = 0
                    mem[_4935 + 128] = 0
                    mem[_4935 + 160] = 0
                    mem[_4935 + 192] = 0
                    mem[_4935 + 224] = 0
                    mem[var184001] = _4935
                    s = var184001
                    idx = var184002
                    while idx - 1:
                        _4935 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4935] = 0
                        mem[_4935 + 32] = 96
                        mem[_4935 + 64] = 96
                        mem[_4935 + 96] = 0
                        mem[_4935 + 128] = 0
                        mem[_4935 + 160] = 0
                        mem[_4935 + 192] = 0
                        mem[_4935 + 224] = 0
                        mem[s + 32] = _4935
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3945]
                    mem[_3945 + 32] = _1803
                    require 1 < mem[_3945]
                    mem[_3945 + 64] = _3563
                    _5223 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5223] = 0
                    mem[_5223 + 32] = 96
                    mem[_5223 + 64] = 96
                    mem[_5223 + 96] = 0
                    mem[_5223 + 128] = 0
                    mem[_5223 + 160] = 0
                    mem[_5223 + 192] = 0
                    mem[_5223 + 224] = 0
                    require 0 < mem[_3945]
                    _5483 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5483] = 0
                    mem[_5483 + 32] = 96
                    mem[_5483 + 64] = 96
                    mem[_5483 + 96] = 0
                    mem[_5483 + 128] = 0
                    mem[_5483 + 160] = 0
                    mem[_5483 + 192] = 0
                    mem[_5483 + 224] = 0
                    require 1 < mem[_3945]
                    if mem[_1803 + 96] <= mem[_3563 + 96]:
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _6077 = mem[_1803 + 96]
                        _6078 = mem[_1803 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6077 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3563 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3563 + 128] / 10^(mem[_3563 + 96] - s):
                            if not _6078 / 10^(_6077 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6078 / 10^(_6077 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6078 / 10^(_6077 - s))
                        if 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6078 / 10^(_6077 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _6078 / 10^(_6077 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _6078 / 10^(_6077 - s))
                    idx = 12
                    s = mem[_3563 + 96]
                    while idx >= 4:
                        if not mem[_3563 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3563 + 96] - idx
                        continue 
                    _6079 = mem[_1803 + 96]
                    _6080 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6079 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3563 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3563 + 128] / 10^(mem[_3563 + 96] - s):
                        if not _6080 / 10^(_6079 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6080 / 10^(_6079 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6080 / 10^(_6079 - s))
                    if 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6080 / 10^(_6079 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _6080 / 10^(_6079 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _6080 / 10^(_6079 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3993 = mem[64]
                    mem[mem[64]] = 2
                    _4934 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4934] = 0
                    mem[_4934 + 32] = 96
                    mem[_4934 + 64] = 96
                    mem[_4934 + 96] = 0
                    mem[_4934 + 128] = 0
                    mem[_4934 + 160] = 0
                    mem[_4934 + 192] = 0
                    mem[_4934 + 224] = 0
                    mem[var187001] = _4934
                    s = var187001
                    idx = var187002
                    while idx - 1:
                        _4934 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4934] = 0
                        mem[_4934 + 32] = 96
                        mem[_4934 + 64] = 96
                        mem[_4934 + 96] = 0
                        mem[_4934 + 128] = 0
                        mem[_4934 + 160] = 0
                        mem[_4934 + 192] = 0
                        mem[_4934 + 224] = 0
                        mem[s + 32] = _4934
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3993]
                    mem[_3993 + 32] = _3563
                    require 1 < mem[_3993]
                    mem[_3993 + 64] = _1803
                    _5222 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5222] = 0
                    mem[_5222 + 32] = 96
                    mem[_5222 + 64] = 96
                    mem[_5222 + 96] = 0
                    mem[_5222 + 128] = 0
                    mem[_5222 + 160] = 0
                    mem[_5222 + 192] = 0
                    mem[_5222 + 224] = 0
                    require 0 < mem[_3993]
                    _5482 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5482] = 0
                    mem[_5482 + 32] = 96
                    mem[_5482 + 64] = 96
                    mem[_5482 + 96] = 0
                    mem[_5482 + 128] = 0
                    mem[_5482 + 160] = 0
                    mem[_5482 + 192] = 0
                    mem[_5482 + 224] = 0
                    require 1 < mem[_3993]
                    if mem[_3563 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3563 + 96]
                        while idx >= 4:
                            if not mem[_3563 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3563 + 96] - idx
                            continue 
                        _6073 = mem[_3563 + 96]
                        _6074 = mem[_3563 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6073 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6074 / 10^(_6073 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6074 / 10^(_6073 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6074 / 10^(_6073 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6074 / 10^(_6073 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6074 / 10^(_6073 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6074 / 10^(_6073 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6075 = mem[_3563 + 96]
                    _6076 = mem[_3563 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6075 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6076 / 10^(_6075 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6076 / 10^(_6075 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6076 / 10^(_6075 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6076 / 10^(_6075 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6076 / 10^(_6075 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6076 / 10^(_6075 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4041 = mem[64]
                    mem[mem[64]] = 2
                    _4933 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4933] = 0
                    mem[_4933 + 32] = 96
                    mem[_4933 + 64] = 96
                    mem[_4933 + 96] = 0
                    mem[_4933 + 128] = 0
                    mem[_4933 + 160] = 0
                    mem[_4933 + 192] = 0
                    mem[_4933 + 224] = 0
                    mem[var190001] = _4933
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4933 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4933] = 0
                        mem[_4933 + 32] = 96
                        mem[_4933 + 64] = 96
                        mem[_4933 + 96] = 0
                        mem[_4933 + 128] = 0
                        mem[_4933 + 160] = 0
                        mem[_4933 + 192] = 0
                        mem[_4933 + 224] = 0
                        mem[s + 32] = _4933
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4041]
                    mem[_4041 + 32] = _3563
                    require 1 < mem[_4041]
                    mem[_4041 + 64] = _1803
                    _5221 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5221] = 0
                    mem[_5221 + 32] = 96
                    mem[_5221 + 64] = 96
                    mem[_5221 + 96] = 0
                    mem[_5221 + 128] = 0
                    mem[_5221 + 160] = 0
                    mem[_5221 + 192] = 0
                    mem[_5221 + 224] = 0
                    require 0 < mem[_4041]
                    _5481 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5481] = 0
                    mem[_5481 + 32] = 96
                    mem[_5481 + 64] = 96
                    mem[_5481 + 96] = 0
                    mem[_5481 + 128] = 0
                    mem[_5481 + 160] = 0
                    mem[_5481 + 192] = 0
                    mem[_5481 + 224] = 0
                    require 1 < mem[_4041]
                    if mem[_3563 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3563 + 96]
                        while idx >= 4:
                            if not mem[_3563 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3563 + 96] - idx
                            continue 
                        _6069 = mem[_3563 + 96]
                        _6070 = mem[_3563 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6069 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6070 / 10^(_6069 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6070 / 10^(_6069 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6070 / 10^(_6069 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6070 / 10^(_6069 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6070 / 10^(_6069 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6070 / 10^(_6069 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6071 = mem[_3563 + 96]
                    _6072 = mem[_3563 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6071 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6072 / 10^(_6071 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6072 / 10^(_6071 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6072 / 10^(_6071 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6072 / 10^(_6071 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6072 / 10^(_6071 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6072 / 10^(_6071 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4390 = mem[64]
                    mem[mem[64]] = 2
                    _5988 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5988] = 0
                    mem[_5988 + 32] = 96
                    mem[_5988 + 64] = 96
                    mem[_5988 + 96] = 0
                    mem[_5988 + 128] = 0
                    mem[_5988 + 160] = 0
                    mem[_5988 + 192] = 0
                    mem[_5988 + 224] = 0
                    mem[var199001] = _5988
                    s = var199001
                    idx = var199002
                    while idx - 1:
                        _5988 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5988] = 0
                        mem[_5988 + 32] = 96
                        mem[_5988 + 64] = 96
                        mem[_5988 + 96] = 0
                        mem[_5988 + 128] = 0
                        mem[_5988 + 160] = 0
                        mem[_5988 + 192] = 0
                        mem[_5988 + 224] = 0
                        mem[s + 32] = _5988
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4390]
                    mem[_4390 + 32] = _3563
                    require 1 < mem[_4390]
                    mem[_4390 + 64] = _1803
                    _6476 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6476] = 0
                    mem[_6476 + 32] = 96
                    mem[_6476 + 64] = 96
                    mem[_6476 + 96] = 0
                    mem[_6476 + 128] = 0
                    mem[_6476 + 160] = 0
                    mem[_6476 + 192] = 0
                    mem[_6476 + 224] = 0
                    require 0 < mem[_4390]
                    _6820 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6820] = 0
                    mem[_6820 + 32] = 96
                    mem[_6820 + 64] = 96
                    mem[_6820 + 96] = 0
                    mem[_6820 + 128] = 0
                    mem[_6820 + 160] = 0
                    mem[_6820 + 192] = 0
                    mem[_6820 + 224] = 0
                    require 1 < mem[_4390]
                    if mem[_3563 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3563 + 96]
                        while idx >= 4:
                            if not mem[_3563 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3563 + 96] - idx
                            continue 
                        _13005 = mem[_3563 + 96]
                        _13006 = mem[_3563 + 128]
                        _13127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13127] = 26
                        mem[_13127 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13005 - s):
                            _13239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13239 + 68] = mem[idx + _13127 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13239 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13239 + -mem[64] + 100
                        _14861 = mem[_1803 + 96]
                        _14862 = mem[_1803 + 128]
                        _14989 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14989] = 26
                        mem[_14989 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14861 - s):
                            _15111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15111 + 68] = mem[idx + _14989 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15111 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15111 + -mem[64] + 100
                        if not _14862 / 10^(_14861 - s):
                            _15495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15495] = 26
                            mem[_15495 + 32] = 'SafeMath: division by zero'
                            if not _13006 / 10^(_13005 - s):
                                _15700 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15700 + 68] = mem[idx + _15495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15700 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15700 + -mem[64] + 100
                            _16269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16269] = 26
                            mem[_16269 + 32] = 'SafeMath: division by zero'
                            if 0 / _13006 / 10^(_13005 - s):
                                return (1000000 * 10^18 / 0 / _13006 / 10^(_13005 - s))
                            _16469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16469 + 68] = mem[idx + _16269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16469 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16469 + -mem[64] + 100
                        if 10^12 * _14862 / 10^(_14861 - s) / _14862 / 10^(_14861 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15699] = 26
                        mem[_15699 + 32] = 'SafeMath: division by zero'
                        if not _13006 / 10^(_13005 - s):
                            _15885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15885 + 68] = mem[idx + _15699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15885 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15885 + -mem[64] + 100
                        _16467 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16467] = 26
                        mem[_16467 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14862 / 10^(_14861 - s) / _13006 / 10^(_13005 - s):
                            return (1000000 * 10^18 / 10^12 * _14862 / 10^(_14861 - s) / _13006 / 10^(_13005 - s))
                        _16653 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16653 + 68] = mem[idx + _16467 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16653 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16653 + -mem[64] + 100
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _13007 = mem[_3563 + 96]
                    _13008 = mem[_3563 + 128]
                    _13128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13128] = 26
                    mem[_13128 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13007 - s):
                        _13240 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13240 + 68] = mem[idx + _13128 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13240 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13240 + -mem[64] + 100
                    _14863 = mem[_1803 + 96]
                    _14864 = mem[_1803 + 128]
                    _14991 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14991] = 26
                    mem[_14991 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14863 - s):
                        _15112 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15112 + 68] = mem[idx + _14991 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15112 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15112 + -mem[64] + 100
                    if not _14864 / 10^(_14863 - s):
                        _15496 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15496] = 26
                        mem[_15496 + 32] = 'SafeMath: division by zero'
                        if not _13008 / 10^(_13007 - s):
                            _15703 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15703 + 68] = mem[idx + _15496 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15703 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15703 + -mem[64] + 100
                        _16271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16271] = 26
                        mem[_16271 + 32] = 'SafeMath: division by zero'
                        if 0 / _13008 / 10^(_13007 - s):
                            return (1000000 * 10^18 / 0 / _13008 / 10^(_13007 - s))
                        _16472 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16472 + 68] = mem[idx + _16271 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16472 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16472 + -mem[64] + 100
                    if 10^12 * _14864 / 10^(_14863 - s) / _14864 / 10^(_14863 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15702 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15702] = 26
                    mem[_15702 + 32] = 'SafeMath: division by zero'
                    if not _13008 / 10^(_13007 - s):
                        _15887 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15887 + 68] = mem[idx + _15702 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15887 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15887 + -mem[64] + 100
                    _16470 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16470] = 26
                    mem[_16470 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14864 / 10^(_14863 - s) / _13008 / 10^(_13007 - s):
                        return (1000000 * 10^18 / 10^12 * _14864 / 10^(_14863 - s) / _13008 / 10^(_13007 - s))
                    _16655 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16655 + 68] = mem[idx + _16470 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16655 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16655 + -mem[64] + 100
                _4230 = mem[64]
                mem[mem[64]] = 2
                _5987 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5987] = 0
                mem[_5987 + 32] = 96
                mem[_5987 + 64] = 96
                mem[_5987 + 96] = 0
                mem[_5987 + 128] = 0
                mem[_5987 + 160] = 0
                mem[_5987 + 192] = 0
                mem[_5987 + 224] = 0
                mem[var195001] = _5987
                s = var195001
                idx = var195002
                while idx - 1:
                    _5987 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5987] = 0
                    mem[_5987 + 32] = 96
                    mem[_5987 + 64] = 96
                    mem[_5987 + 96] = 0
                    mem[_5987 + 128] = 0
                    mem[_5987 + 160] = 0
                    mem[_5987 + 192] = 0
                    mem[_5987 + 224] = 0
                    mem[s + 32] = _5987
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4230]
                mem[_4230 + 32] = _1803
                require 1 < mem[_4230]
                mem[_4230 + 64] = _3563
                _6475 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6475] = 0
                mem[_6475 + 32] = 96
                mem[_6475 + 64] = 96
                mem[_6475 + 96] = 0
                mem[_6475 + 128] = 0
                mem[_6475 + 160] = 0
                mem[_6475 + 192] = 0
                mem[_6475 + 224] = 0
                require 0 < mem[_4230]
                _6819 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6819] = 0
                mem[_6819 + 32] = 96
                mem[_6819 + 64] = 96
                mem[_6819 + 96] = 0
                mem[_6819 + 128] = 0
                mem[_6819 + 160] = 0
                mem[_6819 + 192] = 0
                mem[_6819 + 224] = 0
                require 1 < mem[_4230]
                if mem[_1803 + 96] <= mem[_3563 + 96]:
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _13001 = mem[_1803 + 96]
                    _13002 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_13001 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3563 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3563 + 128] / 10^(mem[_3563 + 96] - s):
                        if not _13002 / 10^(_13001 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _13002 / 10^(_13001 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _13002 / 10^(_13001 - s))
                    if 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _13002 / 10^(_13001 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _13002 / 10^(_13001 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _13002 / 10^(_13001 - s))
                idx = 12
                s = mem[_3563 + 96]
                while idx >= 4:
                    if not mem[_3563 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3563 + 96] - idx
                    continue 
                _13003 = mem[_1803 + 96]
                _13004 = mem[_1803 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13003 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3563 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3563 + 128] / 10^(mem[_3563 + 96] - s):
                    if not _13004 / 10^(_13003 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13004 / 10^(_13003 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13004 / 10^(_13003 - s))
                if 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13004 / 10^(_13003 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _13004 / 10^(_13003 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3563 + 128] / 10^(mem[_3563 + 96] - s) / _13004 / 10^(_13003 - s))
            mem[_1841 + ceil32(return_data.size) + _1849 + 32] = 0
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1825))
            staticcall address(_1825).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2661 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2669 = mem[_2661]
            require mem[_2661] <= test266151307()
            require _2661 + mem[_2661] + 31 < _2661 + return_data.size
            _2677 = mem[_2661 + mem[_2661]]
            require mem[_2661 + mem[_2661]] <= test266151307()
            require ceil32(mem[_2661 + mem[_2661]]) + 32 >= 0 and _2661 + ceil32(return_data.size) + ceil32(mem[_2661 + mem[_2661]]) + 32 <= test266151307()
            mem[64] = _2661 + ceil32(return_data.size) + ceil32(mem[_2661 + mem[_2661]]) + 32
            mem[_2661 + ceil32(return_data.size)] = _2677
            require _2669 + _2677 + 32 <= return_data.size
            mem[_2661 + ceil32(return_data.size) + 32 len ceil32(_2677)] = mem[_2661 + _2669 + 32 len ceil32(_2677)]
            if ceil32(_2677) <= _2677:
                require ext_code.size(address(_1825))
                staticcall address(_1825).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3458 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3474 = mem[_3458]
                require mem[_3458] == mem[_3458 + 31 len 1]
                require ext_code.size(address(_1825))
                staticcall address(_1825).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3522 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3538 = mem[_3522]
                _3547 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3547] = address(_1825)
                mem[_3547 + 32] = _1841 + ceil32(return_data.size)
                mem[_3547 + 64] = _2661 + ceil32(return_data.size)
                mem[_3547 + 96] = uint8(_3474)
                mem[_3547 + 128] = 0
                mem[_3547 + 160] = _3538
                mem[_3547 + 192] = 0
                mem[_3547 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3602 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3618 = mem[_3602]
                require mem[_3602] == mem[_3602 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3618))
                staticcall address(_3618).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3666 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1803 + 128] = mem[_3666]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3730 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3746 = mem[_3730]
                require mem[_3730] == mem[_3730 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3746))
                staticcall address(_3746).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3794 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3547 + 128] = mem[_3794]
                _3826 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3826] = 0
                mem[_3826 + 32] = 96
                mem[_3826 + 64] = 96
                mem[_3826 + 96] = 0
                mem[_3826 + 128] = 0
                mem[_3826 + 160] = 0
                mem[_3826 + 192] = 0
                mem[_3826 + 224] = 0
                _3842 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3842] = 0
                mem[_3842 + 32] = 96
                mem[_3842 + 64] = 96
                mem[_3842 + 96] = 0
                mem[_3842 + 128] = 0
                mem[_3842 + 160] = 0
                mem[_3842 + 192] = 0
                mem[_3842 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3883 = mem[64]
                    mem[mem[64]] = 2
                    _4940 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4940] = 0
                    mem[_4940 + 32] = 96
                    mem[_4940 + 64] = 96
                    mem[_4940 + 96] = 0
                    mem[_4940 + 128] = 0
                    mem[_4940 + 160] = 0
                    mem[_4940 + 192] = 0
                    mem[_4940 + 224] = 0
                    mem[var181001] = _4940
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _4940 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4940] = 0
                        mem[_4940 + 32] = 96
                        mem[_4940 + 64] = 96
                        mem[_4940 + 96] = 0
                        mem[_4940 + 128] = 0
                        mem[_4940 + 160] = 0
                        mem[_4940 + 192] = 0
                        mem[_4940 + 224] = 0
                        mem[s + 32] = _4940
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3883]
                    mem[_3883 + 32] = _3547
                    require 1 < mem[_3883]
                    mem[_3883 + 64] = _1803
                    _5228 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5228] = 0
                    mem[_5228 + 32] = 96
                    mem[_5228 + 64] = 96
                    mem[_5228 + 96] = 0
                    mem[_5228 + 128] = 0
                    mem[_5228 + 160] = 0
                    mem[_5228 + 192] = 0
                    mem[_5228 + 224] = 0
                    require 0 < mem[_3883]
                    _5490 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5490] = 0
                    mem[_5490 + 32] = 96
                    mem[_5490 + 64] = 96
                    mem[_5490 + 96] = 0
                    mem[_5490 + 128] = 0
                    mem[_5490 + 160] = 0
                    mem[_5490 + 192] = 0
                    mem[_5490 + 224] = 0
                    require 1 < mem[_3883]
                    if mem[_3547 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3547 + 96]
                        while idx >= 4:
                            if not mem[_3547 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3547 + 96] - idx
                            continue 
                        _6099 = mem[_3547 + 96]
                        _6100 = mem[_3547 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6099 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6100 / 10^(_6099 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6100 / 10^(_6099 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6100 / 10^(_6099 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6100 / 10^(_6099 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6100 / 10^(_6099 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6100 / 10^(_6099 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6101 = mem[_3547 + 96]
                    _6102 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6101 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6102 / 10^(_6101 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6102 / 10^(_6101 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6102 / 10^(_6101 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6102 / 10^(_6101 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6102 / 10^(_6101 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6102 / 10^(_6101 - s))
                if wbnbAddress == address(_1825):
                    _3924 = mem[64]
                    mem[mem[64]] = 2
                    _4939 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4939] = 0
                    mem[_4939 + 32] = 96
                    mem[_4939 + 64] = 96
                    mem[_4939 + 96] = 0
                    mem[_4939 + 128] = 0
                    mem[_4939 + 160] = 0
                    mem[_4939 + 192] = 0
                    mem[_4939 + 224] = 0
                    mem[var184001] = _4939
                    s = var184001
                    idx = var184002
                    while idx - 1:
                        _4939 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4939] = 0
                        mem[_4939 + 32] = 96
                        mem[_4939 + 64] = 96
                        mem[_4939 + 96] = 0
                        mem[_4939 + 128] = 0
                        mem[_4939 + 160] = 0
                        mem[_4939 + 192] = 0
                        mem[_4939 + 224] = 0
                        mem[s + 32] = _4939
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3924]
                    mem[_3924 + 32] = _1803
                    require 1 < mem[_3924]
                    mem[_3924 + 64] = _3547
                    _5227 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5227] = 0
                    mem[_5227 + 32] = 96
                    mem[_5227 + 64] = 96
                    mem[_5227 + 96] = 0
                    mem[_5227 + 128] = 0
                    mem[_5227 + 160] = 0
                    mem[_5227 + 192] = 0
                    mem[_5227 + 224] = 0
                    require 0 < mem[_3924]
                    _5489 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5489] = 0
                    mem[_5489 + 32] = 96
                    mem[_5489 + 64] = 96
                    mem[_5489 + 96] = 0
                    mem[_5489 + 128] = 0
                    mem[_5489 + 160] = 0
                    mem[_5489 + 192] = 0
                    mem[_5489 + 224] = 0
                    require 1 < mem[_3924]
                    if mem[_1803 + 96] <= mem[_3547 + 96]:
                        idx = 12
                        s = mem[_1803 + 96]
                        while idx >= 4:
                            if not mem[_1803 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1803 + 96] - idx
                            continue 
                        _6095 = mem[_1803 + 96]
                        _6096 = mem[_1803 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6095 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3547 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                            if not _6096 / 10^(_6095 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6096 / 10^(_6095 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6096 / 10^(_6095 - s))
                        if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6096 / 10^(_6095 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6096 / 10^(_6095 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6096 / 10^(_6095 - s))
                    idx = 12
                    s = mem[_3547 + 96]
                    while idx >= 4:
                        if not mem[_3547 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3547 + 96] - idx
                        continue 
                    _6097 = mem[_1803 + 96]
                    _6098 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6097 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3547 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                        if not _6098 / 10^(_6097 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6098 / 10^(_6097 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6098 / 10^(_6097 - s))
                    if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6098 / 10^(_6097 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6098 / 10^(_6097 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6098 / 10^(_6097 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3972 = mem[64]
                    mem[mem[64]] = 2
                    _4938 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4938] = 0
                    mem[_4938 + 32] = 96
                    mem[_4938 + 64] = 96
                    mem[_4938 + 96] = 0
                    mem[_4938 + 128] = 0
                    mem[_4938 + 160] = 0
                    mem[_4938 + 192] = 0
                    mem[_4938 + 224] = 0
                    mem[var187001] = _4938
                    s = var187001
                    idx = var187002
                    while idx - 1:
                        _4938 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4938] = 0
                        mem[_4938 + 32] = 96
                        mem[_4938 + 64] = 96
                        mem[_4938 + 96] = 0
                        mem[_4938 + 128] = 0
                        mem[_4938 + 160] = 0
                        mem[_4938 + 192] = 0
                        mem[_4938 + 224] = 0
                        mem[s + 32] = _4938
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3972]
                    mem[_3972 + 32] = _3547
                    require 1 < mem[_3972]
                    mem[_3972 + 64] = _1803
                    _5226 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5226] = 0
                    mem[_5226 + 32] = 96
                    mem[_5226 + 64] = 96
                    mem[_5226 + 96] = 0
                    mem[_5226 + 128] = 0
                    mem[_5226 + 160] = 0
                    mem[_5226 + 192] = 0
                    mem[_5226 + 224] = 0
                    require 0 < mem[_3972]
                    _5488 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5488] = 0
                    mem[_5488 + 32] = 96
                    mem[_5488 + 64] = 96
                    mem[_5488 + 96] = 0
                    mem[_5488 + 128] = 0
                    mem[_5488 + 160] = 0
                    mem[_5488 + 192] = 0
                    mem[_5488 + 224] = 0
                    require 1 < mem[_3972]
                    if mem[_3547 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3547 + 96]
                        while idx >= 4:
                            if not mem[_3547 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3547 + 96] - idx
                            continue 
                        _6091 = mem[_3547 + 96]
                        _6092 = mem[_3547 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6091 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6092 / 10^(_6091 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6092 / 10^(_6091 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6092 / 10^(_6091 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6092 / 10^(_6091 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6092 / 10^(_6091 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6092 / 10^(_6091 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6093 = mem[_3547 + 96]
                    _6094 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6094 / 10^(_6093 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6094 / 10^(_6093 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6094 / 10^(_6093 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6094 / 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6094 / 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6094 / 10^(_6093 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4020 = mem[64]
                    mem[mem[64]] = 2
                    _4937 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4937] = 0
                    mem[_4937 + 32] = 96
                    mem[_4937 + 64] = 96
                    mem[_4937 + 96] = 0
                    mem[_4937 + 128] = 0
                    mem[_4937 + 160] = 0
                    mem[_4937 + 192] = 0
                    mem[_4937 + 224] = 0
                    mem[var190001] = _4937
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4937 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4937] = 0
                        mem[_4937 + 32] = 96
                        mem[_4937 + 64] = 96
                        mem[_4937 + 96] = 0
                        mem[_4937 + 128] = 0
                        mem[_4937 + 160] = 0
                        mem[_4937 + 192] = 0
                        mem[_4937 + 224] = 0
                        mem[s + 32] = _4937
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4020]
                    mem[_4020 + 32] = _3547
                    require 1 < mem[_4020]
                    mem[_4020 + 64] = _1803
                    _5225 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5225] = 0
                    mem[_5225 + 32] = 96
                    mem[_5225 + 64] = 96
                    mem[_5225 + 96] = 0
                    mem[_5225 + 128] = 0
                    mem[_5225 + 160] = 0
                    mem[_5225 + 192] = 0
                    mem[_5225 + 224] = 0
                    require 0 < mem[_4020]
                    _5487 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5487] = 0
                    mem[_5487 + 32] = 96
                    mem[_5487 + 64] = 96
                    mem[_5487 + 96] = 0
                    mem[_5487 + 128] = 0
                    mem[_5487 + 160] = 0
                    mem[_5487 + 192] = 0
                    mem[_5487 + 224] = 0
                    require 1 < mem[_4020]
                    if mem[_3547 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3547 + 96]
                        while idx >= 4:
                            if not mem[_3547 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3547 + 96] - idx
                            continue 
                        _6087 = mem[_3547 + 96]
                        _6088 = mem[_3547 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6087 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1803 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                            if not _6088 / 10^(_6087 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6088 / 10^(_6087 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6088 / 10^(_6087 - s))
                        if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6088 / 10^(_6087 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6088 / 10^(_6087 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6088 / 10^(_6087 - s))
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6089 = mem[_3547 + 96]
                    _6090 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6090 / 10^(_6089 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6090 / 10^(_6089 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6090 / 10^(_6089 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6090 / 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6090 / 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6090 / 10^(_6089 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4395 = mem[64]
                    mem[mem[64]] = 2
                    _5990 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5990] = 0
                    mem[_5990 + 32] = 96
                    mem[_5990 + 64] = 96
                    mem[_5990 + 96] = 0
                    mem[_5990 + 128] = 0
                    mem[_5990 + 160] = 0
                    mem[_5990 + 192] = 0
                    mem[_5990 + 224] = 0
                    mem[var199001] = _5990
                    s = var199001
                    idx = var199002
                    while idx - 1:
                        _5990 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5990] = 0
                        mem[_5990 + 32] = 96
                        mem[_5990 + 64] = 96
                        mem[_5990 + 96] = 0
                        mem[_5990 + 128] = 0
                        mem[_5990 + 160] = 0
                        mem[_5990 + 192] = 0
                        mem[_5990 + 224] = 0
                        mem[s + 32] = _5990
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4395]
                    mem[_4395 + 32] = _3547
                    require 1 < mem[_4395]
                    mem[_4395 + 64] = _1803
                    _6486 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6486] = 0
                    mem[_6486 + 32] = 96
                    mem[_6486 + 64] = 96
                    mem[_6486 + 96] = 0
                    mem[_6486 + 128] = 0
                    mem[_6486 + 160] = 0
                    mem[_6486 + 192] = 0
                    mem[_6486 + 224] = 0
                    require 0 < mem[_4395]
                    _6822 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6822] = 0
                    mem[_6822 + 32] = 96
                    mem[_6822 + 64] = 96
                    mem[_6822 + 96] = 0
                    mem[_6822 + 128] = 0
                    mem[_6822 + 160] = 0
                    mem[_6822 + 192] = 0
                    mem[_6822 + 224] = 0
                    require 1 < mem[_4395]
                    if mem[_3547 + 96] <= mem[_1803 + 96]:
                        idx = 12
                        s = mem[_3547 + 96]
                        while idx >= 4:
                            if not mem[_3547 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3547 + 96] - idx
                            continue 
                        _13013 = mem[_3547 + 96]
                        _13014 = mem[_3547 + 128]
                        _13131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13131] = 26
                        mem[_13131 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13013 - s):
                            _13291 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13291 + 68] = mem[idx + _13131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13291 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13291 + -mem[64] + 100
                        _14869 = mem[_1803 + 96]
                        _14870 = mem[_1803 + 128]
                        _14997 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14997] = 26
                        mem[_14997 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14869 - s):
                            _15115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15115 + 68] = mem[idx + _14997 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15115 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15115 + -mem[64] + 100
                        if not _14870 / 10^(_14869 - s):
                            _15499 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15499] = 26
                            mem[_15499 + 32] = 'SafeMath: division by zero'
                            if not _13014 / 10^(_13013 - s):
                                _15712 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15712 + 68] = mem[idx + _15499 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15712 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15712 + -mem[64] + 100
                            _16277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16277] = 26
                            mem[_16277 + 32] = 'SafeMath: division by zero'
                            if 0 / _13014 / 10^(_13013 - s):
                                return (1000000 * 10^18 / 0 / _13014 / 10^(_13013 - s))
                            _16481 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16481 + 68] = mem[idx + _16277 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16481 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16481 + -mem[64] + 100
                        if 10^12 * _14870 / 10^(_14869 - s) / _14870 / 10^(_14869 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15711] = 26
                        mem[_15711 + 32] = 'SafeMath: division by zero'
                        if not _13014 / 10^(_13013 - s):
                            _15893 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15893 + 68] = mem[idx + _15711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15893 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15893 + -mem[64] + 100
                        _16479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16479] = 26
                        mem[_16479 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14870 / 10^(_14869 - s) / _13014 / 10^(_13013 - s):
                            return (1000000 * 10^18 / 10^12 * _14870 / 10^(_14869 - s) / _13014 / 10^(_13013 - s))
                        _16661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16661 + 68] = mem[idx + _16479 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16661 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16661 + -mem[64] + 100
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _13015 = mem[_3547 + 96]
                    _13016 = mem[_3547 + 128]
                    _13132 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13132] = 26
                    mem[_13132 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13015 - s):
                        _13292 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13292 + 68] = mem[idx + _13132 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13292 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13292 + -mem[64] + 100
                    _14871 = mem[_1803 + 96]
                    _14872 = mem[_1803 + 128]
                    _14999 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14999] = 26
                    mem[_14999 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14871 - s):
                        _15116 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15116 + 68] = mem[idx + _14999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15116 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15116 + -mem[64] + 100
                    if not _14872 / 10^(_14871 - s):
                        _15500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15500] = 26
                        mem[_15500 + 32] = 'SafeMath: division by zero'
                        if not _13016 / 10^(_13015 - s):
                            _15715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15715 + 68] = mem[idx + _15500 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15715 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15715 + -mem[64] + 100
                        _16279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16279] = 26
                        mem[_16279 + 32] = 'SafeMath: division by zero'
                        if 0 / _13016 / 10^(_13015 - s):
                            return (1000000 * 10^18 / 0 / _13016 / 10^(_13015 - s))
                        _16484 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16484 + 68] = mem[idx + _16279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16484 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16484 + -mem[64] + 100
                    if 10^12 * _14872 / 10^(_14871 - s) / _14872 / 10^(_14871 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15714] = 26
                    mem[_15714 + 32] = 'SafeMath: division by zero'
                    if not _13016 / 10^(_13015 - s):
                        _15895 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15895 + 68] = mem[idx + _15714 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15895 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15895 + -mem[64] + 100
                    _16482 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16482] = 26
                    mem[_16482 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14872 / 10^(_14871 - s) / _13016 / 10^(_13015 - s):
                        return (1000000 * 10^18 / 10^12 * _14872 / 10^(_14871 - s) / _13016 / 10^(_13015 - s))
                    _16663 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16663 + 68] = mem[idx + _16482 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16663 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16663 + -mem[64] + 100
                _4235 = mem[64]
                mem[mem[64]] = 2
                _5989 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5989] = 0
                mem[_5989 + 32] = 96
                mem[_5989 + 64] = 96
                mem[_5989 + 96] = 0
                mem[_5989 + 128] = 0
                mem[_5989 + 160] = 0
                mem[_5989 + 192] = 0
                mem[_5989 + 224] = 0
                mem[var195001] = _5989
                s = var195001
                idx = var195002
                while idx - 1:
                    _5989 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5989] = 0
                    mem[_5989 + 32] = 96
                    mem[_5989 + 64] = 96
                    mem[_5989 + 96] = 0
                    mem[_5989 + 128] = 0
                    mem[_5989 + 160] = 0
                    mem[_5989 + 192] = 0
                    mem[_5989 + 224] = 0
                    mem[s + 32] = _5989
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4235]
                mem[_4235 + 32] = _1803
                require 1 < mem[_4235]
                mem[_4235 + 64] = _3547
                _6485 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6485] = 0
                mem[_6485 + 32] = 96
                mem[_6485 + 64] = 96
                mem[_6485 + 96] = 0
                mem[_6485 + 128] = 0
                mem[_6485 + 160] = 0
                mem[_6485 + 192] = 0
                mem[_6485 + 224] = 0
                require 0 < mem[_4235]
                _6821 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6821] = 0
                mem[_6821 + 32] = 96
                mem[_6821 + 64] = 96
                mem[_6821 + 96] = 0
                mem[_6821 + 128] = 0
                mem[_6821 + 160] = 0
                mem[_6821 + 192] = 0
                mem[_6821 + 224] = 0
                require 1 < mem[_4235]
                if mem[_1803 + 96] <= mem[_3547 + 96]:
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _13009 = mem[_1803 + 96]
                    _13010 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_13009 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3547 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                        if not _13010 / 10^(_13009 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _13010 / 10^(_13009 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _13010 / 10^(_13009 - s))
                    if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _13010 / 10^(_13009 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13010 / 10^(_13009 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13010 / 10^(_13009 - s))
                idx = 12
                s = mem[_3547 + 96]
                while idx >= 4:
                    if not mem[_3547 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3547 + 96] - idx
                    continue 
                _13011 = mem[_1803 + 96]
                _13012 = mem[_1803 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13011 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3547 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                    if not _13012 / 10^(_13011 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13012 / 10^(_13011 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13012 / 10^(_13011 - s))
                if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13012 / 10^(_13011 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13012 / 10^(_13011 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13012 / 10^(_13011 - s))
            mem[_2661 + ceil32(return_data.size) + _2677 + 32] = 0
            require ext_code.size(address(_1825))
            staticcall address(_1825).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3466 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3482 = mem[_3466]
            require mem[_3466] == mem[_3466 + 31 len 1]
            require ext_code.size(address(_1825))
            staticcall address(_1825).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3530 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3548 = mem[_3530]
            _3566 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3566] = address(_1825)
            mem[_3566 + 32] = _1841 + ceil32(return_data.size)
            mem[_3566 + 64] = _2661 + ceil32(return_data.size)
            mem[_3566 + 96] = uint8(_3482)
            mem[_3566 + 128] = 0
            mem[_3566 + 160] = _3548
            mem[_3566 + 192] = 0
            mem[_3566 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3610 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3626 = mem[_3610]
            require mem[_3610] == mem[_3610 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3626))
            staticcall address(_3626).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3674 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1803 + 128] = mem[_3674]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3738 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3754 = mem[_3738]
            require mem[_3738] == mem[_3738 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3754))
            staticcall address(_3754).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3802 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3566 + 128] = mem[_3802]
            _3834 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3834] = 0
            mem[_3834 + 32] = 96
            mem[_3834 + 64] = 96
            mem[_3834 + 96] = 0
            mem[_3834 + 128] = 0
            mem[_3834 + 160] = 0
            mem[_3834 + 192] = 0
            mem[_3834 + 224] = 0
            _3852 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3852] = 0
            mem[_3852 + 32] = 96
            mem[_3852 + 64] = 96
            mem[_3852 + 96] = 0
            mem[_3852 + 128] = 0
            mem[_3852 + 160] = 0
            mem[_3852 + 192] = 0
            mem[_3852 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3898 = mem[64]
                mem[mem[64]] = 2
                _4944 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4944] = 0
                mem[_4944 + 32] = 96
                mem[_4944 + 64] = 96
                mem[_4944 + 96] = 0
                mem[_4944 + 128] = 0
                mem[_4944 + 160] = 0
                mem[_4944 + 192] = 0
                mem[_4944 + 224] = 0
                mem[var182001] = _4944
                s = var182001
                idx = var182002
                while idx - 1:
                    _4944 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4944] = 0
                    mem[_4944 + 32] = 96
                    mem[_4944 + 64] = 96
                    mem[_4944 + 96] = 0
                    mem[_4944 + 128] = 0
                    mem[_4944 + 160] = 0
                    mem[_4944 + 192] = 0
                    mem[_4944 + 224] = 0
                    mem[s + 32] = _4944
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3898]
                mem[_3898 + 32] = _3566
                require 1 < mem[_3898]
                mem[_3898 + 64] = _1803
                _5232 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5232] = 0
                mem[_5232 + 32] = 96
                mem[_5232 + 64] = 96
                mem[_5232 + 96] = 0
                mem[_5232 + 128] = 0
                mem[_5232 + 160] = 0
                mem[_5232 + 192] = 0
                mem[_5232 + 224] = 0
                require 0 < mem[_3898]
                _5496 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5496] = 0
                mem[_5496 + 32] = 96
                mem[_5496 + 64] = 96
                mem[_5496 + 96] = 0
                mem[_5496 + 128] = 0
                mem[_5496 + 160] = 0
                mem[_5496 + 192] = 0
                mem[_5496 + 224] = 0
                require 1 < mem[_3898]
                if mem[_3566 + 96] <= mem[_1803 + 96]:
                    idx = 12
                    s = mem[_3566 + 96]
                    while idx >= 4:
                        if not mem[_3566 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3566 + 96] - idx
                        continue 
                    _6117 = mem[_3566 + 96]
                    _6118 = mem[_3566 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6117 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6118 / 10^(_6117 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6118 / 10^(_6117 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6118 / 10^(_6117 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6118 / 10^(_6117 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6118 / 10^(_6117 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6118 / 10^(_6117 - s))
                idx = 12
                s = mem[_1803 + 96]
                while idx >= 4:
                    if not mem[_1803 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1803 + 96] - idx
                    continue 
                _6119 = mem[_3566 + 96]
                _6120 = mem[_3566 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6119 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1803 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                    if not _6120 / 10^(_6119 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6120 / 10^(_6119 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6120 / 10^(_6119 - s))
                if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6120 / 10^(_6119 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6120 / 10^(_6119 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6120 / 10^(_6119 - s))
            if wbnbAddress == address(_1825):
                _3946 = mem[64]
                mem[mem[64]] = 2
                _4943 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4943] = 0
                mem[_4943 + 32] = 96
                mem[_4943 + 64] = 96
                mem[_4943 + 96] = 0
                mem[_4943 + 128] = 0
                mem[_4943 + 160] = 0
                mem[_4943 + 192] = 0
                mem[_4943 + 224] = 0
                mem[var185001] = _4943
                s = var185001
                idx = var185002
                while idx - 1:
                    _4943 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4943] = 0
                    mem[_4943 + 32] = 96
                    mem[_4943 + 64] = 96
                    mem[_4943 + 96] = 0
                    mem[_4943 + 128] = 0
                    mem[_4943 + 160] = 0
                    mem[_4943 + 192] = 0
                    mem[_4943 + 224] = 0
                    mem[s + 32] = _4943
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3946]
                mem[_3946 + 32] = _1803
                require 1 < mem[_3946]
                mem[_3946 + 64] = _3566
                _5231 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5231] = 0
                mem[_5231 + 32] = 96
                mem[_5231 + 64] = 96
                mem[_5231 + 96] = 0
                mem[_5231 + 128] = 0
                mem[_5231 + 160] = 0
                mem[_5231 + 192] = 0
                mem[_5231 + 224] = 0
                require 0 < mem[_3946]
                _5495 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5495] = 0
                mem[_5495 + 32] = 96
                mem[_5495 + 64] = 96
                mem[_5495 + 96] = 0
                mem[_5495 + 128] = 0
                mem[_5495 + 160] = 0
                mem[_5495 + 192] = 0
                mem[_5495 + 224] = 0
                require 1 < mem[_3946]
                if mem[_1803 + 96] <= mem[_3566 + 96]:
                    idx = 12
                    s = mem[_1803 + 96]
                    while idx >= 4:
                        if not mem[_1803 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1803 + 96] - idx
                        continue 
                    _6113 = mem[_1803 + 96]
                    _6114 = mem[_1803 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6113 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3566 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3566 + 128] / 10^(mem[_3566 + 96] - s):
                        if not _6114 / 10^(_6113 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6114 / 10^(_6113 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6114 / 10^(_6113 - s))
                    if 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6114 / 10^(_6113 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _6114 / 10^(_6113 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _6114 / 10^(_6113 - s))
                idx = 12
                s = mem[_3566 + 96]
                while idx >= 4:
                    if not mem[_3566 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3566 + 96] - idx
                    continue 
                _6115 = mem[_1803 + 96]
                _6116 = mem[_1803 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6115 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3566 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3566 + 128] / 10^(mem[_3566 + 96] - s):
                    if not _6116 / 10^(_6115 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6116 / 10^(_6115 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6116 / 10^(_6115 - s))
                if 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6116 / 10^(_6115 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _6116 / 10^(_6115 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _6116 / 10^(_6115 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3994 = mem[64]
                mem[mem[64]] = 2
                _4942 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4942] = 0
                mem[_4942 + 32] = 96
                mem[_4942 + 64] = 96
                mem[_4942 + 96] = 0
                mem[_4942 + 128] = 0
                mem[_4942 + 160] = 0
                mem[_4942 + 192] = 0
                mem[_4942 + 224] = 0
                mem[var188001] = _4942
                s = var188001
                idx = var188002
                while idx - 1:
                    _4942 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4942] = 0
                    mem[_4942 + 32] = 96
                    mem[_4942 + 64] = 96
                    mem[_4942 + 96] = 0
                    mem[_4942 + 128] = 0
                    mem[_4942 + 160] = 0
                    mem[_4942 + 192] = 0
                    mem[_4942 + 224] = 0
                    mem[s + 32] = _4942
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3994]
                mem[_3994 + 32] = _3566
                require 1 < mem[_3994]
                mem[_3994 + 64] = _1803
                _5230 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5230] = 0
                mem[_5230 + 32] = 96
                mem[_5230 + 64] = 96
                mem[_5230 + 96] = 0
                mem[_5230 + 128] = 0
                mem[_5230 + 160] = 0
                mem[_5230 + 192] = 0
                mem[_5230 + 224] = 0
                require 0 < mem[_3994]
                _5494 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5494] = 0
                mem[_5494 + 32] = 96
                mem[_5494 + 64] = 96
                mem[_5494 + 96] = 0
                mem[_5494 + 128] = 0
                mem[_5494 + 160] = 0
                mem[_5494 + 192] = 0
                mem[_5494 + 224] = 0
                require 1 < mem[_3994]
                if mem[_3566 + 96] <= mem[_1803 + 96]:
                    idx = 12
                    s = mem[_3566 + 96]
                    while idx >= 4:
                        if not mem[_3566 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3566 + 96] - idx
                        continue 
                    _6109 = mem[_3566 + 96]
                    _6110 = mem[_3566 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6109 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6110 / 10^(_6109 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6110 / 10^(_6109 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6110 / 10^(_6109 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6110 / 10^(_6109 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6110 / 10^(_6109 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6110 / 10^(_6109 - s))
                idx = 12
                s = mem[_1803 + 96]
                while idx >= 4:
                    if not mem[_1803 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1803 + 96] - idx
                    continue 
                _6111 = mem[_3566 + 96]
                _6112 = mem[_3566 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6111 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1803 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                    if not _6112 / 10^(_6111 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6112 / 10^(_6111 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6112 / 10^(_6111 - s))
                if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6112 / 10^(_6111 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6112 / 10^(_6111 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6112 / 10^(_6111 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4042 = mem[64]
                mem[mem[64]] = 2
                _4941 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4941] = 0
                mem[_4941 + 32] = 96
                mem[_4941 + 64] = 96
                mem[_4941 + 96] = 0
                mem[_4941 + 128] = 0
                mem[_4941 + 160] = 0
                mem[_4941 + 192] = 0
                mem[_4941 + 224] = 0
                mem[var191001] = _4941
                s = var191001
                idx = var191002
                while idx - 1:
                    _4941 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4941] = 0
                    mem[_4941 + 32] = 96
                    mem[_4941 + 64] = 96
                    mem[_4941 + 96] = 0
                    mem[_4941 + 128] = 0
                    mem[_4941 + 160] = 0
                    mem[_4941 + 192] = 0
                    mem[_4941 + 224] = 0
                    mem[s + 32] = _4941
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4042]
                mem[_4042 + 32] = _3566
                require 1 < mem[_4042]
                mem[_4042 + 64] = _1803
                _5229 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5229] = 0
                mem[_5229 + 32] = 96
                mem[_5229 + 64] = 96
                mem[_5229 + 96] = 0
                mem[_5229 + 128] = 0
                mem[_5229 + 160] = 0
                mem[_5229 + 192] = 0
                mem[_5229 + 224] = 0
                require 0 < mem[_4042]
                _5493 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5493] = 0
                mem[_5493 + 32] = 96
                mem[_5493 + 64] = 96
                mem[_5493 + 96] = 0
                mem[_5493 + 128] = 0
                mem[_5493 + 160] = 0
                mem[_5493 + 192] = 0
                mem[_5493 + 224] = 0
                require 1 < mem[_4042]
                if mem[_3566 + 96] <= mem[_1803 + 96]:
                    idx = 12
                    s = mem[_3566 + 96]
                    while idx >= 4:
                        if not mem[_3566 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3566 + 96] - idx
                        continue 
                    _6105 = mem[_3566 + 96]
                    _6106 = mem[_3566 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6105 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1803 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                        if not _6106 / 10^(_6105 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6106 / 10^(_6105 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6106 / 10^(_6105 - s))
                    if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6106 / 10^(_6105 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6106 / 10^(_6105 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6106 / 10^(_6105 - s))
                idx = 12
                s = mem[_1803 + 96]
                while idx >= 4:
                    if not mem[_1803 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1803 + 96] - idx
                    continue 
                _6107 = mem[_3566 + 96]
                _6108 = mem[_3566 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6107 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1803 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1803 + 128] / 10^(mem[_1803 + 96] - s):
                    if not _6108 / 10^(_6107 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6108 / 10^(_6107 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6108 / 10^(_6107 - s))
                if 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6108 / 10^(_6107 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6108 / 10^(_6107 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1803 + 128] / 10^(mem[_1803 + 96] - s) / _6108 / 10^(_6107 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4400 = mem[64]
                mem[mem[64]] = 2
                _5992 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5992] = 0
                mem[_5992 + 32] = 96
                mem[_5992 + 64] = 96
                mem[_5992 + 96] = 0
                mem[_5992 + 128] = 0
                mem[_5992 + 160] = 0
                mem[_5992 + 192] = 0
                mem[_5992 + 224] = 0
                mem[var200001] = _5992
                s = var200001
                idx = var200002
                while idx - 1:
                    _5992 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5992] = 0
                    mem[_5992 + 32] = 96
                    mem[_5992 + 64] = 96
                    mem[_5992 + 96] = 0
                    mem[_5992 + 128] = 0
                    mem[_5992 + 160] = 0
                    mem[_5992 + 192] = 0
                    mem[_5992 + 224] = 0
                    mem[s + 32] = _5992
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4400]
                mem[_4400 + 32] = _3566
                require 1 < mem[_4400]
                mem[_4400 + 64] = _1803
                _6496 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6496] = 0
                mem[_6496 + 32] = 96
                mem[_6496 + 64] = 96
                mem[_6496 + 96] = 0
                mem[_6496 + 128] = 0
                mem[_6496 + 160] = 0
                mem[_6496 + 192] = 0
                mem[_6496 + 224] = 0
                require 0 < mem[_4400]
                _6824 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6824] = 0
                mem[_6824 + 32] = 96
                mem[_6824 + 64] = 96
                mem[_6824 + 96] = 0
                mem[_6824 + 128] = 0
                mem[_6824 + 160] = 0
                mem[_6824 + 192] = 0
                mem[_6824 + 224] = 0
                require 1 < mem[_4400]
                if mem[_3566 + 96] <= mem[_1803 + 96]:
                    idx = 12
                    s = mem[_3566 + 96]
                    while idx >= 4:
                        if not mem[_3566 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3566 + 96] - idx
                        continue 
                    _13021 = mem[_3566 + 96]
                    _13022 = mem[_3566 + 128]
                    _13135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13135] = 26
                    mem[_13135 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13021 - s):
                        _13343 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13343 + 68] = mem[idx + _13135 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13343 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13343 + -mem[64] + 100
                    _14877 = mem[_1803 + 96]
                    _14878 = mem[_1803 + 128]
                    _15005 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15005] = 26
                    mem[_15005 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14877 - s):
                        _15119 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15119 + 68] = mem[idx + _15005 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15119 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15119 + -mem[64] + 100
                    if not _14878 / 10^(_14877 - s):
                        _15503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15503] = 26
                        mem[_15503 + 32] = 'SafeMath: division by zero'
                        if not _13022 / 10^(_13021 - s):
                            _15724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15724 + 68] = mem[idx + _15503 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15724 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15724 + -mem[64] + 100
                        _16285 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16285] = 26
                        mem[_16285 + 32] = 'SafeMath: division by zero'
                        if 0 / _13022 / 10^(_13021 - s):
                            return (1000000 * 10^18 / 0 / _13022 / 10^(_13021 - s))
                        _16493 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16493 + 68] = mem[idx + _16285 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16493 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16493 + -mem[64] + 100
                    if 10^12 * _14878 / 10^(_14877 - s) / _14878 / 10^(_14877 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15723] = 26
                    mem[_15723 + 32] = 'SafeMath: division by zero'
                    if not _13022 / 10^(_13021 - s):
                        _15901 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15901 + 68] = mem[idx + _15723 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15901 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15901 + -mem[64] + 100
                    _16491 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16491] = 26
                    mem[_16491 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14878 / 10^(_14877 - s) / _13022 / 10^(_13021 - s):
                        return (1000000 * 10^18 / 10^12 * _14878 / 10^(_14877 - s) / _13022 / 10^(_13021 - s))
                    _16669 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16669 + 68] = mem[idx + _16491 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16669 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16669 + -mem[64] + 100
                idx = 12
                s = mem[_1803 + 96]
                while idx >= 4:
                    if not mem[_1803 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1803 + 96] - idx
                    continue 
                _13023 = mem[_3566 + 96]
                _13024 = mem[_3566 + 128]
                _13136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13136] = 26
                mem[_13136 + 32] = 'SafeMath: division by zero'
                if not 10^(_13023 - s):
                    _13344 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13344 + 68] = mem[idx + _13136 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13344 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13344 + -mem[64] + 100
                _14879 = mem[_1803 + 96]
                _14880 = mem[_1803 + 128]
                _15007 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15007] = 26
                mem[_15007 + 32] = 'SafeMath: division by zero'
                if not 10^(_14879 - s):
                    _15120 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15120 + 68] = mem[idx + _15007 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15120 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15120 + -mem[64] + 100
                if not _14880 / 10^(_14879 - s):
                    _15504 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15504] = 26
                    mem[_15504 + 32] = 'SafeMath: division by zero'
                    if not _13024 / 10^(_13023 - s):
                        _15727 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15727 + 68] = mem[idx + _15504 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15727 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15727 + -mem[64] + 100
                    _16287 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16287] = 26
                    mem[_16287 + 32] = 'SafeMath: division by zero'
                    if 0 / _13024 / 10^(_13023 - s):
                        return (1000000 * 10^18 / 0 / _13024 / 10^(_13023 - s))
                    _16496 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16496 + 68] = mem[idx + _16287 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16496 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16496 + -mem[64] + 100
                if 10^12 * _14880 / 10^(_14879 - s) / _14880 / 10^(_14879 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15726 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15726] = 26
                mem[_15726 + 32] = 'SafeMath: division by zero'
                if not _13024 / 10^(_13023 - s):
                    _15903 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15903 + 68] = mem[idx + _15726 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15903 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15903 + -mem[64] + 100
                _16494 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16494] = 26
                mem[_16494 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14880 / 10^(_14879 - s) / _13024 / 10^(_13023 - s):
                    return (1000000 * 10^18 / 10^12 * _14880 / 10^(_14879 - s) / _13024 / 10^(_13023 - s))
                _16671 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16671 + 68] = mem[idx + _16494 + 32]
                    idx = idx + 32
                    continue 
                mem[_16671 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16671 + -mem[64] + 100
            _4240 = mem[64]
            mem[mem[64]] = 2
            _5991 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5991] = 0
            mem[_5991 + 32] = 96
            mem[_5991 + 64] = 96
            mem[_5991 + 96] = 0
            mem[_5991 + 128] = 0
            mem[_5991 + 160] = 0
            mem[_5991 + 192] = 0
            mem[_5991 + 224] = 0
            mem[var196001] = _5991
            s = var196001
            idx = var196002
            while idx - 1:
                _5991 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5991] = 0
                mem[_5991 + 32] = 96
                mem[_5991 + 64] = 96
                mem[_5991 + 96] = 0
                mem[_5991 + 128] = 0
                mem[_5991 + 160] = 0
                mem[_5991 + 192] = 0
                mem[_5991 + 224] = 0
                mem[s + 32] = _5991
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4240]
            mem[_4240 + 32] = _1803
            require 1 < mem[_4240]
            mem[_4240 + 64] = _3566
            _6495 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6495] = 0
            mem[_6495 + 32] = 96
            mem[_6495 + 64] = 96
            mem[_6495 + 96] = 0
            mem[_6495 + 128] = 0
            mem[_6495 + 160] = 0
            mem[_6495 + 192] = 0
            mem[_6495 + 224] = 0
            require 0 < mem[_4240]
            _6823 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6823] = 0
            mem[_6823 + 32] = 96
            mem[_6823 + 64] = 96
            mem[_6823 + 96] = 0
            mem[_6823 + 128] = 0
            mem[_6823 + 160] = 0
            mem[_6823 + 192] = 0
            mem[_6823 + 224] = 0
            require 1 < mem[_4240]
            if mem[_1803 + 96] <= mem[_3566 + 96]:
                idx = 12
                s = mem[_1803 + 96]
                while idx >= 4:
                    if not mem[_1803 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1803 + 96] - idx
                    continue 
                _13017 = mem[_1803 + 96]
                _13018 = mem[_1803 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13017 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3566 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3566 + 128] / 10^(mem[_3566 + 96] - s):
                    if not _13018 / 10^(_13017 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13018 / 10^(_13017 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13018 / 10^(_13017 - s))
                if 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13018 / 10^(_13017 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _13018 / 10^(_13017 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _13018 / 10^(_13017 - s))
            idx = 12
            s = mem[_3566 + 96]
            while idx >= 4:
                if not mem[_3566 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3566 + 96] - idx
                continue 
            _13019 = mem[_1803 + 96]
            _13020 = mem[_1803 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13019 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3566 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3566 + 128] / 10^(mem[_3566 + 96] - s):
                if not _13020 / 10^(_13019 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13020 / 10^(_13019 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13020 / 10^(_13019 - s))
            if 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13020 / 10^(_13019 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _13020 / 10^(_13019 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3566 + 128] / 10^(mem[_3566 + 96] - s) / _13020 / 10^(_13019 - s))
        mem[_897 + ceil32(return_data.size) + _901 + 32] = 0
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1783 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1787 = mem[_1783]
        require mem[_1783] == mem[_1783 + 31 len 1]
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1799 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1804 = mem[_1799]
        _1807 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1807] = address(ext_call.return_data[0])
        mem[_1807 + 32] = (2 * ceil32(return_data.size)) + 608
        mem[_1807 + 64] = _897 + ceil32(return_data.size)
        mem[_1807 + 96] = uint8(_1787)
        mem[_1807 + 128] = 0
        mem[_1807 + 160] = _1804
        mem[_1807 + 192] = 0
        mem[_1807 + 224] = 0
        _1813 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1813] = 0
        mem[_1813 + 32] = 96
        mem[_1813 + 64] = 96
        mem[_1813 + 96] = 0
        mem[_1813 + 128] = 0
        mem[_1813 + 160] = 0
        mem[_1813 + 192] = 0
        mem[_1813 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1823 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1827 = mem[_1823]
        require mem[_1823] == mem[_1823 + 12 len 20]
        _1833 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1833] = 0
        mem[_1833 + 32] = 96
        mem[_1833 + 64] = 96
        mem[_1833 + 96] = 0
        mem[_1833 + 128] = 0
        mem[_1833 + 160] = 0
        mem[_1833 + 192] = 0
        mem[_1833 + 224] = 0
        mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1827))
        staticcall address(_1827).name() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1843 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1847 = mem[_1843]
        require mem[_1843] <= test266151307()
        require _1843 + mem[_1843] + 31 < _1843 + return_data.size
        _1851 = mem[_1843 + mem[_1843]]
        require mem[_1843 + mem[_1843]] <= test266151307()
        require ceil32(mem[_1843 + mem[_1843]]) + 32 >= 0 and _1843 + ceil32(return_data.size) + ceil32(mem[_1843 + mem[_1843]]) + 32 <= test266151307()
        mem[64] = _1843 + ceil32(return_data.size) + ceil32(mem[_1843 + mem[_1843]]) + 32
        mem[_1843 + ceil32(return_data.size)] = _1851
        require _1847 + _1851 + 32 <= return_data.size
        mem[_1843 + ceil32(return_data.size) + 32 len ceil32(_1851)] = mem[_1843 + _1847 + 32 len ceil32(_1851)]
        if ceil32(_1851) <= _1851:
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1827))
            staticcall address(_1827).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2658 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2666 = mem[_2658]
            require mem[_2658] <= test266151307()
            require _2658 + mem[_2658] + 31 < _2658 + return_data.size
            _2674 = mem[_2658 + mem[_2658]]
            require mem[_2658 + mem[_2658]] <= test266151307()
            require ceil32(mem[_2658 + mem[_2658]]) + 32 >= 0 and _2658 + ceil32(return_data.size) + ceil32(mem[_2658 + mem[_2658]]) + 32 <= test266151307()
            mem[64] = _2658 + ceil32(return_data.size) + ceil32(mem[_2658 + mem[_2658]]) + 32
            mem[_2658 + ceil32(return_data.size)] = _2674
            require _2666 + _2674 + 32 <= return_data.size
            mem[_2658 + ceil32(return_data.size) + 32 len ceil32(_2674)] = mem[_2658 + _2666 + 32 len ceil32(_2674)]
            if ceil32(_2674) <= _2674:
                require ext_code.size(address(_1827))
                staticcall address(_1827).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3459 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3475 = mem[_3459]
                require mem[_3459] == mem[_3459 + 31 len 1]
                require ext_code.size(address(_1827))
                staticcall address(_1827).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3523 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3539 = mem[_3523]
                _3549 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3549] = address(_1827)
                mem[_3549 + 32] = _1843 + ceil32(return_data.size)
                mem[_3549 + 64] = _2658 + ceil32(return_data.size)
                mem[_3549 + 96] = uint8(_3475)
                mem[_3549 + 128] = 0
                mem[_3549 + 160] = _3539
                mem[_3549 + 192] = 0
                mem[_3549 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3603 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3619 = mem[_3603]
                require mem[_3603] == mem[_3603 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3619))
                staticcall address(_3619).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3667 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1807 + 128] = mem[_3667]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3731 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3747 = mem[_3731]
                require mem[_3731] == mem[_3731 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3747))
                staticcall address(_3747).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3795 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3549 + 128] = mem[_3795]
                _3827 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3827] = 0
                mem[_3827 + 32] = 96
                mem[_3827 + 64] = 96
                mem[_3827 + 96] = 0
                mem[_3827 + 128] = 0
                mem[_3827 + 160] = 0
                mem[_3827 + 192] = 0
                mem[_3827 + 224] = 0
                _3843 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3843] = 0
                mem[_3843 + 32] = 96
                mem[_3843 + 64] = 96
                mem[_3843 + 96] = 0
                mem[_3843 + 128] = 0
                mem[_3843 + 160] = 0
                mem[_3843 + 192] = 0
                mem[_3843 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3885 = mem[64]
                    mem[mem[64]] = 2
                    _4948 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4948] = 0
                    mem[_4948 + 32] = 96
                    mem[_4948 + 64] = 96
                    mem[_4948 + 96] = 0
                    mem[_4948 + 128] = 0
                    mem[_4948 + 160] = 0
                    mem[_4948 + 192] = 0
                    mem[_4948 + 224] = 0
                    mem[var181001] = _4948
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _4948 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4948] = 0
                        mem[_4948 + 32] = 96
                        mem[_4948 + 64] = 96
                        mem[_4948 + 96] = 0
                        mem[_4948 + 128] = 0
                        mem[_4948 + 160] = 0
                        mem[_4948 + 192] = 0
                        mem[_4948 + 224] = 0
                        mem[s + 32] = _4948
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3885]
                    mem[_3885 + 32] = _3549
                    require 1 < mem[_3885]
                    mem[_3885 + 64] = _1807
                    _5236 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5236] = 0
                    mem[_5236 + 32] = 96
                    mem[_5236 + 64] = 96
                    mem[_5236 + 96] = 0
                    mem[_5236 + 128] = 0
                    mem[_5236 + 160] = 0
                    mem[_5236 + 192] = 0
                    mem[_5236 + 224] = 0
                    require 0 < mem[_3885]
                    _5502 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5502] = 0
                    mem[_5502 + 32] = 96
                    mem[_5502 + 64] = 96
                    mem[_5502 + 96] = 0
                    mem[_5502 + 128] = 0
                    mem[_5502 + 160] = 0
                    mem[_5502 + 192] = 0
                    mem[_5502 + 224] = 0
                    require 1 < mem[_3885]
                    if mem[_3549 + 96] <= mem[_1807 + 96]:
                        idx = 12
                        s = mem[_3549 + 96]
                        while idx >= 4:
                            if not mem[_3549 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3549 + 96] - idx
                            continue 
                        _6135 = mem[_3549 + 96]
                        _6136 = mem[_3549 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1807 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                            if not _6136 / 10^(_6135 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6136 / 10^(_6135 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6136 / 10^(_6135 - s))
                        if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6136 / 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6136 / 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6136 / 10^(_6135 - s))
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _6137 = mem[_3549 + 96]
                    _6138 = mem[_3549 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6138 / 10^(_6137 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6138 / 10^(_6137 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6138 / 10^(_6137 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6138 / 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6138 / 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6138 / 10^(_6137 - s))
                if wbnbAddress == address(_1827):
                    _3927 = mem[64]
                    mem[mem[64]] = 2
                    _4947 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4947] = 0
                    mem[_4947 + 32] = 96
                    mem[_4947 + 64] = 96
                    mem[_4947 + 96] = 0
                    mem[_4947 + 128] = 0
                    mem[_4947 + 160] = 0
                    mem[_4947 + 192] = 0
                    mem[_4947 + 224] = 0
                    mem[var184001] = _4947
                    s = var184001
                    idx = var184002
                    while idx - 1:
                        _4947 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4947] = 0
                        mem[_4947 + 32] = 96
                        mem[_4947 + 64] = 96
                        mem[_4947 + 96] = 0
                        mem[_4947 + 128] = 0
                        mem[_4947 + 160] = 0
                        mem[_4947 + 192] = 0
                        mem[_4947 + 224] = 0
                        mem[s + 32] = _4947
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3927]
                    mem[_3927 + 32] = _1807
                    require 1 < mem[_3927]
                    mem[_3927 + 64] = _3549
                    _5235 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5235] = 0
                    mem[_5235 + 32] = 96
                    mem[_5235 + 64] = 96
                    mem[_5235 + 96] = 0
                    mem[_5235 + 128] = 0
                    mem[_5235 + 160] = 0
                    mem[_5235 + 192] = 0
                    mem[_5235 + 224] = 0
                    require 0 < mem[_3927]
                    _5501 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5501] = 0
                    mem[_5501 + 32] = 96
                    mem[_5501 + 64] = 96
                    mem[_5501 + 96] = 0
                    mem[_5501 + 128] = 0
                    mem[_5501 + 160] = 0
                    mem[_5501 + 192] = 0
                    mem[_5501 + 224] = 0
                    require 1 < mem[_3927]
                    if mem[_1807 + 96] <= mem[_3549 + 96]:
                        idx = 12
                        s = mem[_1807 + 96]
                        while idx >= 4:
                            if not mem[_1807 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1807 + 96] - idx
                            continue 
                        _6131 = mem[_1807 + 96]
                        _6132 = mem[_1807 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6131 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3549 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3549 + 128] / 10^(mem[_3549 + 96] - s):
                            if not _6132 / 10^(_6131 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6132 / 10^(_6131 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6132 / 10^(_6131 - s))
                        if 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6132 / 10^(_6131 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _6132 / 10^(_6131 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _6132 / 10^(_6131 - s))
                    idx = 12
                    s = mem[_3549 + 96]
                    while idx >= 4:
                        if not mem[_3549 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3549 + 96] - idx
                        continue 
                    _6133 = mem[_1807 + 96]
                    _6134 = mem[_1807 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6133 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3549 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3549 + 128] / 10^(mem[_3549 + 96] - s):
                        if not _6134 / 10^(_6133 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6134 / 10^(_6133 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6134 / 10^(_6133 - s))
                    if 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6134 / 10^(_6133 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _6134 / 10^(_6133 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _6134 / 10^(_6133 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3975 = mem[64]
                    mem[mem[64]] = 2
                    _4946 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4946] = 0
                    mem[_4946 + 32] = 96
                    mem[_4946 + 64] = 96
                    mem[_4946 + 96] = 0
                    mem[_4946 + 128] = 0
                    mem[_4946 + 160] = 0
                    mem[_4946 + 192] = 0
                    mem[_4946 + 224] = 0
                    mem[var187001] = _4946
                    s = var187001
                    idx = var187002
                    while idx - 1:
                        _4946 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4946] = 0
                        mem[_4946 + 32] = 96
                        mem[_4946 + 64] = 96
                        mem[_4946 + 96] = 0
                        mem[_4946 + 128] = 0
                        mem[_4946 + 160] = 0
                        mem[_4946 + 192] = 0
                        mem[_4946 + 224] = 0
                        mem[s + 32] = _4946
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3975]
                    mem[_3975 + 32] = _3549
                    require 1 < mem[_3975]
                    mem[_3975 + 64] = _1807
                    _5234 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5234] = 0
                    mem[_5234 + 32] = 96
                    mem[_5234 + 64] = 96
                    mem[_5234 + 96] = 0
                    mem[_5234 + 128] = 0
                    mem[_5234 + 160] = 0
                    mem[_5234 + 192] = 0
                    mem[_5234 + 224] = 0
                    require 0 < mem[_3975]
                    _5500 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5500] = 0
                    mem[_5500 + 32] = 96
                    mem[_5500 + 64] = 96
                    mem[_5500 + 96] = 0
                    mem[_5500 + 128] = 0
                    mem[_5500 + 160] = 0
                    mem[_5500 + 192] = 0
                    mem[_5500 + 224] = 0
                    require 1 < mem[_3975]
                    if mem[_3549 + 96] <= mem[_1807 + 96]:
                        idx = 12
                        s = mem[_3549 + 96]
                        while idx >= 4:
                            if not mem[_3549 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3549 + 96] - idx
                            continue 
                        _6127 = mem[_3549 + 96]
                        _6128 = mem[_3549 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6127 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1807 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                            if not _6128 / 10^(_6127 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6128 / 10^(_6127 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6128 / 10^(_6127 - s))
                        if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6128 / 10^(_6127 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6128 / 10^(_6127 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6128 / 10^(_6127 - s))
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _6129 = mem[_3549 + 96]
                    _6130 = mem[_3549 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6129 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6130 / 10^(_6129 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6130 / 10^(_6129 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6130 / 10^(_6129 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6130 / 10^(_6129 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6130 / 10^(_6129 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6130 / 10^(_6129 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4023 = mem[64]
                    mem[mem[64]] = 2
                    _4945 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4945] = 0
                    mem[_4945 + 32] = 96
                    mem[_4945 + 64] = 96
                    mem[_4945 + 96] = 0
                    mem[_4945 + 128] = 0
                    mem[_4945 + 160] = 0
                    mem[_4945 + 192] = 0
                    mem[_4945 + 224] = 0
                    mem[var190001] = _4945
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4945 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4945] = 0
                        mem[_4945 + 32] = 96
                        mem[_4945 + 64] = 96
                        mem[_4945 + 96] = 0
                        mem[_4945 + 128] = 0
                        mem[_4945 + 160] = 0
                        mem[_4945 + 192] = 0
                        mem[_4945 + 224] = 0
                        mem[s + 32] = _4945
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4023]
                    mem[_4023 + 32] = _3549
                    require 1 < mem[_4023]
                    mem[_4023 + 64] = _1807
                    _5233 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5233] = 0
                    mem[_5233 + 32] = 96
                    mem[_5233 + 64] = 96
                    mem[_5233 + 96] = 0
                    mem[_5233 + 128] = 0
                    mem[_5233 + 160] = 0
                    mem[_5233 + 192] = 0
                    mem[_5233 + 224] = 0
                    require 0 < mem[_4023]
                    _5499 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5499] = 0
                    mem[_5499 + 32] = 96
                    mem[_5499 + 64] = 96
                    mem[_5499 + 96] = 0
                    mem[_5499 + 128] = 0
                    mem[_5499 + 160] = 0
                    mem[_5499 + 192] = 0
                    mem[_5499 + 224] = 0
                    require 1 < mem[_4023]
                    if mem[_3549 + 96] <= mem[_1807 + 96]:
                        idx = 12
                        s = mem[_3549 + 96]
                        while idx >= 4:
                            if not mem[_3549 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3549 + 96] - idx
                            continue 
                        _6123 = mem[_3549 + 96]
                        _6124 = mem[_3549 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6123 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1807 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                            if not _6124 / 10^(_6123 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6124 / 10^(_6123 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6124 / 10^(_6123 - s))
                        if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6124 / 10^(_6123 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6124 / 10^(_6123 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6124 / 10^(_6123 - s))
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _6125 = mem[_3549 + 96]
                    _6126 = mem[_3549 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6125 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6126 / 10^(_6125 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6126 / 10^(_6125 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6126 / 10^(_6125 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6126 / 10^(_6125 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6126 / 10^(_6125 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6126 / 10^(_6125 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4405 = mem[64]
                    mem[mem[64]] = 2
                    _5994 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5994] = 0
                    mem[_5994 + 32] = 96
                    mem[_5994 + 64] = 96
                    mem[_5994 + 96] = 0
                    mem[_5994 + 128] = 0
                    mem[_5994 + 160] = 0
                    mem[_5994 + 192] = 0
                    mem[_5994 + 224] = 0
                    mem[var199001] = _5994
                    s = var199001
                    idx = var199002
                    while idx - 1:
                        _5994 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5994] = 0
                        mem[_5994 + 32] = 96
                        mem[_5994 + 64] = 96
                        mem[_5994 + 96] = 0
                        mem[_5994 + 128] = 0
                        mem[_5994 + 160] = 0
                        mem[_5994 + 192] = 0
                        mem[_5994 + 224] = 0
                        mem[s + 32] = _5994
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4405]
                    mem[_4405 + 32] = _3549
                    require 1 < mem[_4405]
                    mem[_4405 + 64] = _1807
                    _6506 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6506] = 0
                    mem[_6506 + 32] = 96
                    mem[_6506 + 64] = 96
                    mem[_6506 + 96] = 0
                    mem[_6506 + 128] = 0
                    mem[_6506 + 160] = 0
                    mem[_6506 + 192] = 0
                    mem[_6506 + 224] = 0
                    require 0 < mem[_4405]
                    _6826 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6826] = 0
                    mem[_6826 + 32] = 96
                    mem[_6826 + 64] = 96
                    mem[_6826 + 96] = 0
                    mem[_6826 + 128] = 0
                    mem[_6826 + 160] = 0
                    mem[_6826 + 192] = 0
                    mem[_6826 + 224] = 0
                    require 1 < mem[_4405]
                    if mem[_3549 + 96] <= mem[_1807 + 96]:
                        idx = 12
                        s = mem[_3549 + 96]
                        while idx >= 4:
                            if not mem[_3549 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3549 + 96] - idx
                            continue 
                        _13029 = mem[_3549 + 96]
                        _13030 = mem[_3549 + 128]
                        _13139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13139] = 26
                        mem[_13139 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13029 - s):
                            _13395 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13395 + 68] = mem[idx + _13139 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13395 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13395 + -mem[64] + 100
                        _14885 = mem[_1807 + 96]
                        _14886 = mem[_1807 + 128]
                        _15013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15013] = 26
                        mem[_15013 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14885 - s):
                            _15123 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15123 + 68] = mem[idx + _15013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15123 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15123 + -mem[64] + 100
                        if not _14886 / 10^(_14885 - s):
                            _15507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15507] = 26
                            mem[_15507 + 32] = 'SafeMath: division by zero'
                            if not _13030 / 10^(_13029 - s):
                                _15736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15736 + 68] = mem[idx + _15507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15736 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15736 + -mem[64] + 100
                            _16293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16293] = 26
                            mem[_16293 + 32] = 'SafeMath: division by zero'
                            if 0 / _13030 / 10^(_13029 - s):
                                return (1000000 * 10^18 / 0 / _13030 / 10^(_13029 - s))
                            _16505 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16505 + 68] = mem[idx + _16293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16505 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16505 + -mem[64] + 100
                        if 10^12 * _14886 / 10^(_14885 - s) / _14886 / 10^(_14885 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15735] = 26
                        mem[_15735 + 32] = 'SafeMath: division by zero'
                        if not _13030 / 10^(_13029 - s):
                            _15909 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15909 + 68] = mem[idx + _15735 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15909 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15909 + -mem[64] + 100
                        _16503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16503] = 26
                        mem[_16503 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14886 / 10^(_14885 - s) / _13030 / 10^(_13029 - s):
                            return (1000000 * 10^18 / 10^12 * _14886 / 10^(_14885 - s) / _13030 / 10^(_13029 - s))
                        _16677 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16677 + 68] = mem[idx + _16503 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16677 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16677 + -mem[64] + 100
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _13031 = mem[_3549 + 96]
                    _13032 = mem[_3549 + 128]
                    _13140 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13140] = 26
                    mem[_13140 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13031 - s):
                        _13396 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13396 + 68] = mem[idx + _13140 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13396 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13396 + -mem[64] + 100
                    _14887 = mem[_1807 + 96]
                    _14888 = mem[_1807 + 128]
                    _15015 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15015] = 26
                    mem[_15015 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14887 - s):
                        _15124 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15124 + 68] = mem[idx + _15015 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15124 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15124 + -mem[64] + 100
                    if not _14888 / 10^(_14887 - s):
                        _15508 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15508] = 26
                        mem[_15508 + 32] = 'SafeMath: division by zero'
                        if not _13032 / 10^(_13031 - s):
                            _15739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15739 + 68] = mem[idx + _15508 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15739 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15739 + -mem[64] + 100
                        _16295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16295] = 26
                        mem[_16295 + 32] = 'SafeMath: division by zero'
                        if 0 / _13032 / 10^(_13031 - s):
                            return (1000000 * 10^18 / 0 / _13032 / 10^(_13031 - s))
                        _16508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16508 + 68] = mem[idx + _16295 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16508 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16508 + -mem[64] + 100
                    if 10^12 * _14888 / 10^(_14887 - s) / _14888 / 10^(_14887 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15738 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15738] = 26
                    mem[_15738 + 32] = 'SafeMath: division by zero'
                    if not _13032 / 10^(_13031 - s):
                        _15911 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15911 + 68] = mem[idx + _15738 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15911 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15911 + -mem[64] + 100
                    _16506 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16506] = 26
                    mem[_16506 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14888 / 10^(_14887 - s) / _13032 / 10^(_13031 - s):
                        return (1000000 * 10^18 / 10^12 * _14888 / 10^(_14887 - s) / _13032 / 10^(_13031 - s))
                    _16679 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16679 + 68] = mem[idx + _16506 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16679 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16679 + -mem[64] + 100
                _4245 = mem[64]
                mem[mem[64]] = 2
                _5993 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5993] = 0
                mem[_5993 + 32] = 96
                mem[_5993 + 64] = 96
                mem[_5993 + 96] = 0
                mem[_5993 + 128] = 0
                mem[_5993 + 160] = 0
                mem[_5993 + 192] = 0
                mem[_5993 + 224] = 0
                mem[var195001] = _5993
                s = var195001
                idx = var195002
                while idx - 1:
                    _5993 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5993] = 0
                    mem[_5993 + 32] = 96
                    mem[_5993 + 64] = 96
                    mem[_5993 + 96] = 0
                    mem[_5993 + 128] = 0
                    mem[_5993 + 160] = 0
                    mem[_5993 + 192] = 0
                    mem[_5993 + 224] = 0
                    mem[s + 32] = _5993
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4245]
                mem[_4245 + 32] = _1807
                require 1 < mem[_4245]
                mem[_4245 + 64] = _3549
                _6505 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6505] = 0
                mem[_6505 + 32] = 96
                mem[_6505 + 64] = 96
                mem[_6505 + 96] = 0
                mem[_6505 + 128] = 0
                mem[_6505 + 160] = 0
                mem[_6505 + 192] = 0
                mem[_6505 + 224] = 0
                require 0 < mem[_4245]
                _6825 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6825] = 0
                mem[_6825 + 32] = 96
                mem[_6825 + 64] = 96
                mem[_6825 + 96] = 0
                mem[_6825 + 128] = 0
                mem[_6825 + 160] = 0
                mem[_6825 + 192] = 0
                mem[_6825 + 224] = 0
                require 1 < mem[_4245]
                if mem[_1807 + 96] <= mem[_3549 + 96]:
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _13025 = mem[_1807 + 96]
                    _13026 = mem[_1807 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_13025 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3549 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3549 + 128] / 10^(mem[_3549 + 96] - s):
                        if not _13026 / 10^(_13025 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _13026 / 10^(_13025 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _13026 / 10^(_13025 - s))
                    if 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _13026 / 10^(_13025 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _13026 / 10^(_13025 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _13026 / 10^(_13025 - s))
                idx = 12
                s = mem[_3549 + 96]
                while idx >= 4:
                    if not mem[_3549 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3549 + 96] - idx
                    continue 
                _13027 = mem[_1807 + 96]
                _13028 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13027 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3549 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3549 + 128] / 10^(mem[_3549 + 96] - s):
                    if not _13028 / 10^(_13027 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13028 / 10^(_13027 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13028 / 10^(_13027 - s))
                if 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13028 / 10^(_13027 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _13028 / 10^(_13027 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3549 + 128] / 10^(mem[_3549 + 96] - s) / _13028 / 10^(_13027 - s))
            mem[_2658 + ceil32(return_data.size) + _2674 + 32] = 0
            require ext_code.size(address(_1827))
            staticcall address(_1827).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3467 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3483 = mem[_3467]
            require mem[_3467] == mem[_3467 + 31 len 1]
            require ext_code.size(address(_1827))
            staticcall address(_1827).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3531 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3550 = mem[_3531]
            _3569 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3569] = address(_1827)
            mem[_3569 + 32] = _1843 + ceil32(return_data.size)
            mem[_3569 + 64] = _2658 + ceil32(return_data.size)
            mem[_3569 + 96] = uint8(_3483)
            mem[_3569 + 128] = 0
            mem[_3569 + 160] = _3550
            mem[_3569 + 192] = 0
            mem[_3569 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3611 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3627 = mem[_3611]
            require mem[_3611] == mem[_3611 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3627))
            staticcall address(_3627).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3675 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1807 + 128] = mem[_3675]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3739 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3755 = mem[_3739]
            require mem[_3739] == mem[_3739 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3755))
            staticcall address(_3755).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3803 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3569 + 128] = mem[_3803]
            _3835 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3835] = 0
            mem[_3835 + 32] = 96
            mem[_3835 + 64] = 96
            mem[_3835 + 96] = 0
            mem[_3835 + 128] = 0
            mem[_3835 + 160] = 0
            mem[_3835 + 192] = 0
            mem[_3835 + 224] = 0
            _3854 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3854] = 0
            mem[_3854 + 32] = 96
            mem[_3854 + 64] = 96
            mem[_3854 + 96] = 0
            mem[_3854 + 128] = 0
            mem[_3854 + 160] = 0
            mem[_3854 + 192] = 0
            mem[_3854 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3899 = mem[64]
                mem[mem[64]] = 2
                _4952 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4952] = 0
                mem[_4952 + 32] = 96
                mem[_4952 + 64] = 96
                mem[_4952 + 96] = 0
                mem[_4952 + 128] = 0
                mem[_4952 + 160] = 0
                mem[_4952 + 192] = 0
                mem[_4952 + 224] = 0
                mem[var182001] = _4952
                s = var182001
                idx = var182002
                while idx - 1:
                    _4952 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4952] = 0
                    mem[_4952 + 32] = 96
                    mem[_4952 + 64] = 96
                    mem[_4952 + 96] = 0
                    mem[_4952 + 128] = 0
                    mem[_4952 + 160] = 0
                    mem[_4952 + 192] = 0
                    mem[_4952 + 224] = 0
                    mem[s + 32] = _4952
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3899]
                mem[_3899 + 32] = _3569
                require 1 < mem[_3899]
                mem[_3899 + 64] = _1807
                _5240 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5240] = 0
                mem[_5240 + 32] = 96
                mem[_5240 + 64] = 96
                mem[_5240 + 96] = 0
                mem[_5240 + 128] = 0
                mem[_5240 + 160] = 0
                mem[_5240 + 192] = 0
                mem[_5240 + 224] = 0
                require 0 < mem[_3899]
                _5508 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5508] = 0
                mem[_5508 + 32] = 96
                mem[_5508 + 64] = 96
                mem[_5508 + 96] = 0
                mem[_5508 + 128] = 0
                mem[_5508 + 160] = 0
                mem[_5508 + 192] = 0
                mem[_5508 + 224] = 0
                require 1 < mem[_3899]
                if mem[_3569 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3569 + 96]
                    while idx >= 4:
                        if not mem[_3569 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3569 + 96] - idx
                        continue 
                    _6153 = mem[_3569 + 96]
                    _6154 = mem[_3569 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6154 / 10^(_6153 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6154 / 10^(_6153 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6154 / 10^(_6153 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6154 / 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6154 / 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6154 / 10^(_6153 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6155 = mem[_3569 + 96]
                _6156 = mem[_3569 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6156 / 10^(_6155 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6156 / 10^(_6155 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6156 / 10^(_6155 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6156 / 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6156 / 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6156 / 10^(_6155 - s))
            if wbnbAddress == address(_1827):
                _3947 = mem[64]
                mem[mem[64]] = 2
                _4951 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4951] = 0
                mem[_4951 + 32] = 96
                mem[_4951 + 64] = 96
                mem[_4951 + 96] = 0
                mem[_4951 + 128] = 0
                mem[_4951 + 160] = 0
                mem[_4951 + 192] = 0
                mem[_4951 + 224] = 0
                mem[var185001] = _4951
                s = var185001
                idx = var185002
                while idx - 1:
                    _4951 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4951] = 0
                    mem[_4951 + 32] = 96
                    mem[_4951 + 64] = 96
                    mem[_4951 + 96] = 0
                    mem[_4951 + 128] = 0
                    mem[_4951 + 160] = 0
                    mem[_4951 + 192] = 0
                    mem[_4951 + 224] = 0
                    mem[s + 32] = _4951
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3947]
                mem[_3947 + 32] = _1807
                require 1 < mem[_3947]
                mem[_3947 + 64] = _3569
                _5239 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5239] = 0
                mem[_5239 + 32] = 96
                mem[_5239 + 64] = 96
                mem[_5239 + 96] = 0
                mem[_5239 + 128] = 0
                mem[_5239 + 160] = 0
                mem[_5239 + 192] = 0
                mem[_5239 + 224] = 0
                require 0 < mem[_3947]
                _5507 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5507] = 0
                mem[_5507 + 32] = 96
                mem[_5507 + 64] = 96
                mem[_5507 + 96] = 0
                mem[_5507 + 128] = 0
                mem[_5507 + 160] = 0
                mem[_5507 + 192] = 0
                mem[_5507 + 224] = 0
                require 1 < mem[_3947]
                if mem[_1807 + 96] <= mem[_3569 + 96]:
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _6149 = mem[_1807 + 96]
                    _6150 = mem[_1807 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3569 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3569 + 128] / 10^(mem[_3569 + 96] - s):
                        if not _6150 / 10^(_6149 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6150 / 10^(_6149 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6150 / 10^(_6149 - s))
                    if 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6150 / 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _6150 / 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _6150 / 10^(_6149 - s))
                idx = 12
                s = mem[_3569 + 96]
                while idx >= 4:
                    if not mem[_3569 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3569 + 96] - idx
                    continue 
                _6151 = mem[_1807 + 96]
                _6152 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6151 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3569 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3569 + 128] / 10^(mem[_3569 + 96] - s):
                    if not _6152 / 10^(_6151 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6152 / 10^(_6151 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6152 / 10^(_6151 - s))
                if 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6152 / 10^(_6151 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _6152 / 10^(_6151 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _6152 / 10^(_6151 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3995 = mem[64]
                mem[mem[64]] = 2
                _4950 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4950] = 0
                mem[_4950 + 32] = 96
                mem[_4950 + 64] = 96
                mem[_4950 + 96] = 0
                mem[_4950 + 128] = 0
                mem[_4950 + 160] = 0
                mem[_4950 + 192] = 0
                mem[_4950 + 224] = 0
                mem[var188001] = _4950
                s = var188001
                idx = var188002
                while idx - 1:
                    _4950 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4950] = 0
                    mem[_4950 + 32] = 96
                    mem[_4950 + 64] = 96
                    mem[_4950 + 96] = 0
                    mem[_4950 + 128] = 0
                    mem[_4950 + 160] = 0
                    mem[_4950 + 192] = 0
                    mem[_4950 + 224] = 0
                    mem[s + 32] = _4950
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3995]
                mem[_3995 + 32] = _3569
                require 1 < mem[_3995]
                mem[_3995 + 64] = _1807
                _5238 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5238] = 0
                mem[_5238 + 32] = 96
                mem[_5238 + 64] = 96
                mem[_5238 + 96] = 0
                mem[_5238 + 128] = 0
                mem[_5238 + 160] = 0
                mem[_5238 + 192] = 0
                mem[_5238 + 224] = 0
                require 0 < mem[_3995]
                _5506 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5506] = 0
                mem[_5506 + 32] = 96
                mem[_5506 + 64] = 96
                mem[_5506 + 96] = 0
                mem[_5506 + 128] = 0
                mem[_5506 + 160] = 0
                mem[_5506 + 192] = 0
                mem[_5506 + 224] = 0
                require 1 < mem[_3995]
                if mem[_3569 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3569 + 96]
                    while idx >= 4:
                        if not mem[_3569 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3569 + 96] - idx
                        continue 
                    _6145 = mem[_3569 + 96]
                    _6146 = mem[_3569 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6146 / 10^(_6145 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6146 / 10^(_6145 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6146 / 10^(_6145 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6146 / 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6146 / 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6146 / 10^(_6145 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6147 = mem[_3569 + 96]
                _6148 = mem[_3569 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6147 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6148 / 10^(_6147 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6148 / 10^(_6147 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6148 / 10^(_6147 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6148 / 10^(_6147 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6148 / 10^(_6147 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6148 / 10^(_6147 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4043 = mem[64]
                mem[mem[64]] = 2
                _4949 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4949] = 0
                mem[_4949 + 32] = 96
                mem[_4949 + 64] = 96
                mem[_4949 + 96] = 0
                mem[_4949 + 128] = 0
                mem[_4949 + 160] = 0
                mem[_4949 + 192] = 0
                mem[_4949 + 224] = 0
                mem[var191001] = _4949
                s = var191001
                idx = var191002
                while idx - 1:
                    _4949 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4949] = 0
                    mem[_4949 + 32] = 96
                    mem[_4949 + 64] = 96
                    mem[_4949 + 96] = 0
                    mem[_4949 + 128] = 0
                    mem[_4949 + 160] = 0
                    mem[_4949 + 192] = 0
                    mem[_4949 + 224] = 0
                    mem[s + 32] = _4949
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4043]
                mem[_4043 + 32] = _3569
                require 1 < mem[_4043]
                mem[_4043 + 64] = _1807
                _5237 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5237] = 0
                mem[_5237 + 32] = 96
                mem[_5237 + 64] = 96
                mem[_5237 + 96] = 0
                mem[_5237 + 128] = 0
                mem[_5237 + 160] = 0
                mem[_5237 + 192] = 0
                mem[_5237 + 224] = 0
                require 0 < mem[_4043]
                _5505 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5505] = 0
                mem[_5505 + 32] = 96
                mem[_5505 + 64] = 96
                mem[_5505 + 96] = 0
                mem[_5505 + 128] = 0
                mem[_5505 + 160] = 0
                mem[_5505 + 192] = 0
                mem[_5505 + 224] = 0
                require 1 < mem[_4043]
                if mem[_3569 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3569 + 96]
                    while idx >= 4:
                        if not mem[_3569 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3569 + 96] - idx
                        continue 
                    _6141 = mem[_3569 + 96]
                    _6142 = mem[_3569 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6142 / 10^(_6141 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6142 / 10^(_6141 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6142 / 10^(_6141 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6142 / 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6142 / 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6142 / 10^(_6141 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6143 = mem[_3569 + 96]
                _6144 = mem[_3569 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6143 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6144 / 10^(_6143 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6144 / 10^(_6143 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6144 / 10^(_6143 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6144 / 10^(_6143 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6144 / 10^(_6143 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6144 / 10^(_6143 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4410 = mem[64]
                mem[mem[64]] = 2
                _5996 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5996] = 0
                mem[_5996 + 32] = 96
                mem[_5996 + 64] = 96
                mem[_5996 + 96] = 0
                mem[_5996 + 128] = 0
                mem[_5996 + 160] = 0
                mem[_5996 + 192] = 0
                mem[_5996 + 224] = 0
                mem[var200001] = _5996
                s = var200001
                idx = var200002
                while idx - 1:
                    _5996 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5996] = 0
                    mem[_5996 + 32] = 96
                    mem[_5996 + 64] = 96
                    mem[_5996 + 96] = 0
                    mem[_5996 + 128] = 0
                    mem[_5996 + 160] = 0
                    mem[_5996 + 192] = 0
                    mem[_5996 + 224] = 0
                    mem[s + 32] = _5996
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4410]
                mem[_4410 + 32] = _3569
                require 1 < mem[_4410]
                mem[_4410 + 64] = _1807
                _6516 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6516] = 0
                mem[_6516 + 32] = 96
                mem[_6516 + 64] = 96
                mem[_6516 + 96] = 0
                mem[_6516 + 128] = 0
                mem[_6516 + 160] = 0
                mem[_6516 + 192] = 0
                mem[_6516 + 224] = 0
                require 0 < mem[_4410]
                _6828 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6828] = 0
                mem[_6828 + 32] = 96
                mem[_6828 + 64] = 96
                mem[_6828 + 96] = 0
                mem[_6828 + 128] = 0
                mem[_6828 + 160] = 0
                mem[_6828 + 192] = 0
                mem[_6828 + 224] = 0
                require 1 < mem[_4410]
                if mem[_3569 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3569 + 96]
                    while idx >= 4:
                        if not mem[_3569 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3569 + 96] - idx
                        continue 
                    _13037 = mem[_3569 + 96]
                    _13038 = mem[_3569 + 128]
                    _13143 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13143] = 26
                    mem[_13143 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13037 - s):
                        _13447 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13447 + 68] = mem[idx + _13143 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13447 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13447 + -mem[64] + 100
                    _14893 = mem[_1807 + 96]
                    _14894 = mem[_1807 + 128]
                    _15021 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15021] = 26
                    mem[_15021 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14893 - s):
                        _15127 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15127 + 68] = mem[idx + _15021 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15127 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15127 + -mem[64] + 100
                    if not _14894 / 10^(_14893 - s):
                        _15511 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15511] = 26
                        mem[_15511 + 32] = 'SafeMath: division by zero'
                        if not _13038 / 10^(_13037 - s):
                            _15748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15748 + 68] = mem[idx + _15511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15748 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15748 + -mem[64] + 100
                        _16301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16301] = 26
                        mem[_16301 + 32] = 'SafeMath: division by zero'
                        if 0 / _13038 / 10^(_13037 - s):
                            return (1000000 * 10^18 / 0 / _13038 / 10^(_13037 - s))
                        _16517 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16517 + 68] = mem[idx + _16301 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16517 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16517 + -mem[64] + 100
                    if 10^12 * _14894 / 10^(_14893 - s) / _14894 / 10^(_14893 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15747 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15747] = 26
                    mem[_15747 + 32] = 'SafeMath: division by zero'
                    if not _13038 / 10^(_13037 - s):
                        _15917 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15917 + 68] = mem[idx + _15747 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15917 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15917 + -mem[64] + 100
                    _16515 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16515] = 26
                    mem[_16515 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14894 / 10^(_14893 - s) / _13038 / 10^(_13037 - s):
                        return (1000000 * 10^18 / 10^12 * _14894 / 10^(_14893 - s) / _13038 / 10^(_13037 - s))
                    _16685 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16685 + 68] = mem[idx + _16515 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16685 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16685 + -mem[64] + 100
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _13039 = mem[_3569 + 96]
                _13040 = mem[_3569 + 128]
                _13144 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13144] = 26
                mem[_13144 + 32] = 'SafeMath: division by zero'
                if not 10^(_13039 - s):
                    _13448 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13448 + 68] = mem[idx + _13144 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13448 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13448 + -mem[64] + 100
                _14895 = mem[_1807 + 96]
                _14896 = mem[_1807 + 128]
                _15023 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15023] = 26
                mem[_15023 + 32] = 'SafeMath: division by zero'
                if not 10^(_14895 - s):
                    _15128 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15128 + 68] = mem[idx + _15023 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15128 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15128 + -mem[64] + 100
                if not _14896 / 10^(_14895 - s):
                    _15512 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15512] = 26
                    mem[_15512 + 32] = 'SafeMath: division by zero'
                    if not _13040 / 10^(_13039 - s):
                        _15751 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15751 + 68] = mem[idx + _15512 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15751 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15751 + -mem[64] + 100
                    _16303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16303] = 26
                    mem[_16303 + 32] = 'SafeMath: division by zero'
                    if 0 / _13040 / 10^(_13039 - s):
                        return (1000000 * 10^18 / 0 / _13040 / 10^(_13039 - s))
                    _16520 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16520 + 68] = mem[idx + _16303 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16520 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16520 + -mem[64] + 100
                if 10^12 * _14896 / 10^(_14895 - s) / _14896 / 10^(_14895 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15750 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15750] = 26
                mem[_15750 + 32] = 'SafeMath: division by zero'
                if not _13040 / 10^(_13039 - s):
                    _15919 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15919 + 68] = mem[idx + _15750 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15919 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15919 + -mem[64] + 100
                _16518 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16518] = 26
                mem[_16518 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14896 / 10^(_14895 - s) / _13040 / 10^(_13039 - s):
                    return (1000000 * 10^18 / 10^12 * _14896 / 10^(_14895 - s) / _13040 / 10^(_13039 - s))
                _16687 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16687 + 68] = mem[idx + _16518 + 32]
                    idx = idx + 32
                    continue 
                mem[_16687 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16687 + -mem[64] + 100
            _4250 = mem[64]
            mem[mem[64]] = 2
            _5995 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5995] = 0
            mem[_5995 + 32] = 96
            mem[_5995 + 64] = 96
            mem[_5995 + 96] = 0
            mem[_5995 + 128] = 0
            mem[_5995 + 160] = 0
            mem[_5995 + 192] = 0
            mem[_5995 + 224] = 0
            mem[var196001] = _5995
            s = var196001
            idx = var196002
            while idx - 1:
                _5995 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5995] = 0
                mem[_5995 + 32] = 96
                mem[_5995 + 64] = 96
                mem[_5995 + 96] = 0
                mem[_5995 + 128] = 0
                mem[_5995 + 160] = 0
                mem[_5995 + 192] = 0
                mem[_5995 + 224] = 0
                mem[s + 32] = _5995
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4250]
            mem[_4250 + 32] = _1807
            require 1 < mem[_4250]
            mem[_4250 + 64] = _3569
            _6515 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6515] = 0
            mem[_6515 + 32] = 96
            mem[_6515 + 64] = 96
            mem[_6515 + 96] = 0
            mem[_6515 + 128] = 0
            mem[_6515 + 160] = 0
            mem[_6515 + 192] = 0
            mem[_6515 + 224] = 0
            require 0 < mem[_4250]
            _6827 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6827] = 0
            mem[_6827 + 32] = 96
            mem[_6827 + 64] = 96
            mem[_6827 + 96] = 0
            mem[_6827 + 128] = 0
            mem[_6827 + 160] = 0
            mem[_6827 + 192] = 0
            mem[_6827 + 224] = 0
            require 1 < mem[_4250]
            if mem[_1807 + 96] <= mem[_3569 + 96]:
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _13033 = mem[_1807 + 96]
                _13034 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13033 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3569 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3569 + 128] / 10^(mem[_3569 + 96] - s):
                    if not _13034 / 10^(_13033 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13034 / 10^(_13033 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13034 / 10^(_13033 - s))
                if 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13034 / 10^(_13033 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _13034 / 10^(_13033 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _13034 / 10^(_13033 - s))
            idx = 12
            s = mem[_3569 + 96]
            while idx >= 4:
                if not mem[_3569 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3569 + 96] - idx
                continue 
            _13035 = mem[_1807 + 96]
            _13036 = mem[_1807 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13035 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3569 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3569 + 128] / 10^(mem[_3569 + 96] - s):
                if not _13036 / 10^(_13035 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13036 / 10^(_13035 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13036 / 10^(_13035 - s))
            if 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13036 / 10^(_13035 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _13036 / 10^(_13035 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3569 + 128] / 10^(mem[_3569 + 96] - s) / _13036 / 10^(_13035 - s))
        mem[_1843 + ceil32(return_data.size) + _1851 + 32] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1827))
        staticcall address(_1827).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2662 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2670 = mem[_2662]
        require mem[_2662] <= test266151307()
        require _2662 + mem[_2662] + 31 < _2662 + return_data.size
        _2678 = mem[_2662 + mem[_2662]]
        require mem[_2662 + mem[_2662]] <= test266151307()
        require ceil32(mem[_2662 + mem[_2662]]) + 32 >= 0 and _2662 + ceil32(return_data.size) + ceil32(mem[_2662 + mem[_2662]]) + 32 <= test266151307()
        mem[64] = _2662 + ceil32(return_data.size) + ceil32(mem[_2662 + mem[_2662]]) + 32
        mem[_2662 + ceil32(return_data.size)] = _2678
        require _2670 + _2678 + 32 <= return_data.size
        mem[_2662 + ceil32(return_data.size) + 32 len ceil32(_2678)] = mem[_2662 + _2670 + 32 len ceil32(_2678)]
        if ceil32(_2678) <= _2678:
            require ext_code.size(address(_1827))
            staticcall address(_1827).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3460 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3476 = mem[_3460]
            require mem[_3460] == mem[_3460 + 31 len 1]
            require ext_code.size(address(_1827))
            staticcall address(_1827).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3524 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3540 = mem[_3524]
            _3551 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3551] = address(_1827)
            mem[_3551 + 32] = _1843 + ceil32(return_data.size)
            mem[_3551 + 64] = _2662 + ceil32(return_data.size)
            mem[_3551 + 96] = uint8(_3476)
            mem[_3551 + 128] = 0
            mem[_3551 + 160] = _3540
            mem[_3551 + 192] = 0
            mem[_3551 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3604 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3620 = mem[_3604]
            require mem[_3604] == mem[_3604 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3620))
            staticcall address(_3620).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3668 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1807 + 128] = mem[_3668]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3732 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3748 = mem[_3732]
            require mem[_3732] == mem[_3732 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3748))
            staticcall address(_3748).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3796 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3551 + 128] = mem[_3796]
            _3828 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3828] = 0
            mem[_3828 + 32] = 96
            mem[_3828 + 64] = 96
            mem[_3828 + 96] = 0
            mem[_3828 + 128] = 0
            mem[_3828 + 160] = 0
            mem[_3828 + 192] = 0
            mem[_3828 + 224] = 0
            _3844 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3844] = 0
            mem[_3844 + 32] = 96
            mem[_3844 + 64] = 96
            mem[_3844 + 96] = 0
            mem[_3844 + 128] = 0
            mem[_3844 + 160] = 0
            mem[_3844 + 192] = 0
            mem[_3844 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3887 = mem[64]
                mem[mem[64]] = 2
                _4956 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4956] = 0
                mem[_4956 + 32] = 96
                mem[_4956 + 64] = 96
                mem[_4956 + 96] = 0
                mem[_4956 + 128] = 0
                mem[_4956 + 160] = 0
                mem[_4956 + 192] = 0
                mem[_4956 + 224] = 0
                mem[var182001] = _4956
                s = var182001
                idx = var182002
                while idx - 1:
                    _4956 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4956] = 0
                    mem[_4956 + 32] = 96
                    mem[_4956 + 64] = 96
                    mem[_4956 + 96] = 0
                    mem[_4956 + 128] = 0
                    mem[_4956 + 160] = 0
                    mem[_4956 + 192] = 0
                    mem[_4956 + 224] = 0
                    mem[s + 32] = _4956
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3887]
                mem[_3887 + 32] = _3551
                require 1 < mem[_3887]
                mem[_3887 + 64] = _1807
                _5244 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5244] = 0
                mem[_5244 + 32] = 96
                mem[_5244 + 64] = 96
                mem[_5244 + 96] = 0
                mem[_5244 + 128] = 0
                mem[_5244 + 160] = 0
                mem[_5244 + 192] = 0
                mem[_5244 + 224] = 0
                require 0 < mem[_3887]
                _5514 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5514] = 0
                mem[_5514 + 32] = 96
                mem[_5514 + 64] = 96
                mem[_5514 + 96] = 0
                mem[_5514 + 128] = 0
                mem[_5514 + 160] = 0
                mem[_5514 + 192] = 0
                mem[_5514 + 224] = 0
                require 1 < mem[_3887]
                if mem[_3551 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3551 + 96]
                    while idx >= 4:
                        if not mem[_3551 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3551 + 96] - idx
                        continue 
                    _6171 = mem[_3551 + 96]
                    _6172 = mem[_3551 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6172 / 10^(_6171 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6172 / 10^(_6171 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6172 / 10^(_6171 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6172 / 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6172 / 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6172 / 10^(_6171 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6173 = mem[_3551 + 96]
                _6174 = mem[_3551 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6174 / 10^(_6173 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6174 / 10^(_6173 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6174 / 10^(_6173 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6174 / 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6174 / 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6174 / 10^(_6173 - s))
            if wbnbAddress == address(_1827):
                _3930 = mem[64]
                mem[mem[64]] = 2
                _4955 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4955] = 0
                mem[_4955 + 32] = 96
                mem[_4955 + 64] = 96
                mem[_4955 + 96] = 0
                mem[_4955 + 128] = 0
                mem[_4955 + 160] = 0
                mem[_4955 + 192] = 0
                mem[_4955 + 224] = 0
                mem[var185001] = _4955
                s = var185001
                idx = var185002
                while idx - 1:
                    _4955 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4955] = 0
                    mem[_4955 + 32] = 96
                    mem[_4955 + 64] = 96
                    mem[_4955 + 96] = 0
                    mem[_4955 + 128] = 0
                    mem[_4955 + 160] = 0
                    mem[_4955 + 192] = 0
                    mem[_4955 + 224] = 0
                    mem[s + 32] = _4955
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3930]
                mem[_3930 + 32] = _1807
                require 1 < mem[_3930]
                mem[_3930 + 64] = _3551
                _5243 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5243] = 0
                mem[_5243 + 32] = 96
                mem[_5243 + 64] = 96
                mem[_5243 + 96] = 0
                mem[_5243 + 128] = 0
                mem[_5243 + 160] = 0
                mem[_5243 + 192] = 0
                mem[_5243 + 224] = 0
                require 0 < mem[_3930]
                _5513 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5513] = 0
                mem[_5513 + 32] = 96
                mem[_5513 + 64] = 96
                mem[_5513 + 96] = 0
                mem[_5513 + 128] = 0
                mem[_5513 + 160] = 0
                mem[_5513 + 192] = 0
                mem[_5513 + 224] = 0
                require 1 < mem[_3930]
                if mem[_1807 + 96] <= mem[_3551 + 96]:
                    idx = 12
                    s = mem[_1807 + 96]
                    while idx >= 4:
                        if not mem[_1807 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1807 + 96] - idx
                        continue 
                    _6167 = mem[_1807 + 96]
                    _6168 = mem[_1807 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6167 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3551 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3551 + 128] / 10^(mem[_3551 + 96] - s):
                        if not _6168 / 10^(_6167 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6168 / 10^(_6167 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6168 / 10^(_6167 - s))
                    if 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6168 / 10^(_6167 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _6168 / 10^(_6167 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _6168 / 10^(_6167 - s))
                idx = 12
                s = mem[_3551 + 96]
                while idx >= 4:
                    if not mem[_3551 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3551 + 96] - idx
                    continue 
                _6169 = mem[_1807 + 96]
                _6170 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6169 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3551 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3551 + 128] / 10^(mem[_3551 + 96] - s):
                    if not _6170 / 10^(_6169 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6170 / 10^(_6169 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6170 / 10^(_6169 - s))
                if 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6170 / 10^(_6169 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _6170 / 10^(_6169 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _6170 / 10^(_6169 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3978 = mem[64]
                mem[mem[64]] = 2
                _4954 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4954] = 0
                mem[_4954 + 32] = 96
                mem[_4954 + 64] = 96
                mem[_4954 + 96] = 0
                mem[_4954 + 128] = 0
                mem[_4954 + 160] = 0
                mem[_4954 + 192] = 0
                mem[_4954 + 224] = 0
                mem[var188001] = _4954
                s = var188001
                idx = var188002
                while idx - 1:
                    _4954 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4954] = 0
                    mem[_4954 + 32] = 96
                    mem[_4954 + 64] = 96
                    mem[_4954 + 96] = 0
                    mem[_4954 + 128] = 0
                    mem[_4954 + 160] = 0
                    mem[_4954 + 192] = 0
                    mem[_4954 + 224] = 0
                    mem[s + 32] = _4954
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3978]
                mem[_3978 + 32] = _3551
                require 1 < mem[_3978]
                mem[_3978 + 64] = _1807
                _5242 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5242] = 0
                mem[_5242 + 32] = 96
                mem[_5242 + 64] = 96
                mem[_5242 + 96] = 0
                mem[_5242 + 128] = 0
                mem[_5242 + 160] = 0
                mem[_5242 + 192] = 0
                mem[_5242 + 224] = 0
                require 0 < mem[_3978]
                _5512 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5512] = 0
                mem[_5512 + 32] = 96
                mem[_5512 + 64] = 96
                mem[_5512 + 96] = 0
                mem[_5512 + 128] = 0
                mem[_5512 + 160] = 0
                mem[_5512 + 192] = 0
                mem[_5512 + 224] = 0
                require 1 < mem[_3978]
                if mem[_3551 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3551 + 96]
                    while idx >= 4:
                        if not mem[_3551 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3551 + 96] - idx
                        continue 
                    _6163 = mem[_3551 + 96]
                    _6164 = mem[_3551 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6163 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6164 / 10^(_6163 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6164 / 10^(_6163 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6164 / 10^(_6163 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6164 / 10^(_6163 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6164 / 10^(_6163 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6164 / 10^(_6163 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6165 = mem[_3551 + 96]
                _6166 = mem[_3551 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6165 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6166 / 10^(_6165 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6166 / 10^(_6165 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6166 / 10^(_6165 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6166 / 10^(_6165 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6166 / 10^(_6165 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6166 / 10^(_6165 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4026 = mem[64]
                mem[mem[64]] = 2
                _4953 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4953] = 0
                mem[_4953 + 32] = 96
                mem[_4953 + 64] = 96
                mem[_4953 + 96] = 0
                mem[_4953 + 128] = 0
                mem[_4953 + 160] = 0
                mem[_4953 + 192] = 0
                mem[_4953 + 224] = 0
                mem[var191001] = _4953
                s = var191001
                idx = var191002
                while idx - 1:
                    _4953 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4953] = 0
                    mem[_4953 + 32] = 96
                    mem[_4953 + 64] = 96
                    mem[_4953 + 96] = 0
                    mem[_4953 + 128] = 0
                    mem[_4953 + 160] = 0
                    mem[_4953 + 192] = 0
                    mem[_4953 + 224] = 0
                    mem[s + 32] = _4953
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4026]
                mem[_4026 + 32] = _3551
                require 1 < mem[_4026]
                mem[_4026 + 64] = _1807
                _5241 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5241] = 0
                mem[_5241 + 32] = 96
                mem[_5241 + 64] = 96
                mem[_5241 + 96] = 0
                mem[_5241 + 128] = 0
                mem[_5241 + 160] = 0
                mem[_5241 + 192] = 0
                mem[_5241 + 224] = 0
                require 0 < mem[_4026]
                _5511 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5511] = 0
                mem[_5511 + 32] = 96
                mem[_5511 + 64] = 96
                mem[_5511 + 96] = 0
                mem[_5511 + 128] = 0
                mem[_5511 + 160] = 0
                mem[_5511 + 192] = 0
                mem[_5511 + 224] = 0
                require 1 < mem[_4026]
                if mem[_3551 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3551 + 96]
                    while idx >= 4:
                        if not mem[_3551 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3551 + 96] - idx
                        continue 
                    _6159 = mem[_3551 + 96]
                    _6160 = mem[_3551 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6159 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1807 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                        if not _6160 / 10^(_6159 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6160 / 10^(_6159 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6160 / 10^(_6159 - s))
                    if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6160 / 10^(_6159 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6160 / 10^(_6159 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6160 / 10^(_6159 - s))
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6161 = mem[_3551 + 96]
                _6162 = mem[_3551 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6161 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6162 / 10^(_6161 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6162 / 10^(_6161 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6162 / 10^(_6161 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6162 / 10^(_6161 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6162 / 10^(_6161 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6162 / 10^(_6161 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4415 = mem[64]
                mem[mem[64]] = 2
                _5998 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5998] = 0
                mem[_5998 + 32] = 96
                mem[_5998 + 64] = 96
                mem[_5998 + 96] = 0
                mem[_5998 + 128] = 0
                mem[_5998 + 160] = 0
                mem[_5998 + 192] = 0
                mem[_5998 + 224] = 0
                mem[var200001] = _5998
                s = var200001
                idx = var200002
                while idx - 1:
                    _5998 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5998] = 0
                    mem[_5998 + 32] = 96
                    mem[_5998 + 64] = 96
                    mem[_5998 + 96] = 0
                    mem[_5998 + 128] = 0
                    mem[_5998 + 160] = 0
                    mem[_5998 + 192] = 0
                    mem[_5998 + 224] = 0
                    mem[s + 32] = _5998
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4415]
                mem[_4415 + 32] = _3551
                require 1 < mem[_4415]
                mem[_4415 + 64] = _1807
                _6526 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6526] = 0
                mem[_6526 + 32] = 96
                mem[_6526 + 64] = 96
                mem[_6526 + 96] = 0
                mem[_6526 + 128] = 0
                mem[_6526 + 160] = 0
                mem[_6526 + 192] = 0
                mem[_6526 + 224] = 0
                require 0 < mem[_4415]
                _6830 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6830] = 0
                mem[_6830 + 32] = 96
                mem[_6830 + 64] = 96
                mem[_6830 + 96] = 0
                mem[_6830 + 128] = 0
                mem[_6830 + 160] = 0
                mem[_6830 + 192] = 0
                mem[_6830 + 224] = 0
                require 1 < mem[_4415]
                if mem[_3551 + 96] <= mem[_1807 + 96]:
                    idx = 12
                    s = mem[_3551 + 96]
                    while idx >= 4:
                        if not mem[_3551 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3551 + 96] - idx
                        continue 
                    _13045 = mem[_3551 + 96]
                    _13046 = mem[_3551 + 128]
                    _13147 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13147] = 26
                    mem[_13147 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13045 - s):
                        _13499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13499 + 68] = mem[idx + _13147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13499 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13499 + -mem[64] + 100
                    _14901 = mem[_1807 + 96]
                    _14902 = mem[_1807 + 128]
                    _15029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15029] = 26
                    mem[_15029 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14901 - s):
                        _15131 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15131 + 68] = mem[idx + _15029 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15131 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15131 + -mem[64] + 100
                    if not _14902 / 10^(_14901 - s):
                        _15515 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15515] = 26
                        mem[_15515 + 32] = 'SafeMath: division by zero'
                        if not _13046 / 10^(_13045 - s):
                            _15760 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15760 + 68] = mem[idx + _15515 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15760 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15760 + -mem[64] + 100
                        _16309 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16309] = 26
                        mem[_16309 + 32] = 'SafeMath: division by zero'
                        if 0 / _13046 / 10^(_13045 - s):
                            return (1000000 * 10^18 / 0 / _13046 / 10^(_13045 - s))
                        _16529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16529 + 68] = mem[idx + _16309 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16529 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16529 + -mem[64] + 100
                    if 10^12 * _14902 / 10^(_14901 - s) / _14902 / 10^(_14901 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15759 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15759] = 26
                    mem[_15759 + 32] = 'SafeMath: division by zero'
                    if not _13046 / 10^(_13045 - s):
                        _15925 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15925 + 68] = mem[idx + _15759 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15925 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15925 + -mem[64] + 100
                    _16527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16527] = 26
                    mem[_16527 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14902 / 10^(_14901 - s) / _13046 / 10^(_13045 - s):
                        return (1000000 * 10^18 / 10^12 * _14902 / 10^(_14901 - s) / _13046 / 10^(_13045 - s))
                    _16693 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16693 + 68] = mem[idx + _16527 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16693 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16693 + -mem[64] + 100
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _13047 = mem[_3551 + 96]
                _13048 = mem[_3551 + 128]
                _13148 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13148] = 26
                mem[_13148 + 32] = 'SafeMath: division by zero'
                if not 10^(_13047 - s):
                    _13500 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13500 + 68] = mem[idx + _13148 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13500 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13500 + -mem[64] + 100
                _14903 = mem[_1807 + 96]
                _14904 = mem[_1807 + 128]
                _15031 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15031] = 26
                mem[_15031 + 32] = 'SafeMath: division by zero'
                if not 10^(_14903 - s):
                    _15132 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15132 + 68] = mem[idx + _15031 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15132 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15132 + -mem[64] + 100
                if not _14904 / 10^(_14903 - s):
                    _15516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15516] = 26
                    mem[_15516 + 32] = 'SafeMath: division by zero'
                    if not _13048 / 10^(_13047 - s):
                        _15763 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15763 + 68] = mem[idx + _15516 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15763 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15763 + -mem[64] + 100
                    _16311 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16311] = 26
                    mem[_16311 + 32] = 'SafeMath: division by zero'
                    if 0 / _13048 / 10^(_13047 - s):
                        return (1000000 * 10^18 / 0 / _13048 / 10^(_13047 - s))
                    _16532 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16532 + 68] = mem[idx + _16311 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16532 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16532 + -mem[64] + 100
                if 10^12 * _14904 / 10^(_14903 - s) / _14904 / 10^(_14903 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15762 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15762] = 26
                mem[_15762 + 32] = 'SafeMath: division by zero'
                if not _13048 / 10^(_13047 - s):
                    _15927 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15927 + 68] = mem[idx + _15762 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15927 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15927 + -mem[64] + 100
                _16530 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16530] = 26
                mem[_16530 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14904 / 10^(_14903 - s) / _13048 / 10^(_13047 - s):
                    return (1000000 * 10^18 / 10^12 * _14904 / 10^(_14903 - s) / _13048 / 10^(_13047 - s))
                _16695 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16695 + 68] = mem[idx + _16530 + 32]
                    idx = idx + 32
                    continue 
                mem[_16695 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16695 + -mem[64] + 100
            _4255 = mem[64]
            mem[mem[64]] = 2
            _5997 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5997] = 0
            mem[_5997 + 32] = 96
            mem[_5997 + 64] = 96
            mem[_5997 + 96] = 0
            mem[_5997 + 128] = 0
            mem[_5997 + 160] = 0
            mem[_5997 + 192] = 0
            mem[_5997 + 224] = 0
            mem[var196001] = _5997
            s = var196001
            idx = var196002
            while idx - 1:
                _5997 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5997] = 0
                mem[_5997 + 32] = 96
                mem[_5997 + 64] = 96
                mem[_5997 + 96] = 0
                mem[_5997 + 128] = 0
                mem[_5997 + 160] = 0
                mem[_5997 + 192] = 0
                mem[_5997 + 224] = 0
                mem[s + 32] = _5997
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4255]
            mem[_4255 + 32] = _1807
            require 1 < mem[_4255]
            mem[_4255 + 64] = _3551
            _6525 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6525] = 0
            mem[_6525 + 32] = 96
            mem[_6525 + 64] = 96
            mem[_6525 + 96] = 0
            mem[_6525 + 128] = 0
            mem[_6525 + 160] = 0
            mem[_6525 + 192] = 0
            mem[_6525 + 224] = 0
            require 0 < mem[_4255]
            _6829 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6829] = 0
            mem[_6829 + 32] = 96
            mem[_6829 + 64] = 96
            mem[_6829 + 96] = 0
            mem[_6829 + 128] = 0
            mem[_6829 + 160] = 0
            mem[_6829 + 192] = 0
            mem[_6829 + 224] = 0
            require 1 < mem[_4255]
            if mem[_1807 + 96] <= mem[_3551 + 96]:
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _13041 = mem[_1807 + 96]
                _13042 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13041 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3551 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3551 + 128] / 10^(mem[_3551 + 96] - s):
                    if not _13042 / 10^(_13041 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13042 / 10^(_13041 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13042 / 10^(_13041 - s))
                if 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13042 / 10^(_13041 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _13042 / 10^(_13041 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _13042 / 10^(_13041 - s))
            idx = 12
            s = mem[_3551 + 96]
            while idx >= 4:
                if not mem[_3551 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3551 + 96] - idx
                continue 
            _13043 = mem[_1807 + 96]
            _13044 = mem[_1807 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13043 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3551 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3551 + 128] / 10^(mem[_3551 + 96] - s):
                if not _13044 / 10^(_13043 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13044 / 10^(_13043 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13044 / 10^(_13043 - s))
            if 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13044 / 10^(_13043 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _13044 / 10^(_13043 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3551 + 128] / 10^(mem[_3551 + 96] - s) / _13044 / 10^(_13043 - s))
        mem[_2662 + ceil32(return_data.size) + _2678 + 32] = 0
        require ext_code.size(address(_1827))
        staticcall address(_1827).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3468 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3484 = mem[_3468]
        require mem[_3468] == mem[_3468 + 31 len 1]
        require ext_code.size(address(_1827))
        staticcall address(_1827).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3532 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3552 = mem[_3532]
        _3572 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3572] = address(_1827)
        mem[_3572 + 32] = _1843 + ceil32(return_data.size)
        mem[_3572 + 64] = _2662 + ceil32(return_data.size)
        mem[_3572 + 96] = uint8(_3484)
        mem[_3572 + 128] = 0
        mem[_3572 + 160] = _3552
        mem[_3572 + 192] = 0
        mem[_3572 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3612 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3628 = mem[_3612]
        require mem[_3612] == mem[_3612 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3628))
        staticcall address(_3628).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3676 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1807 + 128] = mem[_3676]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3740 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3756 = mem[_3740]
        require mem[_3740] == mem[_3740 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3756))
        staticcall address(_3756).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3804 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3572 + 128] = mem[_3804]
        _3836 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3836] = 0
        mem[_3836 + 32] = 96
        mem[_3836 + 64] = 96
        mem[_3836 + 96] = 0
        mem[_3836 + 128] = 0
        mem[_3836 + 160] = 0
        mem[_3836 + 192] = 0
        mem[_3836 + 224] = 0
        _3856 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3856] = 0
        mem[_3856 + 32] = 96
        mem[_3856 + 64] = 96
        mem[_3856 + 96] = 0
        mem[_3856 + 128] = 0
        mem[_3856 + 160] = 0
        mem[_3856 + 192] = 0
        mem[_3856 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3900 = mem[64]
            mem[mem[64]] = 2
            _4960 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4960] = 0
            mem[_4960 + 32] = 96
            mem[_4960 + 64] = 96
            mem[_4960 + 96] = 0
            mem[_4960 + 128] = 0
            mem[_4960 + 160] = 0
            mem[_4960 + 192] = 0
            mem[_4960 + 224] = 0
            mem[var183001] = _4960
            s = var183001
            idx = var183002
            while idx - 1:
                _4960 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4960] = 0
                mem[_4960 + 32] = 96
                mem[_4960 + 64] = 96
                mem[_4960 + 96] = 0
                mem[_4960 + 128] = 0
                mem[_4960 + 160] = 0
                mem[_4960 + 192] = 0
                mem[_4960 + 224] = 0
                mem[s + 32] = _4960
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3900]
            mem[_3900 + 32] = _3572
            require 1 < mem[_3900]
            mem[_3900 + 64] = _1807
            _5248 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5248] = 0
            mem[_5248 + 32] = 96
            mem[_5248 + 64] = 96
            mem[_5248 + 96] = 0
            mem[_5248 + 128] = 0
            mem[_5248 + 160] = 0
            mem[_5248 + 192] = 0
            mem[_5248 + 224] = 0
            require 0 < mem[_3900]
            _5520 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5520] = 0
            mem[_5520 + 32] = 96
            mem[_5520 + 64] = 96
            mem[_5520 + 96] = 0
            mem[_5520 + 128] = 0
            mem[_5520 + 160] = 0
            mem[_5520 + 192] = 0
            mem[_5520 + 224] = 0
            require 1 < mem[_3900]
            if mem[_3572 + 96] <= mem[_1807 + 96]:
                idx = 12
                s = mem[_3572 + 96]
                while idx >= 4:
                    if not mem[_3572 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3572 + 96] - idx
                    continue 
                _6189 = mem[_3572 + 96]
                _6190 = mem[_3572 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6190 / 10^(_6189 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6190 / 10^(_6189 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6190 / 10^(_6189 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6190 / 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6190 / 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6190 / 10^(_6189 - s))
            idx = 12
            s = mem[_1807 + 96]
            while idx >= 4:
                if not mem[_1807 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1807 + 96] - idx
                continue 
            _6191 = mem[_3572 + 96]
            _6192 = mem[_3572 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1807 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                if not _6192 / 10^(_6191 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6192 / 10^(_6191 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6192 / 10^(_6191 - s))
            if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6192 / 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6192 / 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6192 / 10^(_6191 - s))
        if wbnbAddress == address(_1827):
            _3948 = mem[64]
            mem[mem[64]] = 2
            _4959 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4959] = 0
            mem[_4959 + 32] = 96
            mem[_4959 + 64] = 96
            mem[_4959 + 96] = 0
            mem[_4959 + 128] = 0
            mem[_4959 + 160] = 0
            mem[_4959 + 192] = 0
            mem[_4959 + 224] = 0
            mem[var186001] = _4959
            s = var186001
            idx = var186002
            while idx - 1:
                _4959 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4959] = 0
                mem[_4959 + 32] = 96
                mem[_4959 + 64] = 96
                mem[_4959 + 96] = 0
                mem[_4959 + 128] = 0
                mem[_4959 + 160] = 0
                mem[_4959 + 192] = 0
                mem[_4959 + 224] = 0
                mem[s + 32] = _4959
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3948]
            mem[_3948 + 32] = _1807
            require 1 < mem[_3948]
            mem[_3948 + 64] = _3572
            _5247 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5247] = 0
            mem[_5247 + 32] = 96
            mem[_5247 + 64] = 96
            mem[_5247 + 96] = 0
            mem[_5247 + 128] = 0
            mem[_5247 + 160] = 0
            mem[_5247 + 192] = 0
            mem[_5247 + 224] = 0
            require 0 < mem[_3948]
            _5519 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5519] = 0
            mem[_5519 + 32] = 96
            mem[_5519 + 64] = 96
            mem[_5519 + 96] = 0
            mem[_5519 + 128] = 0
            mem[_5519 + 160] = 0
            mem[_5519 + 192] = 0
            mem[_5519 + 224] = 0
            require 1 < mem[_3948]
            if mem[_1807 + 96] <= mem[_3572 + 96]:
                idx = 12
                s = mem[_1807 + 96]
                while idx >= 4:
                    if not mem[_1807 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1807 + 96] - idx
                    continue 
                _6185 = mem[_1807 + 96]
                _6186 = mem[_1807 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3572 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3572 + 128] / 10^(mem[_3572 + 96] - s):
                    if not _6186 / 10^(_6185 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6186 / 10^(_6185 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6186 / 10^(_6185 - s))
                if 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6186 / 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _6186 / 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _6186 / 10^(_6185 - s))
            idx = 12
            s = mem[_3572 + 96]
            while idx >= 4:
                if not mem[_3572 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3572 + 96] - idx
                continue 
            _6187 = mem[_1807 + 96]
            _6188 = mem[_1807 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6187 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3572 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3572 + 128] / 10^(mem[_3572 + 96] - s):
                if not _6188 / 10^(_6187 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6188 / 10^(_6187 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6188 / 10^(_6187 - s))
            if 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6188 / 10^(_6187 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _6188 / 10^(_6187 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _6188 / 10^(_6187 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3996 = mem[64]
            mem[mem[64]] = 2
            _4958 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4958] = 0
            mem[_4958 + 32] = 96
            mem[_4958 + 64] = 96
            mem[_4958 + 96] = 0
            mem[_4958 + 128] = 0
            mem[_4958 + 160] = 0
            mem[_4958 + 192] = 0
            mem[_4958 + 224] = 0
            mem[var189001] = _4958
            s = var189001
            idx = var189002
            while idx - 1:
                _4958 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4958] = 0
                mem[_4958 + 32] = 96
                mem[_4958 + 64] = 96
                mem[_4958 + 96] = 0
                mem[_4958 + 128] = 0
                mem[_4958 + 160] = 0
                mem[_4958 + 192] = 0
                mem[_4958 + 224] = 0
                mem[s + 32] = _4958
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3996]
            mem[_3996 + 32] = _3572
            require 1 < mem[_3996]
            mem[_3996 + 64] = _1807
            _5246 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5246] = 0
            mem[_5246 + 32] = 96
            mem[_5246 + 64] = 96
            mem[_5246 + 96] = 0
            mem[_5246 + 128] = 0
            mem[_5246 + 160] = 0
            mem[_5246 + 192] = 0
            mem[_5246 + 224] = 0
            require 0 < mem[_3996]
            _5518 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5518] = 0
            mem[_5518 + 32] = 96
            mem[_5518 + 64] = 96
            mem[_5518 + 96] = 0
            mem[_5518 + 128] = 0
            mem[_5518 + 160] = 0
            mem[_5518 + 192] = 0
            mem[_5518 + 224] = 0
            require 1 < mem[_3996]
            if mem[_3572 + 96] <= mem[_1807 + 96]:
                idx = 12
                s = mem[_3572 + 96]
                while idx >= 4:
                    if not mem[_3572 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3572 + 96] - idx
                    continue 
                _6181 = mem[_3572 + 96]
                _6182 = mem[_3572 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6182 / 10^(_6181 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6182 / 10^(_6181 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6182 / 10^(_6181 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6182 / 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6182 / 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6182 / 10^(_6181 - s))
            idx = 12
            s = mem[_1807 + 96]
            while idx >= 4:
                if not mem[_1807 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1807 + 96] - idx
                continue 
            _6183 = mem[_3572 + 96]
            _6184 = mem[_3572 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6183 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1807 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                if not _6184 / 10^(_6183 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6184 / 10^(_6183 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6184 / 10^(_6183 - s))
            if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6184 / 10^(_6183 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6184 / 10^(_6183 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6184 / 10^(_6183 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4044 = mem[64]
            mem[mem[64]] = 2
            _4957 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4957] = 0
            mem[_4957 + 32] = 96
            mem[_4957 + 64] = 96
            mem[_4957 + 96] = 0
            mem[_4957 + 128] = 0
            mem[_4957 + 160] = 0
            mem[_4957 + 192] = 0
            mem[_4957 + 224] = 0
            mem[var192001] = _4957
            s = var192001
            idx = var192002
            while idx - 1:
                _4957 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4957] = 0
                mem[_4957 + 32] = 96
                mem[_4957 + 64] = 96
                mem[_4957 + 96] = 0
                mem[_4957 + 128] = 0
                mem[_4957 + 160] = 0
                mem[_4957 + 192] = 0
                mem[_4957 + 224] = 0
                mem[s + 32] = _4957
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4044]
            mem[_4044 + 32] = _3572
            require 1 < mem[_4044]
            mem[_4044 + 64] = _1807
            _5245 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5245] = 0
            mem[_5245 + 32] = 96
            mem[_5245 + 64] = 96
            mem[_5245 + 96] = 0
            mem[_5245 + 128] = 0
            mem[_5245 + 160] = 0
            mem[_5245 + 192] = 0
            mem[_5245 + 224] = 0
            require 0 < mem[_4044]
            _5517 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5517] = 0
            mem[_5517 + 32] = 96
            mem[_5517 + 64] = 96
            mem[_5517 + 96] = 0
            mem[_5517 + 128] = 0
            mem[_5517 + 160] = 0
            mem[_5517 + 192] = 0
            mem[_5517 + 224] = 0
            require 1 < mem[_4044]
            if mem[_3572 + 96] <= mem[_1807 + 96]:
                idx = 12
                s = mem[_3572 + 96]
                while idx >= 4:
                    if not mem[_3572 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3572 + 96] - idx
                    continue 
                _6177 = mem[_3572 + 96]
                _6178 = mem[_3572 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1807 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                    if not _6178 / 10^(_6177 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6178 / 10^(_6177 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6178 / 10^(_6177 - s))
                if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6178 / 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6178 / 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6178 / 10^(_6177 - s))
            idx = 12
            s = mem[_1807 + 96]
            while idx >= 4:
                if not mem[_1807 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1807 + 96] - idx
                continue 
            _6179 = mem[_3572 + 96]
            _6180 = mem[_3572 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6179 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1807 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1807 + 128] / 10^(mem[_1807 + 96] - s):
                if not _6180 / 10^(_6179 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6180 / 10^(_6179 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6180 / 10^(_6179 - s))
            if 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6180 / 10^(_6179 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6180 / 10^(_6179 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1807 + 128] / 10^(mem[_1807 + 96] - s) / _6180 / 10^(_6179 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4420 = mem[64]
            mem[mem[64]] = 2
            _6000 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6000] = 0
            mem[_6000 + 32] = 96
            mem[_6000 + 64] = 96
            mem[_6000 + 96] = 0
            mem[_6000 + 128] = 0
            mem[_6000 + 160] = 0
            mem[_6000 + 192] = 0
            mem[_6000 + 224] = 0
            mem[var201001] = _6000
            s = var201001
            idx = var201002
            while idx - 1:
                _6000 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6000] = 0
                mem[_6000 + 32] = 96
                mem[_6000 + 64] = 96
                mem[_6000 + 96] = 0
                mem[_6000 + 128] = 0
                mem[_6000 + 160] = 0
                mem[_6000 + 192] = 0
                mem[_6000 + 224] = 0
                mem[s + 32] = _6000
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4420]
            mem[_4420 + 32] = _3572
            require 1 < mem[_4420]
            mem[_4420 + 64] = _1807
            _6536 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6536] = 0
            mem[_6536 + 32] = 96
            mem[_6536 + 64] = 96
            mem[_6536 + 96] = 0
            mem[_6536 + 128] = 0
            mem[_6536 + 160] = 0
            mem[_6536 + 192] = 0
            mem[_6536 + 224] = 0
            require 0 < mem[_4420]
            _6832 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6832] = 0
            mem[_6832 + 32] = 96
            mem[_6832 + 64] = 96
            mem[_6832 + 96] = 0
            mem[_6832 + 128] = 0
            mem[_6832 + 160] = 0
            mem[_6832 + 192] = 0
            mem[_6832 + 224] = 0
            require 1 < mem[_4420]
            if mem[_3572 + 96] <= mem[_1807 + 96]:
                idx = 12
                s = mem[_3572 + 96]
                while idx >= 4:
                    if not mem[_3572 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3572 + 96] - idx
                    continue 
                _13053 = mem[_3572 + 96]
                _13054 = mem[_3572 + 128]
                _13151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13151] = 26
                mem[_13151 + 32] = 'SafeMath: division by zero'
                if not 10^(_13053 - s):
                    _13551 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13551 + 68] = mem[idx + _13151 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13551 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13551 + -mem[64] + 100
                _14909 = mem[_1807 + 96]
                _14910 = mem[_1807 + 128]
                _15037 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15037] = 26
                mem[_15037 + 32] = 'SafeMath: division by zero'
                if not 10^(_14909 - s):
                    _15135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15135 + 68] = mem[idx + _15037 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15135 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15135 + -mem[64] + 100
                if not _14910 / 10^(_14909 - s):
                    _15519 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15519] = 26
                    mem[_15519 + 32] = 'SafeMath: division by zero'
                    if not _13054 / 10^(_13053 - s):
                        _15772 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15772 + 68] = mem[idx + _15519 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15772 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15772 + -mem[64] + 100
                    _16317 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16317] = 26
                    mem[_16317 + 32] = 'SafeMath: division by zero'
                    if 0 / _13054 / 10^(_13053 - s):
                        return (1000000 * 10^18 / 0 / _13054 / 10^(_13053 - s))
                    _16541 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16541 + 68] = mem[idx + _16317 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16541 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16541 + -mem[64] + 100
                if 10^12 * _14910 / 10^(_14909 - s) / _14910 / 10^(_14909 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15771 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15771] = 26
                mem[_15771 + 32] = 'SafeMath: division by zero'
                if not _13054 / 10^(_13053 - s):
                    _15933 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15933 + 68] = mem[idx + _15771 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15933 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15933 + -mem[64] + 100
                _16539 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16539] = 26
                mem[_16539 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14910 / 10^(_14909 - s) / _13054 / 10^(_13053 - s):
                    return (1000000 * 10^18 / 10^12 * _14910 / 10^(_14909 - s) / _13054 / 10^(_13053 - s))
                _16701 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16701 + 68] = mem[idx + _16539 + 32]
                    idx = idx + 32
                    continue 
                mem[_16701 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16701 + -mem[64] + 100
            idx = 12
            s = mem[_1807 + 96]
            while idx >= 4:
                if not mem[_1807 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1807 + 96] - idx
                continue 
            _13055 = mem[_3572 + 96]
            _13056 = mem[_3572 + 128]
            _13152 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13152] = 26
            mem[_13152 + 32] = 'SafeMath: division by zero'
            if not 10^(_13055 - s):
                _13552 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13552 + 68] = mem[idx + _13152 + 32]
                    idx = idx + 32
                    continue 
                mem[_13552 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13552 + -mem[64] + 100
            _14911 = mem[_1807 + 96]
            _14912 = mem[_1807 + 128]
            _15039 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15039] = 26
            mem[_15039 + 32] = 'SafeMath: division by zero'
            if not 10^(_14911 - s):
                _15136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15136 + 68] = mem[idx + _15039 + 32]
                    idx = idx + 32
                    continue 
                mem[_15136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15136 + -mem[64] + 100
            if not _14912 / 10^(_14911 - s):
                _15520 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15520] = 26
                mem[_15520 + 32] = 'SafeMath: division by zero'
                if not _13056 / 10^(_13055 - s):
                    _15775 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15775 + 68] = mem[idx + _15520 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15775 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15775 + -mem[64] + 100
                _16319 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16319] = 26
                mem[_16319 + 32] = 'SafeMath: division by zero'
                if 0 / _13056 / 10^(_13055 - s):
                    return (1000000 * 10^18 / 0 / _13056 / 10^(_13055 - s))
                _16544 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16544 + 68] = mem[idx + _16319 + 32]
                    idx = idx + 32
                    continue 
                mem[_16544 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16544 + -mem[64] + 100
            if 10^12 * _14912 / 10^(_14911 - s) / _14912 / 10^(_14911 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15774 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15774] = 26
            mem[_15774 + 32] = 'SafeMath: division by zero'
            if not _13056 / 10^(_13055 - s):
                _15935 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15935 + 68] = mem[idx + _15774 + 32]
                    idx = idx + 32
                    continue 
                mem[_15935 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15935 + -mem[64] + 100
            _16542 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16542] = 26
            mem[_16542 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14912 / 10^(_14911 - s) / _13056 / 10^(_13055 - s):
                return (1000000 * 10^18 / 10^12 * _14912 / 10^(_14911 - s) / _13056 / 10^(_13055 - s))
            _16703 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16703 + 68] = mem[idx + _16542 + 32]
                idx = idx + 32
                continue 
            mem[_16703 + 94] = 0
            revert with memory
              from mem[64]
               len _16703 + -mem[64] + 100
        _4260 = mem[64]
        mem[mem[64]] = 2
        _5999 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5999] = 0
        mem[_5999 + 32] = 96
        mem[_5999 + 64] = 96
        mem[_5999 + 96] = 0
        mem[_5999 + 128] = 0
        mem[_5999 + 160] = 0
        mem[_5999 + 192] = 0
        mem[_5999 + 224] = 0
        mem[var197001] = _5999
        s = var197001
        idx = var197002
        while idx - 1:
            _5999 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5999] = 0
            mem[_5999 + 32] = 96
            mem[_5999 + 64] = 96
            mem[_5999 + 96] = 0
            mem[_5999 + 128] = 0
            mem[_5999 + 160] = 0
            mem[_5999 + 192] = 0
            mem[_5999 + 224] = 0
            mem[s + 32] = _5999
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4260]
        mem[_4260 + 32] = _1807
        require 1 < mem[_4260]
        mem[_4260 + 64] = _3572
        _6535 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6535] = 0
        mem[_6535 + 32] = 96
        mem[_6535 + 64] = 96
        mem[_6535 + 96] = 0
        mem[_6535 + 128] = 0
        mem[_6535 + 160] = 0
        mem[_6535 + 192] = 0
        mem[_6535 + 224] = 0
        require 0 < mem[_4260]
        _6831 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6831] = 0
        mem[_6831 + 32] = 96
        mem[_6831 + 64] = 96
        mem[_6831 + 96] = 0
        mem[_6831 + 128] = 0
        mem[_6831 + 160] = 0
        mem[_6831 + 192] = 0
        mem[_6831 + 224] = 0
        require 1 < mem[_4260]
        if mem[_1807 + 96] <= mem[_3572 + 96]:
            idx = 12
            s = mem[_1807 + 96]
            while idx >= 4:
                if not mem[_1807 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1807 + 96] - idx
                continue 
            _13049 = mem[_1807 + 96]
            _13050 = mem[_1807 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13049 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3572 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3572 + 128] / 10^(mem[_3572 + 96] - s):
                if not _13050 / 10^(_13049 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13050 / 10^(_13049 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13050 / 10^(_13049 - s))
            if 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13050 / 10^(_13049 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _13050 / 10^(_13049 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _13050 / 10^(_13049 - s))
        idx = 12
        s = mem[_3572 + 96]
        while idx >= 4:
            if not mem[_3572 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3572 + 96] - idx
            continue 
        _13051 = mem[_1807 + 96]
        _13052 = mem[_1807 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13051 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3572 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3572 + 128] / 10^(mem[_3572 + 96] - s):
            if not _13052 / 10^(_13051 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13052 / 10^(_13051 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13052 / 10^(_13051 - s))
        if 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13052 / 10^(_13051 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _13052 / 10^(_13051 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3572 + 128] / 10^(mem[_3572 + 96] - s) / _13052 / 10^(_13051 - s))
    mem[(2 * ceil32(return_data.size)) + _11 + 640] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _898 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _900 = mem[_898]
    require mem[_898] <= test266151307()
    require _898 + mem[_898] + 31 < _898 + return_data.size
    _902 = mem[_898 + mem[_898]]
    require mem[_898 + mem[_898]] <= test266151307()
    require ceil32(mem[_898 + mem[_898]]) + 32 >= 0 and _898 + ceil32(return_data.size) + ceil32(mem[_898 + mem[_898]]) + 32 <= test266151307()
    mem[64] = _898 + ceil32(return_data.size) + ceil32(mem[_898 + mem[_898]]) + 32
    mem[_898 + ceil32(return_data.size)] = _902
    require _900 + _902 + 32 <= return_data.size
    mem[_898 + ceil32(return_data.size) + 32 len ceil32(_902)] = mem[_898 + _900 + 32 len ceil32(_902)]
    if ceil32(_902) <= _902:
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1782 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1786 = mem[_1782]
        require mem[_1782] == mem[_1782 + 31 len 1]
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1798 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1802 = mem[_1798]
        _1805 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1805] = address(ext_call.return_data[0])
        mem[_1805 + 32] = (2 * ceil32(return_data.size)) + 608
        mem[_1805 + 64] = _898 + ceil32(return_data.size)
        mem[_1805 + 96] = uint8(_1786)
        mem[_1805 + 128] = 0
        mem[_1805 + 160] = _1802
        mem[_1805 + 192] = 0
        mem[_1805 + 224] = 0
        _1810 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1810] = 0
        mem[_1810 + 32] = 96
        mem[_1810 + 64] = 96
        mem[_1810 + 96] = 0
        mem[_1810 + 128] = 0
        mem[_1810 + 160] = 0
        mem[_1810 + 192] = 0
        mem[_1810 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1822 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1826 = mem[_1822]
        require mem[_1822] == mem[_1822 + 12 len 20]
        _1830 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1830] = 0
        mem[_1830 + 32] = 96
        mem[_1830 + 64] = 96
        mem[_1830 + 96] = 0
        mem[_1830 + 128] = 0
        mem[_1830 + 160] = 0
        mem[_1830 + 192] = 0
        mem[_1830 + 224] = 0
        mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1826))
        staticcall address(_1826).name() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1842 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1846 = mem[_1842]
        require mem[_1842] <= test266151307()
        require _1842 + mem[_1842] + 31 < _1842 + return_data.size
        _1850 = mem[_1842 + mem[_1842]]
        require mem[_1842 + mem[_1842]] <= test266151307()
        require ceil32(mem[_1842 + mem[_1842]]) + 32 >= 0 and _1842 + ceil32(return_data.size) + ceil32(mem[_1842 + mem[_1842]]) + 32 <= test266151307()
        mem[64] = _1842 + ceil32(return_data.size) + ceil32(mem[_1842 + mem[_1842]]) + 32
        mem[_1842 + ceil32(return_data.size)] = _1850
        require _1846 + _1850 + 32 <= return_data.size
        mem[_1842 + ceil32(return_data.size) + 32 len ceil32(_1850)] = mem[_1842 + _1846 + 32 len ceil32(_1850)]
        if ceil32(_1850) <= _1850:
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1826))
            staticcall address(_1826).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2659 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2667 = mem[_2659]
            require mem[_2659] <= test266151307()
            require _2659 + mem[_2659] + 31 < _2659 + return_data.size
            _2675 = mem[_2659 + mem[_2659]]
            require mem[_2659 + mem[_2659]] <= test266151307()
            require ceil32(mem[_2659 + mem[_2659]]) + 32 >= 0 and _2659 + ceil32(return_data.size) + ceil32(mem[_2659 + mem[_2659]]) + 32 <= test266151307()
            mem[64] = _2659 + ceil32(return_data.size) + ceil32(mem[_2659 + mem[_2659]]) + 32
            mem[_2659 + ceil32(return_data.size)] = _2675
            require _2667 + _2675 + 32 <= return_data.size
            mem[_2659 + ceil32(return_data.size) + 32 len ceil32(_2675)] = mem[_2659 + _2667 + 32 len ceil32(_2675)]
            if ceil32(_2675) <= _2675:
                require ext_code.size(address(_1826))
                staticcall address(_1826).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3461 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3477 = mem[_3461]
                require mem[_3461] == mem[_3461 + 31 len 1]
                require ext_code.size(address(_1826))
                staticcall address(_1826).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3525 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3541 = mem[_3525]
                _3553 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3553] = address(_1826)
                mem[_3553 + 32] = _1842 + ceil32(return_data.size)
                mem[_3553 + 64] = _2659 + ceil32(return_data.size)
                mem[_3553 + 96] = uint8(_3477)
                mem[_3553 + 128] = 0
                mem[_3553 + 160] = _3541
                mem[_3553 + 192] = 0
                mem[_3553 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3605 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3621 = mem[_3605]
                require mem[_3605] == mem[_3605 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3621))
                staticcall address(_3621).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3669 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1805 + 128] = mem[_3669]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3733 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3749 = mem[_3733]
                require mem[_3733] == mem[_3733 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3749))
                staticcall address(_3749).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3797 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3553 + 128] = mem[_3797]
                _3829 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3829] = 0
                mem[_3829 + 32] = 96
                mem[_3829 + 64] = 96
                mem[_3829 + 96] = 0
                mem[_3829 + 128] = 0
                mem[_3829 + 160] = 0
                mem[_3829 + 192] = 0
                mem[_3829 + 224] = 0
                _3845 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3845] = 0
                mem[_3845 + 32] = 96
                mem[_3845 + 64] = 96
                mem[_3845 + 96] = 0
                mem[_3845 + 128] = 0
                mem[_3845 + 160] = 0
                mem[_3845 + 192] = 0
                mem[_3845 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3889 = mem[64]
                    mem[mem[64]] = 2
                    _4964 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4964] = 0
                    mem[_4964 + 32] = 96
                    mem[_4964 + 64] = 96
                    mem[_4964 + 96] = 0
                    mem[_4964 + 128] = 0
                    mem[_4964 + 160] = 0
                    mem[_4964 + 192] = 0
                    mem[_4964 + 224] = 0
                    mem[var181001] = _4964
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _4964 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4964] = 0
                        mem[_4964 + 32] = 96
                        mem[_4964 + 64] = 96
                        mem[_4964 + 96] = 0
                        mem[_4964 + 128] = 0
                        mem[_4964 + 160] = 0
                        mem[_4964 + 192] = 0
                        mem[_4964 + 224] = 0
                        mem[s + 32] = _4964
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3889]
                    mem[_3889 + 32] = _3553
                    require 1 < mem[_3889]
                    mem[_3889 + 64] = _1805
                    _5252 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5252] = 0
                    mem[_5252 + 32] = 96
                    mem[_5252 + 64] = 96
                    mem[_5252 + 96] = 0
                    mem[_5252 + 128] = 0
                    mem[_5252 + 160] = 0
                    mem[_5252 + 192] = 0
                    mem[_5252 + 224] = 0
                    require 0 < mem[_3889]
                    _5526 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5526] = 0
                    mem[_5526 + 32] = 96
                    mem[_5526 + 64] = 96
                    mem[_5526 + 96] = 0
                    mem[_5526 + 128] = 0
                    mem[_5526 + 160] = 0
                    mem[_5526 + 192] = 0
                    mem[_5526 + 224] = 0
                    require 1 < mem[_3889]
                    if mem[_3553 + 96] <= mem[_1805 + 96]:
                        idx = 12
                        s = mem[_3553 + 96]
                        while idx >= 4:
                            if not mem[_3553 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3553 + 96] - idx
                            continue 
                        _6207 = mem[_3553 + 96]
                        _6208 = mem[_3553 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6207 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1805 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                            if not _6208 / 10^(_6207 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6208 / 10^(_6207 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6208 / 10^(_6207 - s))
                        if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6208 / 10^(_6207 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6208 / 10^(_6207 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6208 / 10^(_6207 - s))
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _6209 = mem[_3553 + 96]
                    _6210 = mem[_3553 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6209 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6210 / 10^(_6209 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6210 / 10^(_6209 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6210 / 10^(_6209 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6210 / 10^(_6209 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6210 / 10^(_6209 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6210 / 10^(_6209 - s))
                if wbnbAddress == address(_1826):
                    _3933 = mem[64]
                    mem[mem[64]] = 2
                    _4963 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4963] = 0
                    mem[_4963 + 32] = 96
                    mem[_4963 + 64] = 96
                    mem[_4963 + 96] = 0
                    mem[_4963 + 128] = 0
                    mem[_4963 + 160] = 0
                    mem[_4963 + 192] = 0
                    mem[_4963 + 224] = 0
                    mem[var184001] = _4963
                    s = var184001
                    idx = var184002
                    while idx - 1:
                        _4963 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4963] = 0
                        mem[_4963 + 32] = 96
                        mem[_4963 + 64] = 96
                        mem[_4963 + 96] = 0
                        mem[_4963 + 128] = 0
                        mem[_4963 + 160] = 0
                        mem[_4963 + 192] = 0
                        mem[_4963 + 224] = 0
                        mem[s + 32] = _4963
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3933]
                    mem[_3933 + 32] = _1805
                    require 1 < mem[_3933]
                    mem[_3933 + 64] = _3553
                    _5251 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5251] = 0
                    mem[_5251 + 32] = 96
                    mem[_5251 + 64] = 96
                    mem[_5251 + 96] = 0
                    mem[_5251 + 128] = 0
                    mem[_5251 + 160] = 0
                    mem[_5251 + 192] = 0
                    mem[_5251 + 224] = 0
                    require 0 < mem[_3933]
                    _5525 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5525] = 0
                    mem[_5525 + 32] = 96
                    mem[_5525 + 64] = 96
                    mem[_5525 + 96] = 0
                    mem[_5525 + 128] = 0
                    mem[_5525 + 160] = 0
                    mem[_5525 + 192] = 0
                    mem[_5525 + 224] = 0
                    require 1 < mem[_3933]
                    if mem[_1805 + 96] <= mem[_3553 + 96]:
                        idx = 12
                        s = mem[_1805 + 96]
                        while idx >= 4:
                            if not mem[_1805 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1805 + 96] - idx
                            continue 
                        _6203 = mem[_1805 + 96]
                        _6204 = mem[_1805 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6203 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3553 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                            if not _6204 / 10^(_6203 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6204 / 10^(_6203 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6204 / 10^(_6203 - s))
                        if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6204 / 10^(_6203 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6204 / 10^(_6203 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6204 / 10^(_6203 - s))
                    idx = 12
                    s = mem[_3553 + 96]
                    while idx >= 4:
                        if not mem[_3553 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3553 + 96] - idx
                        continue 
                    _6205 = mem[_1805 + 96]
                    _6206 = mem[_1805 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6205 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3553 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                        if not _6206 / 10^(_6205 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6206 / 10^(_6205 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6206 / 10^(_6205 - s))
                    if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6206 / 10^(_6205 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6206 / 10^(_6205 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6206 / 10^(_6205 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3981 = mem[64]
                    mem[mem[64]] = 2
                    _4962 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4962] = 0
                    mem[_4962 + 32] = 96
                    mem[_4962 + 64] = 96
                    mem[_4962 + 96] = 0
                    mem[_4962 + 128] = 0
                    mem[_4962 + 160] = 0
                    mem[_4962 + 192] = 0
                    mem[_4962 + 224] = 0
                    mem[var187001] = _4962
                    s = var187001
                    idx = var187002
                    while idx - 1:
                        _4962 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4962] = 0
                        mem[_4962 + 32] = 96
                        mem[_4962 + 64] = 96
                        mem[_4962 + 96] = 0
                        mem[_4962 + 128] = 0
                        mem[_4962 + 160] = 0
                        mem[_4962 + 192] = 0
                        mem[_4962 + 224] = 0
                        mem[s + 32] = _4962
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3981]
                    mem[_3981 + 32] = _3553
                    require 1 < mem[_3981]
                    mem[_3981 + 64] = _1805
                    _5250 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5250] = 0
                    mem[_5250 + 32] = 96
                    mem[_5250 + 64] = 96
                    mem[_5250 + 96] = 0
                    mem[_5250 + 128] = 0
                    mem[_5250 + 160] = 0
                    mem[_5250 + 192] = 0
                    mem[_5250 + 224] = 0
                    require 0 < mem[_3981]
                    _5524 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5524] = 0
                    mem[_5524 + 32] = 96
                    mem[_5524 + 64] = 96
                    mem[_5524 + 96] = 0
                    mem[_5524 + 128] = 0
                    mem[_5524 + 160] = 0
                    mem[_5524 + 192] = 0
                    mem[_5524 + 224] = 0
                    require 1 < mem[_3981]
                    if mem[_3553 + 96] <= mem[_1805 + 96]:
                        idx = 12
                        s = mem[_3553 + 96]
                        while idx >= 4:
                            if not mem[_3553 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3553 + 96] - idx
                            continue 
                        _6199 = mem[_3553 + 96]
                        _6200 = mem[_3553 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6199 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1805 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                            if not _6200 / 10^(_6199 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6200 / 10^(_6199 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6200 / 10^(_6199 - s))
                        if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6200 / 10^(_6199 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6200 / 10^(_6199 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6200 / 10^(_6199 - s))
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _6201 = mem[_3553 + 96]
                    _6202 = mem[_3553 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6201 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6202 / 10^(_6201 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6202 / 10^(_6201 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6202 / 10^(_6201 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6202 / 10^(_6201 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6202 / 10^(_6201 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6202 / 10^(_6201 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4029 = mem[64]
                    mem[mem[64]] = 2
                    _4961 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4961] = 0
                    mem[_4961 + 32] = 96
                    mem[_4961 + 64] = 96
                    mem[_4961 + 96] = 0
                    mem[_4961 + 128] = 0
                    mem[_4961 + 160] = 0
                    mem[_4961 + 192] = 0
                    mem[_4961 + 224] = 0
                    mem[var190001] = _4961
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4961 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4961] = 0
                        mem[_4961 + 32] = 96
                        mem[_4961 + 64] = 96
                        mem[_4961 + 96] = 0
                        mem[_4961 + 128] = 0
                        mem[_4961 + 160] = 0
                        mem[_4961 + 192] = 0
                        mem[_4961 + 224] = 0
                        mem[s + 32] = _4961
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4029]
                    mem[_4029 + 32] = _3553
                    require 1 < mem[_4029]
                    mem[_4029 + 64] = _1805
                    _5249 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5249] = 0
                    mem[_5249 + 32] = 96
                    mem[_5249 + 64] = 96
                    mem[_5249 + 96] = 0
                    mem[_5249 + 128] = 0
                    mem[_5249 + 160] = 0
                    mem[_5249 + 192] = 0
                    mem[_5249 + 224] = 0
                    require 0 < mem[_4029]
                    _5523 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5523] = 0
                    mem[_5523 + 32] = 96
                    mem[_5523 + 64] = 96
                    mem[_5523 + 96] = 0
                    mem[_5523 + 128] = 0
                    mem[_5523 + 160] = 0
                    mem[_5523 + 192] = 0
                    mem[_5523 + 224] = 0
                    require 1 < mem[_4029]
                    if mem[_3553 + 96] <= mem[_1805 + 96]:
                        idx = 12
                        s = mem[_3553 + 96]
                        while idx >= 4:
                            if not mem[_3553 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3553 + 96] - idx
                            continue 
                        _6195 = mem[_3553 + 96]
                        _6196 = mem[_3553 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6195 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1805 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                            if not _6196 / 10^(_6195 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6196 / 10^(_6195 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6196 / 10^(_6195 - s))
                        if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6196 / 10^(_6195 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6196 / 10^(_6195 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6196 / 10^(_6195 - s))
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _6197 = mem[_3553 + 96]
                    _6198 = mem[_3553 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6197 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6198 / 10^(_6197 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6198 / 10^(_6197 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6198 / 10^(_6197 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6198 / 10^(_6197 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6198 / 10^(_6197 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6198 / 10^(_6197 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4425 = mem[64]
                    mem[mem[64]] = 2
                    _6002 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_6002] = 0
                    mem[_6002 + 32] = 96
                    mem[_6002 + 64] = 96
                    mem[_6002 + 96] = 0
                    mem[_6002 + 128] = 0
                    mem[_6002 + 160] = 0
                    mem[_6002 + 192] = 0
                    mem[_6002 + 224] = 0
                    mem[var199001] = _6002
                    s = var199001
                    idx = var199002
                    while idx - 1:
                        _6002 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_6002] = 0
                        mem[_6002 + 32] = 96
                        mem[_6002 + 64] = 96
                        mem[_6002 + 96] = 0
                        mem[_6002 + 128] = 0
                        mem[_6002 + 160] = 0
                        mem[_6002 + 192] = 0
                        mem[_6002 + 224] = 0
                        mem[s + 32] = _6002
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4425]
                    mem[_4425 + 32] = _3553
                    require 1 < mem[_4425]
                    mem[_4425 + 64] = _1805
                    _6546 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6546] = 0
                    mem[_6546 + 32] = 96
                    mem[_6546 + 64] = 96
                    mem[_6546 + 96] = 0
                    mem[_6546 + 128] = 0
                    mem[_6546 + 160] = 0
                    mem[_6546 + 192] = 0
                    mem[_6546 + 224] = 0
                    require 0 < mem[_4425]
                    _6834 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6834] = 0
                    mem[_6834 + 32] = 96
                    mem[_6834 + 64] = 96
                    mem[_6834 + 96] = 0
                    mem[_6834 + 128] = 0
                    mem[_6834 + 160] = 0
                    mem[_6834 + 192] = 0
                    mem[_6834 + 224] = 0
                    require 1 < mem[_4425]
                    if mem[_3553 + 96] <= mem[_1805 + 96]:
                        idx = 12
                        s = mem[_3553 + 96]
                        while idx >= 4:
                            if not mem[_3553 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3553 + 96] - idx
                            continue 
                        _13061 = mem[_3553 + 96]
                        _13062 = mem[_3553 + 128]
                        _13155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13155] = 26
                        mem[_13155 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13061 - s):
                            _13603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13603 + 68] = mem[idx + _13155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13603 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13603 + -mem[64] + 100
                        _14917 = mem[_1805 + 96]
                        _14918 = mem[_1805 + 128]
                        _15045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15045] = 26
                        mem[_15045 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14917 - s):
                            _15139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15139 + 68] = mem[idx + _15045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15139 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15139 + -mem[64] + 100
                        if not _14918 / 10^(_14917 - s):
                            _15523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15523] = 26
                            mem[_15523 + 32] = 'SafeMath: division by zero'
                            if not _13062 / 10^(_13061 - s):
                                _15784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15784 + 68] = mem[idx + _15523 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15784 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15784 + -mem[64] + 100
                            _16325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16325] = 26
                            mem[_16325 + 32] = 'SafeMath: division by zero'
                            if 0 / _13062 / 10^(_13061 - s):
                                return (1000000 * 10^18 / 0 / _13062 / 10^(_13061 - s))
                            _16553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16553 + 68] = mem[idx + _16325 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16553 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16553 + -mem[64] + 100
                        if 10^12 * _14918 / 10^(_14917 - s) / _14918 / 10^(_14917 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15783] = 26
                        mem[_15783 + 32] = 'SafeMath: division by zero'
                        if not _13062 / 10^(_13061 - s):
                            _15941 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15941 + 68] = mem[idx + _15783 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15941 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15941 + -mem[64] + 100
                        _16551 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16551] = 26
                        mem[_16551 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14918 / 10^(_14917 - s) / _13062 / 10^(_13061 - s):
                            return (1000000 * 10^18 / 10^12 * _14918 / 10^(_14917 - s) / _13062 / 10^(_13061 - s))
                        _16709 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16709 + 68] = mem[idx + _16551 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16709 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16709 + -mem[64] + 100
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _13063 = mem[_3553 + 96]
                    _13064 = mem[_3553 + 128]
                    _13156 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13156] = 26
                    mem[_13156 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13063 - s):
                        _13604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13604 + 68] = mem[idx + _13156 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13604 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13604 + -mem[64] + 100
                    _14919 = mem[_1805 + 96]
                    _14920 = mem[_1805 + 128]
                    _15047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15047] = 26
                    mem[_15047 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14919 - s):
                        _15140 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15140 + 68] = mem[idx + _15047 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15140 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15140 + -mem[64] + 100
                    if not _14920 / 10^(_14919 - s):
                        _15524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15524] = 26
                        mem[_15524 + 32] = 'SafeMath: division by zero'
                        if not _13064 / 10^(_13063 - s):
                            _15787 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15787 + 68] = mem[idx + _15524 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15787 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15787 + -mem[64] + 100
                        _16327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16327] = 26
                        mem[_16327 + 32] = 'SafeMath: division by zero'
                        if 0 / _13064 / 10^(_13063 - s):
                            return (1000000 * 10^18 / 0 / _13064 / 10^(_13063 - s))
                        _16556 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16556 + 68] = mem[idx + _16327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16556 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16556 + -mem[64] + 100
                    if 10^12 * _14920 / 10^(_14919 - s) / _14920 / 10^(_14919 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15786 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15786] = 26
                    mem[_15786 + 32] = 'SafeMath: division by zero'
                    if not _13064 / 10^(_13063 - s):
                        _15943 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15943 + 68] = mem[idx + _15786 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15943 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15943 + -mem[64] + 100
                    _16554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16554] = 26
                    mem[_16554 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14920 / 10^(_14919 - s) / _13064 / 10^(_13063 - s):
                        return (1000000 * 10^18 / 10^12 * _14920 / 10^(_14919 - s) / _13064 / 10^(_13063 - s))
                    _16711 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16711 + 68] = mem[idx + _16554 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16711 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16711 + -mem[64] + 100
                _4265 = mem[64]
                mem[mem[64]] = 2
                _6001 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_6001] = 0
                mem[_6001 + 32] = 96
                mem[_6001 + 64] = 96
                mem[_6001 + 96] = 0
                mem[_6001 + 128] = 0
                mem[_6001 + 160] = 0
                mem[_6001 + 192] = 0
                mem[_6001 + 224] = 0
                mem[var195001] = _6001
                s = var195001
                idx = var195002
                while idx - 1:
                    _6001 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6001] = 0
                    mem[_6001 + 32] = 96
                    mem[_6001 + 64] = 96
                    mem[_6001 + 96] = 0
                    mem[_6001 + 128] = 0
                    mem[_6001 + 160] = 0
                    mem[_6001 + 192] = 0
                    mem[_6001 + 224] = 0
                    mem[s + 32] = _6001
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4265]
                mem[_4265 + 32] = _1805
                require 1 < mem[_4265]
                mem[_4265 + 64] = _3553
                _6545 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6545] = 0
                mem[_6545 + 32] = 96
                mem[_6545 + 64] = 96
                mem[_6545 + 96] = 0
                mem[_6545 + 128] = 0
                mem[_6545 + 160] = 0
                mem[_6545 + 192] = 0
                mem[_6545 + 224] = 0
                require 0 < mem[_4265]
                _6833 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6833] = 0
                mem[_6833 + 32] = 96
                mem[_6833 + 64] = 96
                mem[_6833 + 96] = 0
                mem[_6833 + 128] = 0
                mem[_6833 + 160] = 0
                mem[_6833 + 192] = 0
                mem[_6833 + 224] = 0
                require 1 < mem[_4265]
                if mem[_1805 + 96] <= mem[_3553 + 96]:
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _13057 = mem[_1805 + 96]
                    _13058 = mem[_1805 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_13057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3553 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                        if not _13058 / 10^(_13057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _13058 / 10^(_13057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _13058 / 10^(_13057 - s))
                    if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _13058 / 10^(_13057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13058 / 10^(_13057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13058 / 10^(_13057 - s))
                idx = 12
                s = mem[_3553 + 96]
                while idx >= 4:
                    if not mem[_3553 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3553 + 96] - idx
                    continue 
                _13059 = mem[_1805 + 96]
                _13060 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3553 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                    if not _13060 / 10^(_13059 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13060 / 10^(_13059 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13060 / 10^(_13059 - s))
                if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13060 / 10^(_13059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13060 / 10^(_13059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13060 / 10^(_13059 - s))
            mem[_2659 + ceil32(return_data.size) + _2675 + 32] = 0
            require ext_code.size(address(_1826))
            staticcall address(_1826).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3469 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3485 = mem[_3469]
            require mem[_3469] == mem[_3469 + 31 len 1]
            require ext_code.size(address(_1826))
            staticcall address(_1826).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3533 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3554 = mem[_3533]
            _3575 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3575] = address(_1826)
            mem[_3575 + 32] = _1842 + ceil32(return_data.size)
            mem[_3575 + 64] = _2659 + ceil32(return_data.size)
            mem[_3575 + 96] = uint8(_3485)
            mem[_3575 + 128] = 0
            mem[_3575 + 160] = _3554
            mem[_3575 + 192] = 0
            mem[_3575 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3613 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3629 = mem[_3613]
            require mem[_3613] == mem[_3613 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3629))
            staticcall address(_3629).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3677 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1805 + 128] = mem[_3677]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3741 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3757 = mem[_3741]
            require mem[_3741] == mem[_3741 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3757))
            staticcall address(_3757).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3805 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3575 + 128] = mem[_3805]
            _3837 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3837] = 0
            mem[_3837 + 32] = 96
            mem[_3837 + 64] = 96
            mem[_3837 + 96] = 0
            mem[_3837 + 128] = 0
            mem[_3837 + 160] = 0
            mem[_3837 + 192] = 0
            mem[_3837 + 224] = 0
            _3858 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3858] = 0
            mem[_3858 + 32] = 96
            mem[_3858 + 64] = 96
            mem[_3858 + 96] = 0
            mem[_3858 + 128] = 0
            mem[_3858 + 160] = 0
            mem[_3858 + 192] = 0
            mem[_3858 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3901 = mem[64]
                mem[mem[64]] = 2
                _4968 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4968] = 0
                mem[_4968 + 32] = 96
                mem[_4968 + 64] = 96
                mem[_4968 + 96] = 0
                mem[_4968 + 128] = 0
                mem[_4968 + 160] = 0
                mem[_4968 + 192] = 0
                mem[_4968 + 224] = 0
                mem[var182001] = _4968
                s = var182001
                idx = var182002
                while idx - 1:
                    _4968 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4968] = 0
                    mem[_4968 + 32] = 96
                    mem[_4968 + 64] = 96
                    mem[_4968 + 96] = 0
                    mem[_4968 + 128] = 0
                    mem[_4968 + 160] = 0
                    mem[_4968 + 192] = 0
                    mem[_4968 + 224] = 0
                    mem[s + 32] = _4968
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3901]
                mem[_3901 + 32] = _3575
                require 1 < mem[_3901]
                mem[_3901 + 64] = _1805
                _5256 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5256] = 0
                mem[_5256 + 32] = 96
                mem[_5256 + 64] = 96
                mem[_5256 + 96] = 0
                mem[_5256 + 128] = 0
                mem[_5256 + 160] = 0
                mem[_5256 + 192] = 0
                mem[_5256 + 224] = 0
                require 0 < mem[_3901]
                _5532 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5532] = 0
                mem[_5532 + 32] = 96
                mem[_5532 + 64] = 96
                mem[_5532 + 96] = 0
                mem[_5532 + 128] = 0
                mem[_5532 + 160] = 0
                mem[_5532 + 192] = 0
                mem[_5532 + 224] = 0
                require 1 < mem[_3901]
                if mem[_3575 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3575 + 96]
                    while idx >= 4:
                        if not mem[_3575 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3575 + 96] - idx
                        continue 
                    _6225 = mem[_3575 + 96]
                    _6226 = mem[_3575 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6225 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6226 / 10^(_6225 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6226 / 10^(_6225 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6226 / 10^(_6225 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6226 / 10^(_6225 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6226 / 10^(_6225 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6226 / 10^(_6225 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6227 = mem[_3575 + 96]
                _6228 = mem[_3575 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6227 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6228 / 10^(_6227 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6228 / 10^(_6227 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6228 / 10^(_6227 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6228 / 10^(_6227 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6228 / 10^(_6227 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6228 / 10^(_6227 - s))
            if wbnbAddress == address(_1826):
                _3949 = mem[64]
                mem[mem[64]] = 2
                _4967 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4967] = 0
                mem[_4967 + 32] = 96
                mem[_4967 + 64] = 96
                mem[_4967 + 96] = 0
                mem[_4967 + 128] = 0
                mem[_4967 + 160] = 0
                mem[_4967 + 192] = 0
                mem[_4967 + 224] = 0
                mem[var185001] = _4967
                s = var185001
                idx = var185002
                while idx - 1:
                    _4967 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4967] = 0
                    mem[_4967 + 32] = 96
                    mem[_4967 + 64] = 96
                    mem[_4967 + 96] = 0
                    mem[_4967 + 128] = 0
                    mem[_4967 + 160] = 0
                    mem[_4967 + 192] = 0
                    mem[_4967 + 224] = 0
                    mem[s + 32] = _4967
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3949]
                mem[_3949 + 32] = _1805
                require 1 < mem[_3949]
                mem[_3949 + 64] = _3575
                _5255 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5255] = 0
                mem[_5255 + 32] = 96
                mem[_5255 + 64] = 96
                mem[_5255 + 96] = 0
                mem[_5255 + 128] = 0
                mem[_5255 + 160] = 0
                mem[_5255 + 192] = 0
                mem[_5255 + 224] = 0
                require 0 < mem[_3949]
                _5531 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5531] = 0
                mem[_5531 + 32] = 96
                mem[_5531 + 64] = 96
                mem[_5531 + 96] = 0
                mem[_5531 + 128] = 0
                mem[_5531 + 160] = 0
                mem[_5531 + 192] = 0
                mem[_5531 + 224] = 0
                require 1 < mem[_3949]
                if mem[_1805 + 96] <= mem[_3575 + 96]:
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _6221 = mem[_1805 + 96]
                    _6222 = mem[_1805 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6221 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3575 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3575 + 128] / 10^(mem[_3575 + 96] - s):
                        if not _6222 / 10^(_6221 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6222 / 10^(_6221 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6222 / 10^(_6221 - s))
                    if 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6222 / 10^(_6221 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _6222 / 10^(_6221 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _6222 / 10^(_6221 - s))
                idx = 12
                s = mem[_3575 + 96]
                while idx >= 4:
                    if not mem[_3575 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3575 + 96] - idx
                    continue 
                _6223 = mem[_1805 + 96]
                _6224 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6223 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3575 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3575 + 128] / 10^(mem[_3575 + 96] - s):
                    if not _6224 / 10^(_6223 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6224 / 10^(_6223 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6224 / 10^(_6223 - s))
                if 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6224 / 10^(_6223 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _6224 / 10^(_6223 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _6224 / 10^(_6223 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3997 = mem[64]
                mem[mem[64]] = 2
                _4966 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4966] = 0
                mem[_4966 + 32] = 96
                mem[_4966 + 64] = 96
                mem[_4966 + 96] = 0
                mem[_4966 + 128] = 0
                mem[_4966 + 160] = 0
                mem[_4966 + 192] = 0
                mem[_4966 + 224] = 0
                mem[var188001] = _4966
                s = var188001
                idx = var188002
                while idx - 1:
                    _4966 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4966] = 0
                    mem[_4966 + 32] = 96
                    mem[_4966 + 64] = 96
                    mem[_4966 + 96] = 0
                    mem[_4966 + 128] = 0
                    mem[_4966 + 160] = 0
                    mem[_4966 + 192] = 0
                    mem[_4966 + 224] = 0
                    mem[s + 32] = _4966
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3997]
                mem[_3997 + 32] = _3575
                require 1 < mem[_3997]
                mem[_3997 + 64] = _1805
                _5254 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5254] = 0
                mem[_5254 + 32] = 96
                mem[_5254 + 64] = 96
                mem[_5254 + 96] = 0
                mem[_5254 + 128] = 0
                mem[_5254 + 160] = 0
                mem[_5254 + 192] = 0
                mem[_5254 + 224] = 0
                require 0 < mem[_3997]
                _5530 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5530] = 0
                mem[_5530 + 32] = 96
                mem[_5530 + 64] = 96
                mem[_5530 + 96] = 0
                mem[_5530 + 128] = 0
                mem[_5530 + 160] = 0
                mem[_5530 + 192] = 0
                mem[_5530 + 224] = 0
                require 1 < mem[_3997]
                if mem[_3575 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3575 + 96]
                    while idx >= 4:
                        if not mem[_3575 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3575 + 96] - idx
                        continue 
                    _6217 = mem[_3575 + 96]
                    _6218 = mem[_3575 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6217 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6218 / 10^(_6217 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6218 / 10^(_6217 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6218 / 10^(_6217 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6218 / 10^(_6217 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6218 / 10^(_6217 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6218 / 10^(_6217 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6219 = mem[_3575 + 96]
                _6220 = mem[_3575 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6219 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6220 / 10^(_6219 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6220 / 10^(_6219 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6220 / 10^(_6219 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6220 / 10^(_6219 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6220 / 10^(_6219 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6220 / 10^(_6219 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4045 = mem[64]
                mem[mem[64]] = 2
                _4965 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4965] = 0
                mem[_4965 + 32] = 96
                mem[_4965 + 64] = 96
                mem[_4965 + 96] = 0
                mem[_4965 + 128] = 0
                mem[_4965 + 160] = 0
                mem[_4965 + 192] = 0
                mem[_4965 + 224] = 0
                mem[var191001] = _4965
                s = var191001
                idx = var191002
                while idx - 1:
                    _4965 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4965] = 0
                    mem[_4965 + 32] = 96
                    mem[_4965 + 64] = 96
                    mem[_4965 + 96] = 0
                    mem[_4965 + 128] = 0
                    mem[_4965 + 160] = 0
                    mem[_4965 + 192] = 0
                    mem[_4965 + 224] = 0
                    mem[s + 32] = _4965
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4045]
                mem[_4045 + 32] = _3575
                require 1 < mem[_4045]
                mem[_4045 + 64] = _1805
                _5253 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5253] = 0
                mem[_5253 + 32] = 96
                mem[_5253 + 64] = 96
                mem[_5253 + 96] = 0
                mem[_5253 + 128] = 0
                mem[_5253 + 160] = 0
                mem[_5253 + 192] = 0
                mem[_5253 + 224] = 0
                require 0 < mem[_4045]
                _5529 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5529] = 0
                mem[_5529 + 32] = 96
                mem[_5529 + 64] = 96
                mem[_5529 + 96] = 0
                mem[_5529 + 128] = 0
                mem[_5529 + 160] = 0
                mem[_5529 + 192] = 0
                mem[_5529 + 224] = 0
                require 1 < mem[_4045]
                if mem[_3575 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3575 + 96]
                    while idx >= 4:
                        if not mem[_3575 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3575 + 96] - idx
                        continue 
                    _6213 = mem[_3575 + 96]
                    _6214 = mem[_3575 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6213 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6214 / 10^(_6213 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6214 / 10^(_6213 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6214 / 10^(_6213 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6214 / 10^(_6213 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6214 / 10^(_6213 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6214 / 10^(_6213 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6215 = mem[_3575 + 96]
                _6216 = mem[_3575 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6215 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6216 / 10^(_6215 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6216 / 10^(_6215 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6216 / 10^(_6215 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6216 / 10^(_6215 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6216 / 10^(_6215 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6216 / 10^(_6215 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4430 = mem[64]
                mem[mem[64]] = 2
                _6004 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_6004] = 0
                mem[_6004 + 32] = 96
                mem[_6004 + 64] = 96
                mem[_6004 + 96] = 0
                mem[_6004 + 128] = 0
                mem[_6004 + 160] = 0
                mem[_6004 + 192] = 0
                mem[_6004 + 224] = 0
                mem[var200001] = _6004
                s = var200001
                idx = var200002
                while idx - 1:
                    _6004 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6004] = 0
                    mem[_6004 + 32] = 96
                    mem[_6004 + 64] = 96
                    mem[_6004 + 96] = 0
                    mem[_6004 + 128] = 0
                    mem[_6004 + 160] = 0
                    mem[_6004 + 192] = 0
                    mem[_6004 + 224] = 0
                    mem[s + 32] = _6004
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4430]
                mem[_4430 + 32] = _3575
                require 1 < mem[_4430]
                mem[_4430 + 64] = _1805
                _6556 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6556] = 0
                mem[_6556 + 32] = 96
                mem[_6556 + 64] = 96
                mem[_6556 + 96] = 0
                mem[_6556 + 128] = 0
                mem[_6556 + 160] = 0
                mem[_6556 + 192] = 0
                mem[_6556 + 224] = 0
                require 0 < mem[_4430]
                _6836 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6836] = 0
                mem[_6836 + 32] = 96
                mem[_6836 + 64] = 96
                mem[_6836 + 96] = 0
                mem[_6836 + 128] = 0
                mem[_6836 + 160] = 0
                mem[_6836 + 192] = 0
                mem[_6836 + 224] = 0
                require 1 < mem[_4430]
                if mem[_3575 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3575 + 96]
                    while idx >= 4:
                        if not mem[_3575 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3575 + 96] - idx
                        continue 
                    _13069 = mem[_3575 + 96]
                    _13070 = mem[_3575 + 128]
                    _13159 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13159] = 26
                    mem[_13159 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13069 - s):
                        _13655 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13655 + 68] = mem[idx + _13159 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13655 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13655 + -mem[64] + 100
                    _14925 = mem[_1805 + 96]
                    _14926 = mem[_1805 + 128]
                    _15053 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15053] = 26
                    mem[_15053 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14925 - s):
                        _15143 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15143 + 68] = mem[idx + _15053 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15143 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15143 + -mem[64] + 100
                    if not _14926 / 10^(_14925 - s):
                        _15527 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15527] = 26
                        mem[_15527 + 32] = 'SafeMath: division by zero'
                        if not _13070 / 10^(_13069 - s):
                            _15796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15796 + 68] = mem[idx + _15527 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15796 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15796 + -mem[64] + 100
                        _16333 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16333] = 26
                        mem[_16333 + 32] = 'SafeMath: division by zero'
                        if 0 / _13070 / 10^(_13069 - s):
                            return (1000000 * 10^18 / 0 / _13070 / 10^(_13069 - s))
                        _16565 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16565 + 68] = mem[idx + _16333 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16565 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16565 + -mem[64] + 100
                    if 10^12 * _14926 / 10^(_14925 - s) / _14926 / 10^(_14925 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15795] = 26
                    mem[_15795 + 32] = 'SafeMath: division by zero'
                    if not _13070 / 10^(_13069 - s):
                        _15949 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15949 + 68] = mem[idx + _15795 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15949 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15949 + -mem[64] + 100
                    _16563 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16563] = 26
                    mem[_16563 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14926 / 10^(_14925 - s) / _13070 / 10^(_13069 - s):
                        return (1000000 * 10^18 / 10^12 * _14926 / 10^(_14925 - s) / _13070 / 10^(_13069 - s))
                    _16717 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16717 + 68] = mem[idx + _16563 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16717 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16717 + -mem[64] + 100
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _13071 = mem[_3575 + 96]
                _13072 = mem[_3575 + 128]
                _13160 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13160] = 26
                mem[_13160 + 32] = 'SafeMath: division by zero'
                if not 10^(_13071 - s):
                    _13656 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13656 + 68] = mem[idx + _13160 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13656 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13656 + -mem[64] + 100
                _14927 = mem[_1805 + 96]
                _14928 = mem[_1805 + 128]
                _15055 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15055] = 26
                mem[_15055 + 32] = 'SafeMath: division by zero'
                if not 10^(_14927 - s):
                    _15144 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15144 + 68] = mem[idx + _15055 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15144 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15144 + -mem[64] + 100
                if not _14928 / 10^(_14927 - s):
                    _15528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15528] = 26
                    mem[_15528 + 32] = 'SafeMath: division by zero'
                    if not _13072 / 10^(_13071 - s):
                        _15799 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15799 + 68] = mem[idx + _15528 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15799 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15799 + -mem[64] + 100
                    _16335 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16335] = 26
                    mem[_16335 + 32] = 'SafeMath: division by zero'
                    if 0 / _13072 / 10^(_13071 - s):
                        return (1000000 * 10^18 / 0 / _13072 / 10^(_13071 - s))
                    _16568 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16568 + 68] = mem[idx + _16335 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16568 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16568 + -mem[64] + 100
                if 10^12 * _14928 / 10^(_14927 - s) / _14928 / 10^(_14927 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15798 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15798] = 26
                mem[_15798 + 32] = 'SafeMath: division by zero'
                if not _13072 / 10^(_13071 - s):
                    _15951 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15951 + 68] = mem[idx + _15798 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15951 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15951 + -mem[64] + 100
                _16566 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16566] = 26
                mem[_16566 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14928 / 10^(_14927 - s) / _13072 / 10^(_13071 - s):
                    return (1000000 * 10^18 / 10^12 * _14928 / 10^(_14927 - s) / _13072 / 10^(_13071 - s))
                _16719 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16719 + 68] = mem[idx + _16566 + 32]
                    idx = idx + 32
                    continue 
                mem[_16719 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16719 + -mem[64] + 100
            _4270 = mem[64]
            mem[mem[64]] = 2
            _6003 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6003] = 0
            mem[_6003 + 32] = 96
            mem[_6003 + 64] = 96
            mem[_6003 + 96] = 0
            mem[_6003 + 128] = 0
            mem[_6003 + 160] = 0
            mem[_6003 + 192] = 0
            mem[_6003 + 224] = 0
            mem[var196001] = _6003
            s = var196001
            idx = var196002
            while idx - 1:
                _6003 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6003] = 0
                mem[_6003 + 32] = 96
                mem[_6003 + 64] = 96
                mem[_6003 + 96] = 0
                mem[_6003 + 128] = 0
                mem[_6003 + 160] = 0
                mem[_6003 + 192] = 0
                mem[_6003 + 224] = 0
                mem[s + 32] = _6003
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4270]
            mem[_4270 + 32] = _1805
            require 1 < mem[_4270]
            mem[_4270 + 64] = _3575
            _6555 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6555] = 0
            mem[_6555 + 32] = 96
            mem[_6555 + 64] = 96
            mem[_6555 + 96] = 0
            mem[_6555 + 128] = 0
            mem[_6555 + 160] = 0
            mem[_6555 + 192] = 0
            mem[_6555 + 224] = 0
            require 0 < mem[_4270]
            _6835 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6835] = 0
            mem[_6835 + 32] = 96
            mem[_6835 + 64] = 96
            mem[_6835 + 96] = 0
            mem[_6835 + 128] = 0
            mem[_6835 + 160] = 0
            mem[_6835 + 192] = 0
            mem[_6835 + 224] = 0
            require 1 < mem[_4270]
            if mem[_1805 + 96] <= mem[_3575 + 96]:
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _13065 = mem[_1805 + 96]
                _13066 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13065 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3575 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3575 + 128] / 10^(mem[_3575 + 96] - s):
                    if not _13066 / 10^(_13065 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13066 / 10^(_13065 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13066 / 10^(_13065 - s))
                if 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13066 / 10^(_13065 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _13066 / 10^(_13065 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _13066 / 10^(_13065 - s))
            idx = 12
            s = mem[_3575 + 96]
            while idx >= 4:
                if not mem[_3575 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3575 + 96] - idx
                continue 
            _13067 = mem[_1805 + 96]
            _13068 = mem[_1805 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13067 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3575 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3575 + 128] / 10^(mem[_3575 + 96] - s):
                if not _13068 / 10^(_13067 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13068 / 10^(_13067 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13068 / 10^(_13067 - s))
            if 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13068 / 10^(_13067 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _13068 / 10^(_13067 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3575 + 128] / 10^(mem[_3575 + 96] - s) / _13068 / 10^(_13067 - s))
        mem[_1842 + ceil32(return_data.size) + _1850 + 32] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1826))
        staticcall address(_1826).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2663 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2671 = mem[_2663]
        require mem[_2663] <= test266151307()
        require _2663 + mem[_2663] + 31 < _2663 + return_data.size
        _2679 = mem[_2663 + mem[_2663]]
        require mem[_2663 + mem[_2663]] <= test266151307()
        require ceil32(mem[_2663 + mem[_2663]]) + 32 >= 0 and _2663 + ceil32(return_data.size) + ceil32(mem[_2663 + mem[_2663]]) + 32 <= test266151307()
        mem[64] = _2663 + ceil32(return_data.size) + ceil32(mem[_2663 + mem[_2663]]) + 32
        mem[_2663 + ceil32(return_data.size)] = _2679
        require _2671 + _2679 + 32 <= return_data.size
        mem[_2663 + ceil32(return_data.size) + 32 len ceil32(_2679)] = mem[_2663 + _2671 + 32 len ceil32(_2679)]
        if ceil32(_2679) <= _2679:
            require ext_code.size(address(_1826))
            staticcall address(_1826).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3462 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3478 = mem[_3462]
            require mem[_3462] == mem[_3462 + 31 len 1]
            require ext_code.size(address(_1826))
            staticcall address(_1826).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3526 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3542 = mem[_3526]
            _3555 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3555] = address(_1826)
            mem[_3555 + 32] = _1842 + ceil32(return_data.size)
            mem[_3555 + 64] = _2663 + ceil32(return_data.size)
            mem[_3555 + 96] = uint8(_3478)
            mem[_3555 + 128] = 0
            mem[_3555 + 160] = _3542
            mem[_3555 + 192] = 0
            mem[_3555 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3606 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3622 = mem[_3606]
            require mem[_3606] == mem[_3606 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3622))
            staticcall address(_3622).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3670 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1805 + 128] = mem[_3670]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3734 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3750 = mem[_3734]
            require mem[_3734] == mem[_3734 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3750))
            staticcall address(_3750).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3798 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3555 + 128] = mem[_3798]
            _3830 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3830] = 0
            mem[_3830 + 32] = 96
            mem[_3830 + 64] = 96
            mem[_3830 + 96] = 0
            mem[_3830 + 128] = 0
            mem[_3830 + 160] = 0
            mem[_3830 + 192] = 0
            mem[_3830 + 224] = 0
            _3846 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3846] = 0
            mem[_3846 + 32] = 96
            mem[_3846 + 64] = 96
            mem[_3846 + 96] = 0
            mem[_3846 + 128] = 0
            mem[_3846 + 160] = 0
            mem[_3846 + 192] = 0
            mem[_3846 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3891 = mem[64]
                mem[mem[64]] = 2
                _4972 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4972] = 0
                mem[_4972 + 32] = 96
                mem[_4972 + 64] = 96
                mem[_4972 + 96] = 0
                mem[_4972 + 128] = 0
                mem[_4972 + 160] = 0
                mem[_4972 + 192] = 0
                mem[_4972 + 224] = 0
                mem[var182001] = _4972
                s = var182001
                idx = var182002
                while idx - 1:
                    _4972 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4972] = 0
                    mem[_4972 + 32] = 96
                    mem[_4972 + 64] = 96
                    mem[_4972 + 96] = 0
                    mem[_4972 + 128] = 0
                    mem[_4972 + 160] = 0
                    mem[_4972 + 192] = 0
                    mem[_4972 + 224] = 0
                    mem[s + 32] = _4972
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3891]
                mem[_3891 + 32] = _3555
                require 1 < mem[_3891]
                mem[_3891 + 64] = _1805
                _5260 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5260] = 0
                mem[_5260 + 32] = 96
                mem[_5260 + 64] = 96
                mem[_5260 + 96] = 0
                mem[_5260 + 128] = 0
                mem[_5260 + 160] = 0
                mem[_5260 + 192] = 0
                mem[_5260 + 224] = 0
                require 0 < mem[_3891]
                _5538 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5538] = 0
                mem[_5538 + 32] = 96
                mem[_5538 + 64] = 96
                mem[_5538 + 96] = 0
                mem[_5538 + 128] = 0
                mem[_5538 + 160] = 0
                mem[_5538 + 192] = 0
                mem[_5538 + 224] = 0
                require 1 < mem[_3891]
                if mem[_3555 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3555 + 96]
                    while idx >= 4:
                        if not mem[_3555 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3555 + 96] - idx
                        continue 
                    _6243 = mem[_3555 + 96]
                    _6244 = mem[_3555 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6243 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6244 / 10^(_6243 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6244 / 10^(_6243 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6244 / 10^(_6243 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6244 / 10^(_6243 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6244 / 10^(_6243 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6244 / 10^(_6243 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6245 = mem[_3555 + 96]
                _6246 = mem[_3555 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6245 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6246 / 10^(_6245 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6246 / 10^(_6245 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6246 / 10^(_6245 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6246 / 10^(_6245 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6246 / 10^(_6245 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6246 / 10^(_6245 - s))
            if wbnbAddress == address(_1826):
                _3936 = mem[64]
                mem[mem[64]] = 2
                _4971 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4971] = 0
                mem[_4971 + 32] = 96
                mem[_4971 + 64] = 96
                mem[_4971 + 96] = 0
                mem[_4971 + 128] = 0
                mem[_4971 + 160] = 0
                mem[_4971 + 192] = 0
                mem[_4971 + 224] = 0
                mem[var185001] = _4971
                s = var185001
                idx = var185002
                while idx - 1:
                    _4971 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4971] = 0
                    mem[_4971 + 32] = 96
                    mem[_4971 + 64] = 96
                    mem[_4971 + 96] = 0
                    mem[_4971 + 128] = 0
                    mem[_4971 + 160] = 0
                    mem[_4971 + 192] = 0
                    mem[_4971 + 224] = 0
                    mem[s + 32] = _4971
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3936]
                mem[_3936 + 32] = _1805
                require 1 < mem[_3936]
                mem[_3936 + 64] = _3555
                _5259 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5259] = 0
                mem[_5259 + 32] = 96
                mem[_5259 + 64] = 96
                mem[_5259 + 96] = 0
                mem[_5259 + 128] = 0
                mem[_5259 + 160] = 0
                mem[_5259 + 192] = 0
                mem[_5259 + 224] = 0
                require 0 < mem[_3936]
                _5537 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5537] = 0
                mem[_5537 + 32] = 96
                mem[_5537 + 64] = 96
                mem[_5537 + 96] = 0
                mem[_5537 + 128] = 0
                mem[_5537 + 160] = 0
                mem[_5537 + 192] = 0
                mem[_5537 + 224] = 0
                require 1 < mem[_3936]
                if mem[_1805 + 96] <= mem[_3555 + 96]:
                    idx = 12
                    s = mem[_1805 + 96]
                    while idx >= 4:
                        if not mem[_1805 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1805 + 96] - idx
                        continue 
                    _6239 = mem[_1805 + 96]
                    _6240 = mem[_1805 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6239 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3555 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3555 + 128] / 10^(mem[_3555 + 96] - s):
                        if not _6240 / 10^(_6239 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6240 / 10^(_6239 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6240 / 10^(_6239 - s))
                    if 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6240 / 10^(_6239 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _6240 / 10^(_6239 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _6240 / 10^(_6239 - s))
                idx = 12
                s = mem[_3555 + 96]
                while idx >= 4:
                    if not mem[_3555 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3555 + 96] - idx
                    continue 
                _6241 = mem[_1805 + 96]
                _6242 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6241 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3555 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3555 + 128] / 10^(mem[_3555 + 96] - s):
                    if not _6242 / 10^(_6241 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6242 / 10^(_6241 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6242 / 10^(_6241 - s))
                if 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6242 / 10^(_6241 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _6242 / 10^(_6241 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _6242 / 10^(_6241 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3984 = mem[64]
                mem[mem[64]] = 2
                _4970 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4970] = 0
                mem[_4970 + 32] = 96
                mem[_4970 + 64] = 96
                mem[_4970 + 96] = 0
                mem[_4970 + 128] = 0
                mem[_4970 + 160] = 0
                mem[_4970 + 192] = 0
                mem[_4970 + 224] = 0
                mem[var188001] = _4970
                s = var188001
                idx = var188002
                while idx - 1:
                    _4970 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4970] = 0
                    mem[_4970 + 32] = 96
                    mem[_4970 + 64] = 96
                    mem[_4970 + 96] = 0
                    mem[_4970 + 128] = 0
                    mem[_4970 + 160] = 0
                    mem[_4970 + 192] = 0
                    mem[_4970 + 224] = 0
                    mem[s + 32] = _4970
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3984]
                mem[_3984 + 32] = _3555
                require 1 < mem[_3984]
                mem[_3984 + 64] = _1805
                _5258 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5258] = 0
                mem[_5258 + 32] = 96
                mem[_5258 + 64] = 96
                mem[_5258 + 96] = 0
                mem[_5258 + 128] = 0
                mem[_5258 + 160] = 0
                mem[_5258 + 192] = 0
                mem[_5258 + 224] = 0
                require 0 < mem[_3984]
                _5536 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5536] = 0
                mem[_5536 + 32] = 96
                mem[_5536 + 64] = 96
                mem[_5536 + 96] = 0
                mem[_5536 + 128] = 0
                mem[_5536 + 160] = 0
                mem[_5536 + 192] = 0
                mem[_5536 + 224] = 0
                require 1 < mem[_3984]
                if mem[_3555 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3555 + 96]
                    while idx >= 4:
                        if not mem[_3555 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3555 + 96] - idx
                        continue 
                    _6235 = mem[_3555 + 96]
                    _6236 = mem[_3555 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6235 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6236 / 10^(_6235 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6236 / 10^(_6235 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6236 / 10^(_6235 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6236 / 10^(_6235 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6236 / 10^(_6235 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6236 / 10^(_6235 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6237 = mem[_3555 + 96]
                _6238 = mem[_3555 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6238 / 10^(_6237 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6238 / 10^(_6237 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6238 / 10^(_6237 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6238 / 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6238 / 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6238 / 10^(_6237 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4032 = mem[64]
                mem[mem[64]] = 2
                _4969 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4969] = 0
                mem[_4969 + 32] = 96
                mem[_4969 + 64] = 96
                mem[_4969 + 96] = 0
                mem[_4969 + 128] = 0
                mem[_4969 + 160] = 0
                mem[_4969 + 192] = 0
                mem[_4969 + 224] = 0
                mem[var191001] = _4969
                s = var191001
                idx = var191002
                while idx - 1:
                    _4969 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4969] = 0
                    mem[_4969 + 32] = 96
                    mem[_4969 + 64] = 96
                    mem[_4969 + 96] = 0
                    mem[_4969 + 128] = 0
                    mem[_4969 + 160] = 0
                    mem[_4969 + 192] = 0
                    mem[_4969 + 224] = 0
                    mem[s + 32] = _4969
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4032]
                mem[_4032 + 32] = _3555
                require 1 < mem[_4032]
                mem[_4032 + 64] = _1805
                _5257 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5257] = 0
                mem[_5257 + 32] = 96
                mem[_5257 + 64] = 96
                mem[_5257 + 96] = 0
                mem[_5257 + 128] = 0
                mem[_5257 + 160] = 0
                mem[_5257 + 192] = 0
                mem[_5257 + 224] = 0
                require 0 < mem[_4032]
                _5535 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5535] = 0
                mem[_5535 + 32] = 96
                mem[_5535 + 64] = 96
                mem[_5535 + 96] = 0
                mem[_5535 + 128] = 0
                mem[_5535 + 160] = 0
                mem[_5535 + 192] = 0
                mem[_5535 + 224] = 0
                require 1 < mem[_4032]
                if mem[_3555 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3555 + 96]
                    while idx >= 4:
                        if not mem[_3555 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3555 + 96] - idx
                        continue 
                    _6231 = mem[_3555 + 96]
                    _6232 = mem[_3555 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6231 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1805 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                        if not _6232 / 10^(_6231 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6232 / 10^(_6231 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6232 / 10^(_6231 - s))
                    if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6232 / 10^(_6231 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6232 / 10^(_6231 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6232 / 10^(_6231 - s))
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6233 = mem[_3555 + 96]
                _6234 = mem[_3555 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6234 / 10^(_6233 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6234 / 10^(_6233 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6234 / 10^(_6233 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6234 / 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6234 / 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6234 / 10^(_6233 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4435 = mem[64]
                mem[mem[64]] = 2
                _6006 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_6006] = 0
                mem[_6006 + 32] = 96
                mem[_6006 + 64] = 96
                mem[_6006 + 96] = 0
                mem[_6006 + 128] = 0
                mem[_6006 + 160] = 0
                mem[_6006 + 192] = 0
                mem[_6006 + 224] = 0
                mem[var200001] = _6006
                s = var200001
                idx = var200002
                while idx - 1:
                    _6006 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6006] = 0
                    mem[_6006 + 32] = 96
                    mem[_6006 + 64] = 96
                    mem[_6006 + 96] = 0
                    mem[_6006 + 128] = 0
                    mem[_6006 + 160] = 0
                    mem[_6006 + 192] = 0
                    mem[_6006 + 224] = 0
                    mem[s + 32] = _6006
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4435]
                mem[_4435 + 32] = _3555
                require 1 < mem[_4435]
                mem[_4435 + 64] = _1805
                _6566 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6566] = 0
                mem[_6566 + 32] = 96
                mem[_6566 + 64] = 96
                mem[_6566 + 96] = 0
                mem[_6566 + 128] = 0
                mem[_6566 + 160] = 0
                mem[_6566 + 192] = 0
                mem[_6566 + 224] = 0
                require 0 < mem[_4435]
                _6838 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6838] = 0
                mem[_6838 + 32] = 96
                mem[_6838 + 64] = 96
                mem[_6838 + 96] = 0
                mem[_6838 + 128] = 0
                mem[_6838 + 160] = 0
                mem[_6838 + 192] = 0
                mem[_6838 + 224] = 0
                require 1 < mem[_4435]
                if mem[_3555 + 96] <= mem[_1805 + 96]:
                    idx = 12
                    s = mem[_3555 + 96]
                    while idx >= 4:
                        if not mem[_3555 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3555 + 96] - idx
                        continue 
                    _13077 = mem[_3555 + 96]
                    _13078 = mem[_3555 + 128]
                    _13163 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13163] = 26
                    mem[_13163 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13077 - s):
                        _13707 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13707 + 68] = mem[idx + _13163 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13707 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13707 + -mem[64] + 100
                    _14933 = mem[_1805 + 96]
                    _14934 = mem[_1805 + 128]
                    _15061 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15061] = 26
                    mem[_15061 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14933 - s):
                        _15147 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15147 + 68] = mem[idx + _15061 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15147 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15147 + -mem[64] + 100
                    if not _14934 / 10^(_14933 - s):
                        _15531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15531] = 26
                        mem[_15531 + 32] = 'SafeMath: division by zero'
                        if not _13078 / 10^(_13077 - s):
                            _15808 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15808 + 68] = mem[idx + _15531 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15808 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15808 + -mem[64] + 100
                        _16341 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16341] = 26
                        mem[_16341 + 32] = 'SafeMath: division by zero'
                        if 0 / _13078 / 10^(_13077 - s):
                            return (1000000 * 10^18 / 0 / _13078 / 10^(_13077 - s))
                        _16577 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16577 + 68] = mem[idx + _16341 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16577 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16577 + -mem[64] + 100
                    if 10^12 * _14934 / 10^(_14933 - s) / _14934 / 10^(_14933 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15807 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15807] = 26
                    mem[_15807 + 32] = 'SafeMath: division by zero'
                    if not _13078 / 10^(_13077 - s):
                        _15957 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15957 + 68] = mem[idx + _15807 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15957 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15957 + -mem[64] + 100
                    _16575 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16575] = 26
                    mem[_16575 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14934 / 10^(_14933 - s) / _13078 / 10^(_13077 - s):
                        return (1000000 * 10^18 / 10^12 * _14934 / 10^(_14933 - s) / _13078 / 10^(_13077 - s))
                    _16725 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16725 + 68] = mem[idx + _16575 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16725 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16725 + -mem[64] + 100
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _13079 = mem[_3555 + 96]
                _13080 = mem[_3555 + 128]
                _13164 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13164] = 26
                mem[_13164 + 32] = 'SafeMath: division by zero'
                if not 10^(_13079 - s):
                    _13708 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13708 + 68] = mem[idx + _13164 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13708 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13708 + -mem[64] + 100
                _14935 = mem[_1805 + 96]
                _14936 = mem[_1805 + 128]
                _15063 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15063] = 26
                mem[_15063 + 32] = 'SafeMath: division by zero'
                if not 10^(_14935 - s):
                    _15148 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15148 + 68] = mem[idx + _15063 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15148 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15148 + -mem[64] + 100
                if not _14936 / 10^(_14935 - s):
                    _15532 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15532] = 26
                    mem[_15532 + 32] = 'SafeMath: division by zero'
                    if not _13080 / 10^(_13079 - s):
                        _15811 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15811 + 68] = mem[idx + _15532 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15811 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15811 + -mem[64] + 100
                    _16343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16343] = 26
                    mem[_16343 + 32] = 'SafeMath: division by zero'
                    if 0 / _13080 / 10^(_13079 - s):
                        return (1000000 * 10^18 / 0 / _13080 / 10^(_13079 - s))
                    _16580 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16580 + 68] = mem[idx + _16343 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16580 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16580 + -mem[64] + 100
                if 10^12 * _14936 / 10^(_14935 - s) / _14936 / 10^(_14935 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15810 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15810] = 26
                mem[_15810 + 32] = 'SafeMath: division by zero'
                if not _13080 / 10^(_13079 - s):
                    _15959 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15959 + 68] = mem[idx + _15810 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15959 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15959 + -mem[64] + 100
                _16578 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16578] = 26
                mem[_16578 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14936 / 10^(_14935 - s) / _13080 / 10^(_13079 - s):
                    return (1000000 * 10^18 / 10^12 * _14936 / 10^(_14935 - s) / _13080 / 10^(_13079 - s))
                _16727 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16727 + 68] = mem[idx + _16578 + 32]
                    idx = idx + 32
                    continue 
                mem[_16727 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16727 + -mem[64] + 100
            _4275 = mem[64]
            mem[mem[64]] = 2
            _6005 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6005] = 0
            mem[_6005 + 32] = 96
            mem[_6005 + 64] = 96
            mem[_6005 + 96] = 0
            mem[_6005 + 128] = 0
            mem[_6005 + 160] = 0
            mem[_6005 + 192] = 0
            mem[_6005 + 224] = 0
            mem[var196001] = _6005
            s = var196001
            idx = var196002
            while idx - 1:
                _6005 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6005] = 0
                mem[_6005 + 32] = 96
                mem[_6005 + 64] = 96
                mem[_6005 + 96] = 0
                mem[_6005 + 128] = 0
                mem[_6005 + 160] = 0
                mem[_6005 + 192] = 0
                mem[_6005 + 224] = 0
                mem[s + 32] = _6005
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4275]
            mem[_4275 + 32] = _1805
            require 1 < mem[_4275]
            mem[_4275 + 64] = _3555
            _6565 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6565] = 0
            mem[_6565 + 32] = 96
            mem[_6565 + 64] = 96
            mem[_6565 + 96] = 0
            mem[_6565 + 128] = 0
            mem[_6565 + 160] = 0
            mem[_6565 + 192] = 0
            mem[_6565 + 224] = 0
            require 0 < mem[_4275]
            _6837 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6837] = 0
            mem[_6837 + 32] = 96
            mem[_6837 + 64] = 96
            mem[_6837 + 96] = 0
            mem[_6837 + 128] = 0
            mem[_6837 + 160] = 0
            mem[_6837 + 192] = 0
            mem[_6837 + 224] = 0
            require 1 < mem[_4275]
            if mem[_1805 + 96] <= mem[_3555 + 96]:
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _13073 = mem[_1805 + 96]
                _13074 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13073 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3555 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3555 + 128] / 10^(mem[_3555 + 96] - s):
                    if not _13074 / 10^(_13073 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13074 / 10^(_13073 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13074 / 10^(_13073 - s))
                if 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13074 / 10^(_13073 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _13074 / 10^(_13073 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _13074 / 10^(_13073 - s))
            idx = 12
            s = mem[_3555 + 96]
            while idx >= 4:
                if not mem[_3555 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3555 + 96] - idx
                continue 
            _13075 = mem[_1805 + 96]
            _13076 = mem[_1805 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13075 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3555 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3555 + 128] / 10^(mem[_3555 + 96] - s):
                if not _13076 / 10^(_13075 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13076 / 10^(_13075 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13076 / 10^(_13075 - s))
            if 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13076 / 10^(_13075 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _13076 / 10^(_13075 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3555 + 128] / 10^(mem[_3555 + 96] - s) / _13076 / 10^(_13075 - s))
        mem[_2663 + ceil32(return_data.size) + _2679 + 32] = 0
        require ext_code.size(address(_1826))
        staticcall address(_1826).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3470 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3486 = mem[_3470]
        require mem[_3470] == mem[_3470 + 31 len 1]
        require ext_code.size(address(_1826))
        staticcall address(_1826).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3534 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3556 = mem[_3534]
        _3578 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3578] = address(_1826)
        mem[_3578 + 32] = _1842 + ceil32(return_data.size)
        mem[_3578 + 64] = _2663 + ceil32(return_data.size)
        mem[_3578 + 96] = uint8(_3486)
        mem[_3578 + 128] = 0
        mem[_3578 + 160] = _3556
        mem[_3578 + 192] = 0
        mem[_3578 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3614 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3630 = mem[_3614]
        require mem[_3614] == mem[_3614 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3630))
        staticcall address(_3630).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3678 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1805 + 128] = mem[_3678]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3742 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3758 = mem[_3742]
        require mem[_3742] == mem[_3742 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3758))
        staticcall address(_3758).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3806 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3578 + 128] = mem[_3806]
        _3838 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3838] = 0
        mem[_3838 + 32] = 96
        mem[_3838 + 64] = 96
        mem[_3838 + 96] = 0
        mem[_3838 + 128] = 0
        mem[_3838 + 160] = 0
        mem[_3838 + 192] = 0
        mem[_3838 + 224] = 0
        _3860 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3860] = 0
        mem[_3860 + 32] = 96
        mem[_3860 + 64] = 96
        mem[_3860 + 96] = 0
        mem[_3860 + 128] = 0
        mem[_3860 + 160] = 0
        mem[_3860 + 192] = 0
        mem[_3860 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3902 = mem[64]
            mem[mem[64]] = 2
            _4976 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4976] = 0
            mem[_4976 + 32] = 96
            mem[_4976 + 64] = 96
            mem[_4976 + 96] = 0
            mem[_4976 + 128] = 0
            mem[_4976 + 160] = 0
            mem[_4976 + 192] = 0
            mem[_4976 + 224] = 0
            mem[var183001] = _4976
            s = var183001
            idx = var183002
            while idx - 1:
                _4976 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4976] = 0
                mem[_4976 + 32] = 96
                mem[_4976 + 64] = 96
                mem[_4976 + 96] = 0
                mem[_4976 + 128] = 0
                mem[_4976 + 160] = 0
                mem[_4976 + 192] = 0
                mem[_4976 + 224] = 0
                mem[s + 32] = _4976
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3902]
            mem[_3902 + 32] = _3578
            require 1 < mem[_3902]
            mem[_3902 + 64] = _1805
            _5264 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5264] = 0
            mem[_5264 + 32] = 96
            mem[_5264 + 64] = 96
            mem[_5264 + 96] = 0
            mem[_5264 + 128] = 0
            mem[_5264 + 160] = 0
            mem[_5264 + 192] = 0
            mem[_5264 + 224] = 0
            require 0 < mem[_3902]
            _5544 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5544] = 0
            mem[_5544 + 32] = 96
            mem[_5544 + 64] = 96
            mem[_5544 + 96] = 0
            mem[_5544 + 128] = 0
            mem[_5544 + 160] = 0
            mem[_5544 + 192] = 0
            mem[_5544 + 224] = 0
            require 1 < mem[_3902]
            if mem[_3578 + 96] <= mem[_1805 + 96]:
                idx = 12
                s = mem[_3578 + 96]
                while idx >= 4:
                    if not mem[_3578 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3578 + 96] - idx
                    continue 
                _6261 = mem[_3578 + 96]
                _6262 = mem[_3578 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6261 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6262 / 10^(_6261 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6262 / 10^(_6261 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6262 / 10^(_6261 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6262 / 10^(_6261 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6262 / 10^(_6261 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6262 / 10^(_6261 - s))
            idx = 12
            s = mem[_1805 + 96]
            while idx >= 4:
                if not mem[_1805 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1805 + 96] - idx
                continue 
            _6263 = mem[_3578 + 96]
            _6264 = mem[_3578 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6263 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1805 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                if not _6264 / 10^(_6263 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6264 / 10^(_6263 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6264 / 10^(_6263 - s))
            if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6264 / 10^(_6263 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6264 / 10^(_6263 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6264 / 10^(_6263 - s))
        if wbnbAddress == address(_1826):
            _3950 = mem[64]
            mem[mem[64]] = 2
            _4975 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4975] = 0
            mem[_4975 + 32] = 96
            mem[_4975 + 64] = 96
            mem[_4975 + 96] = 0
            mem[_4975 + 128] = 0
            mem[_4975 + 160] = 0
            mem[_4975 + 192] = 0
            mem[_4975 + 224] = 0
            mem[var186001] = _4975
            s = var186001
            idx = var186002
            while idx - 1:
                _4975 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4975] = 0
                mem[_4975 + 32] = 96
                mem[_4975 + 64] = 96
                mem[_4975 + 96] = 0
                mem[_4975 + 128] = 0
                mem[_4975 + 160] = 0
                mem[_4975 + 192] = 0
                mem[_4975 + 224] = 0
                mem[s + 32] = _4975
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3950]
            mem[_3950 + 32] = _1805
            require 1 < mem[_3950]
            mem[_3950 + 64] = _3578
            _5263 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5263] = 0
            mem[_5263 + 32] = 96
            mem[_5263 + 64] = 96
            mem[_5263 + 96] = 0
            mem[_5263 + 128] = 0
            mem[_5263 + 160] = 0
            mem[_5263 + 192] = 0
            mem[_5263 + 224] = 0
            require 0 < mem[_3950]
            _5543 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5543] = 0
            mem[_5543 + 32] = 96
            mem[_5543 + 64] = 96
            mem[_5543 + 96] = 0
            mem[_5543 + 128] = 0
            mem[_5543 + 160] = 0
            mem[_5543 + 192] = 0
            mem[_5543 + 224] = 0
            require 1 < mem[_3950]
            if mem[_1805 + 96] <= mem[_3578 + 96]:
                idx = 12
                s = mem[_1805 + 96]
                while idx >= 4:
                    if not mem[_1805 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1805 + 96] - idx
                    continue 
                _6257 = mem[_1805 + 96]
                _6258 = mem[_1805 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6257 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3578 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3578 + 128] / 10^(mem[_3578 + 96] - s):
                    if not _6258 / 10^(_6257 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6258 / 10^(_6257 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6258 / 10^(_6257 - s))
                if 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6258 / 10^(_6257 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _6258 / 10^(_6257 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _6258 / 10^(_6257 - s))
            idx = 12
            s = mem[_3578 + 96]
            while idx >= 4:
                if not mem[_3578 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3578 + 96] - idx
                continue 
            _6259 = mem[_1805 + 96]
            _6260 = mem[_1805 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6259 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3578 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3578 + 128] / 10^(mem[_3578 + 96] - s):
                if not _6260 / 10^(_6259 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6260 / 10^(_6259 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6260 / 10^(_6259 - s))
            if 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6260 / 10^(_6259 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _6260 / 10^(_6259 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _6260 / 10^(_6259 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3998 = mem[64]
            mem[mem[64]] = 2
            _4974 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4974] = 0
            mem[_4974 + 32] = 96
            mem[_4974 + 64] = 96
            mem[_4974 + 96] = 0
            mem[_4974 + 128] = 0
            mem[_4974 + 160] = 0
            mem[_4974 + 192] = 0
            mem[_4974 + 224] = 0
            mem[var189001] = _4974
            s = var189001
            idx = var189002
            while idx - 1:
                _4974 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4974] = 0
                mem[_4974 + 32] = 96
                mem[_4974 + 64] = 96
                mem[_4974 + 96] = 0
                mem[_4974 + 128] = 0
                mem[_4974 + 160] = 0
                mem[_4974 + 192] = 0
                mem[_4974 + 224] = 0
                mem[s + 32] = _4974
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3998]
            mem[_3998 + 32] = _3578
            require 1 < mem[_3998]
            mem[_3998 + 64] = _1805
            _5262 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5262] = 0
            mem[_5262 + 32] = 96
            mem[_5262 + 64] = 96
            mem[_5262 + 96] = 0
            mem[_5262 + 128] = 0
            mem[_5262 + 160] = 0
            mem[_5262 + 192] = 0
            mem[_5262 + 224] = 0
            require 0 < mem[_3998]
            _5542 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5542] = 0
            mem[_5542 + 32] = 96
            mem[_5542 + 64] = 96
            mem[_5542 + 96] = 0
            mem[_5542 + 128] = 0
            mem[_5542 + 160] = 0
            mem[_5542 + 192] = 0
            mem[_5542 + 224] = 0
            require 1 < mem[_3998]
            if mem[_3578 + 96] <= mem[_1805 + 96]:
                idx = 12
                s = mem[_3578 + 96]
                while idx >= 4:
                    if not mem[_3578 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3578 + 96] - idx
                    continue 
                _6253 = mem[_3578 + 96]
                _6254 = mem[_3578 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6253 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6254 / 10^(_6253 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6254 / 10^(_6253 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6254 / 10^(_6253 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6254 / 10^(_6253 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6254 / 10^(_6253 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6254 / 10^(_6253 - s))
            idx = 12
            s = mem[_1805 + 96]
            while idx >= 4:
                if not mem[_1805 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1805 + 96] - idx
                continue 
            _6255 = mem[_3578 + 96]
            _6256 = mem[_3578 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6255 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1805 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                if not _6256 / 10^(_6255 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6256 / 10^(_6255 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6256 / 10^(_6255 - s))
            if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6256 / 10^(_6255 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6256 / 10^(_6255 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6256 / 10^(_6255 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4046 = mem[64]
            mem[mem[64]] = 2
            _4973 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4973] = 0
            mem[_4973 + 32] = 96
            mem[_4973 + 64] = 96
            mem[_4973 + 96] = 0
            mem[_4973 + 128] = 0
            mem[_4973 + 160] = 0
            mem[_4973 + 192] = 0
            mem[_4973 + 224] = 0
            mem[var192001] = _4973
            s = var192001
            idx = var192002
            while idx - 1:
                _4973 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4973] = 0
                mem[_4973 + 32] = 96
                mem[_4973 + 64] = 96
                mem[_4973 + 96] = 0
                mem[_4973 + 128] = 0
                mem[_4973 + 160] = 0
                mem[_4973 + 192] = 0
                mem[_4973 + 224] = 0
                mem[s + 32] = _4973
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4046]
            mem[_4046 + 32] = _3578
            require 1 < mem[_4046]
            mem[_4046 + 64] = _1805
            _5261 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5261] = 0
            mem[_5261 + 32] = 96
            mem[_5261 + 64] = 96
            mem[_5261 + 96] = 0
            mem[_5261 + 128] = 0
            mem[_5261 + 160] = 0
            mem[_5261 + 192] = 0
            mem[_5261 + 224] = 0
            require 0 < mem[_4046]
            _5541 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5541] = 0
            mem[_5541 + 32] = 96
            mem[_5541 + 64] = 96
            mem[_5541 + 96] = 0
            mem[_5541 + 128] = 0
            mem[_5541 + 160] = 0
            mem[_5541 + 192] = 0
            mem[_5541 + 224] = 0
            require 1 < mem[_4046]
            if mem[_3578 + 96] <= mem[_1805 + 96]:
                idx = 12
                s = mem[_3578 + 96]
                while idx >= 4:
                    if not mem[_3578 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3578 + 96] - idx
                    continue 
                _6249 = mem[_3578 + 96]
                _6250 = mem[_3578 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6249 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1805 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                    if not _6250 / 10^(_6249 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6250 / 10^(_6249 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6250 / 10^(_6249 - s))
                if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6250 / 10^(_6249 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6250 / 10^(_6249 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6250 / 10^(_6249 - s))
            idx = 12
            s = mem[_1805 + 96]
            while idx >= 4:
                if not mem[_1805 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1805 + 96] - idx
                continue 
            _6251 = mem[_3578 + 96]
            _6252 = mem[_3578 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6251 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1805 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1805 + 128] / 10^(mem[_1805 + 96] - s):
                if not _6252 / 10^(_6251 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6252 / 10^(_6251 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6252 / 10^(_6251 - s))
            if 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6252 / 10^(_6251 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6252 / 10^(_6251 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1805 + 128] / 10^(mem[_1805 + 96] - s) / _6252 / 10^(_6251 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4440 = mem[64]
            mem[mem[64]] = 2
            _6008 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6008] = 0
            mem[_6008 + 32] = 96
            mem[_6008 + 64] = 96
            mem[_6008 + 96] = 0
            mem[_6008 + 128] = 0
            mem[_6008 + 160] = 0
            mem[_6008 + 192] = 0
            mem[_6008 + 224] = 0
            mem[var201001] = _6008
            s = var201001
            idx = var201002
            while idx - 1:
                _6008 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6008] = 0
                mem[_6008 + 32] = 96
                mem[_6008 + 64] = 96
                mem[_6008 + 96] = 0
                mem[_6008 + 128] = 0
                mem[_6008 + 160] = 0
                mem[_6008 + 192] = 0
                mem[_6008 + 224] = 0
                mem[s + 32] = _6008
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4440]
            mem[_4440 + 32] = _3578
            require 1 < mem[_4440]
            mem[_4440 + 64] = _1805
            _6576 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6576] = 0
            mem[_6576 + 32] = 96
            mem[_6576 + 64] = 96
            mem[_6576 + 96] = 0
            mem[_6576 + 128] = 0
            mem[_6576 + 160] = 0
            mem[_6576 + 192] = 0
            mem[_6576 + 224] = 0
            require 0 < mem[_4440]
            _6840 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6840] = 0
            mem[_6840 + 32] = 96
            mem[_6840 + 64] = 96
            mem[_6840 + 96] = 0
            mem[_6840 + 128] = 0
            mem[_6840 + 160] = 0
            mem[_6840 + 192] = 0
            mem[_6840 + 224] = 0
            require 1 < mem[_4440]
            if mem[_3578 + 96] <= mem[_1805 + 96]:
                idx = 12
                s = mem[_3578 + 96]
                while idx >= 4:
                    if not mem[_3578 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3578 + 96] - idx
                    continue 
                _13085 = mem[_3578 + 96]
                _13086 = mem[_3578 + 128]
                _13167 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13167] = 26
                mem[_13167 + 32] = 'SafeMath: division by zero'
                if not 10^(_13085 - s):
                    _13759 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13759 + 68] = mem[idx + _13167 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13759 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13759 + -mem[64] + 100
                _14941 = mem[_1805 + 96]
                _14942 = mem[_1805 + 128]
                _15069 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15069] = 26
                mem[_15069 + 32] = 'SafeMath: division by zero'
                if not 10^(_14941 - s):
                    _15151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15151 + 68] = mem[idx + _15069 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15151 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15151 + -mem[64] + 100
                if not _14942 / 10^(_14941 - s):
                    _15535 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15535] = 26
                    mem[_15535 + 32] = 'SafeMath: division by zero'
                    if not _13086 / 10^(_13085 - s):
                        _15820 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15820 + 68] = mem[idx + _15535 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15820 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15820 + -mem[64] + 100
                    _16349 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16349] = 26
                    mem[_16349 + 32] = 'SafeMath: division by zero'
                    if 0 / _13086 / 10^(_13085 - s):
                        return (1000000 * 10^18 / 0 / _13086 / 10^(_13085 - s))
                    _16589 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16589 + 68] = mem[idx + _16349 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16589 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16589 + -mem[64] + 100
                if 10^12 * _14942 / 10^(_14941 - s) / _14942 / 10^(_14941 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15819 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15819] = 26
                mem[_15819 + 32] = 'SafeMath: division by zero'
                if not _13086 / 10^(_13085 - s):
                    _15965 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15965 + 68] = mem[idx + _15819 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15965 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15965 + -mem[64] + 100
                _16587 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16587] = 26
                mem[_16587 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14942 / 10^(_14941 - s) / _13086 / 10^(_13085 - s):
                    return (1000000 * 10^18 / 10^12 * _14942 / 10^(_14941 - s) / _13086 / 10^(_13085 - s))
                _16733 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16733 + 68] = mem[idx + _16587 + 32]
                    idx = idx + 32
                    continue 
                mem[_16733 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16733 + -mem[64] + 100
            idx = 12
            s = mem[_1805 + 96]
            while idx >= 4:
                if not mem[_1805 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1805 + 96] - idx
                continue 
            _13087 = mem[_3578 + 96]
            _13088 = mem[_3578 + 128]
            _13168 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13168] = 26
            mem[_13168 + 32] = 'SafeMath: division by zero'
            if not 10^(_13087 - s):
                _13760 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13760 + 68] = mem[idx + _13168 + 32]
                    idx = idx + 32
                    continue 
                mem[_13760 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13760 + -mem[64] + 100
            _14943 = mem[_1805 + 96]
            _14944 = mem[_1805 + 128]
            _15071 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15071] = 26
            mem[_15071 + 32] = 'SafeMath: division by zero'
            if not 10^(_14943 - s):
                _15152 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15152 + 68] = mem[idx + _15071 + 32]
                    idx = idx + 32
                    continue 
                mem[_15152 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15152 + -mem[64] + 100
            if not _14944 / 10^(_14943 - s):
                _15536 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15536] = 26
                mem[_15536 + 32] = 'SafeMath: division by zero'
                if not _13088 / 10^(_13087 - s):
                    _15823 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15823 + 68] = mem[idx + _15536 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15823 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15823 + -mem[64] + 100
                _16351 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16351] = 26
                mem[_16351 + 32] = 'SafeMath: division by zero'
                if 0 / _13088 / 10^(_13087 - s):
                    return (1000000 * 10^18 / 0 / _13088 / 10^(_13087 - s))
                _16592 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16592 + 68] = mem[idx + _16351 + 32]
                    idx = idx + 32
                    continue 
                mem[_16592 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16592 + -mem[64] + 100
            if 10^12 * _14944 / 10^(_14943 - s) / _14944 / 10^(_14943 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15822 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15822] = 26
            mem[_15822 + 32] = 'SafeMath: division by zero'
            if not _13088 / 10^(_13087 - s):
                _15967 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15967 + 68] = mem[idx + _15822 + 32]
                    idx = idx + 32
                    continue 
                mem[_15967 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15967 + -mem[64] + 100
            _16590 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16590] = 26
            mem[_16590 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14944 / 10^(_14943 - s) / _13088 / 10^(_13087 - s):
                return (1000000 * 10^18 / 10^12 * _14944 / 10^(_14943 - s) / _13088 / 10^(_13087 - s))
            _16735 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16735 + 68] = mem[idx + _16590 + 32]
                idx = idx + 32
                continue 
            mem[_16735 + 94] = 0
            revert with memory
              from mem[64]
               len _16735 + -mem[64] + 100
        _4280 = mem[64]
        mem[mem[64]] = 2
        _6007 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_6007] = 0
        mem[_6007 + 32] = 96
        mem[_6007 + 64] = 96
        mem[_6007 + 96] = 0
        mem[_6007 + 128] = 0
        mem[_6007 + 160] = 0
        mem[_6007 + 192] = 0
        mem[_6007 + 224] = 0
        mem[var197001] = _6007
        s = var197001
        idx = var197002
        while idx - 1:
            _6007 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6007] = 0
            mem[_6007 + 32] = 96
            mem[_6007 + 64] = 96
            mem[_6007 + 96] = 0
            mem[_6007 + 128] = 0
            mem[_6007 + 160] = 0
            mem[_6007 + 192] = 0
            mem[_6007 + 224] = 0
            mem[s + 32] = _6007
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4280]
        mem[_4280 + 32] = _1805
        require 1 < mem[_4280]
        mem[_4280 + 64] = _3578
        _6575 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6575] = 0
        mem[_6575 + 32] = 96
        mem[_6575 + 64] = 96
        mem[_6575 + 96] = 0
        mem[_6575 + 128] = 0
        mem[_6575 + 160] = 0
        mem[_6575 + 192] = 0
        mem[_6575 + 224] = 0
        require 0 < mem[_4280]
        _6839 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6839] = 0
        mem[_6839 + 32] = 96
        mem[_6839 + 64] = 96
        mem[_6839 + 96] = 0
        mem[_6839 + 128] = 0
        mem[_6839 + 160] = 0
        mem[_6839 + 192] = 0
        mem[_6839 + 224] = 0
        require 1 < mem[_4280]
        if mem[_1805 + 96] <= mem[_3578 + 96]:
            idx = 12
            s = mem[_1805 + 96]
            while idx >= 4:
                if not mem[_1805 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1805 + 96] - idx
                continue 
            _13081 = mem[_1805 + 96]
            _13082 = mem[_1805 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13081 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3578 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3578 + 128] / 10^(mem[_3578 + 96] - s):
                if not _13082 / 10^(_13081 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13082 / 10^(_13081 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13082 / 10^(_13081 - s))
            if 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13082 / 10^(_13081 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _13082 / 10^(_13081 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _13082 / 10^(_13081 - s))
        idx = 12
        s = mem[_3578 + 96]
        while idx >= 4:
            if not mem[_3578 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3578 + 96] - idx
            continue 
        _13083 = mem[_1805 + 96]
        _13084 = mem[_1805 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13083 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3578 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3578 + 128] / 10^(mem[_3578 + 96] - s):
            if not _13084 / 10^(_13083 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13084 / 10^(_13083 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13084 / 10^(_13083 - s))
        if 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13084 / 10^(_13083 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _13084 / 10^(_13083 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3578 + 128] / 10^(mem[_3578 + 96] - s) / _13084 / 10^(_13083 - s))
    mem[_898 + ceil32(return_data.size) + _902 + 32] = 0
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1784 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1788 = mem[_1784]
    require mem[_1784] == mem[_1784 + 31 len 1]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1800 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1806 = mem[_1800]
    _1808 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1808] = address(ext_call.return_data[0])
    mem[_1808 + 32] = (2 * ceil32(return_data.size)) + 608
    mem[_1808 + 64] = _898 + ceil32(return_data.size)
    mem[_1808 + 96] = uint8(_1788)
    mem[_1808 + 128] = 0
    mem[_1808 + 160] = _1806
    mem[_1808 + 192] = 0
    mem[_1808 + 224] = 0
    _1816 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1816] = 0
    mem[_1816 + 32] = 96
    mem[_1816 + 64] = 96
    mem[_1816 + 96] = 0
    mem[_1816 + 128] = 0
    mem[_1816 + 160] = 0
    mem[_1816 + 192] = 0
    mem[_1816 + 224] = 0
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1824 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1828 = mem[_1824]
    require mem[_1824] == mem[_1824 + 12 len 20]
    _1836 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1836] = 0
    mem[_1836 + 32] = 96
    mem[_1836 + 64] = 96
    mem[_1836 + 96] = 0
    mem[_1836 + 128] = 0
    mem[_1836 + 160] = 0
    mem[_1836 + 192] = 0
    mem[_1836 + 224] = 0
    mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(_1828))
    staticcall address(_1828).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1844 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1848 = mem[_1844]
    require mem[_1844] <= test266151307()
    require _1844 + mem[_1844] + 31 < _1844 + return_data.size
    _1852 = mem[_1844 + mem[_1844]]
    require mem[_1844 + mem[_1844]] <= test266151307()
    require ceil32(mem[_1844 + mem[_1844]]) + 32 >= 0 and _1844 + ceil32(return_data.size) + ceil32(mem[_1844 + mem[_1844]]) + 32 <= test266151307()
    mem[64] = _1844 + ceil32(return_data.size) + ceil32(mem[_1844 + mem[_1844]]) + 32
    mem[_1844 + ceil32(return_data.size)] = _1852
    require _1848 + _1852 + 32 <= return_data.size
    mem[_1844 + ceil32(return_data.size) + 32 len ceil32(_1852)] = mem[_1844 + _1848 + 32 len ceil32(_1852)]
    if ceil32(_1852) <= _1852:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1828))
        staticcall address(_1828).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2660 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2668 = mem[_2660]
        require mem[_2660] <= test266151307()
        require _2660 + mem[_2660] + 31 < _2660 + return_data.size
        _2676 = mem[_2660 + mem[_2660]]
        require mem[_2660 + mem[_2660]] <= test266151307()
        require ceil32(mem[_2660 + mem[_2660]]) + 32 >= 0 and _2660 + ceil32(return_data.size) + ceil32(mem[_2660 + mem[_2660]]) + 32 <= test266151307()
        mem[64] = _2660 + ceil32(return_data.size) + ceil32(mem[_2660 + mem[_2660]]) + 32
        mem[_2660 + ceil32(return_data.size)] = _2676
        require _2668 + _2676 + 32 <= return_data.size
        mem[_2660 + ceil32(return_data.size) + 32 len ceil32(_2676)] = mem[_2660 + _2668 + 32 len ceil32(_2676)]
        if ceil32(_2676) <= _2676:
            require ext_code.size(address(_1828))
            staticcall address(_1828).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3463 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3479 = mem[_3463]
            require mem[_3463] == mem[_3463 + 31 len 1]
            require ext_code.size(address(_1828))
            staticcall address(_1828).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3527 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3543 = mem[_3527]
            _3557 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3557] = address(_1828)
            mem[_3557 + 32] = _1844 + ceil32(return_data.size)
            mem[_3557 + 64] = _2660 + ceil32(return_data.size)
            mem[_3557 + 96] = uint8(_3479)
            mem[_3557 + 128] = 0
            mem[_3557 + 160] = _3543
            mem[_3557 + 192] = 0
            mem[_3557 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3607 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3623 = mem[_3607]
            require mem[_3607] == mem[_3607 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3623))
            staticcall address(_3623).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3671 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1808 + 128] = mem[_3671]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3735 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3751 = mem[_3735]
            require mem[_3735] == mem[_3735 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3751))
            staticcall address(_3751).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3799 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3557 + 128] = mem[_3799]
            _3831 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3831] = 0
            mem[_3831 + 32] = 96
            mem[_3831 + 64] = 96
            mem[_3831 + 96] = 0
            mem[_3831 + 128] = 0
            mem[_3831 + 160] = 0
            mem[_3831 + 192] = 0
            mem[_3831 + 224] = 0
            _3847 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3847] = 0
            mem[_3847 + 32] = 96
            mem[_3847 + 64] = 96
            mem[_3847 + 96] = 0
            mem[_3847 + 128] = 0
            mem[_3847 + 160] = 0
            mem[_3847 + 192] = 0
            mem[_3847 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3893 = mem[64]
                mem[mem[64]] = 2
                _4980 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4980] = 0
                mem[_4980 + 32] = 96
                mem[_4980 + 64] = 96
                mem[_4980 + 96] = 0
                mem[_4980 + 128] = 0
                mem[_4980 + 160] = 0
                mem[_4980 + 192] = 0
                mem[_4980 + 224] = 0
                mem[var182001] = _4980
                s = var182001
                idx = var182002
                while idx - 1:
                    _4980 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4980] = 0
                    mem[_4980 + 32] = 96
                    mem[_4980 + 64] = 96
                    mem[_4980 + 96] = 0
                    mem[_4980 + 128] = 0
                    mem[_4980 + 160] = 0
                    mem[_4980 + 192] = 0
                    mem[_4980 + 224] = 0
                    mem[s + 32] = _4980
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3893]
                mem[_3893 + 32] = _3557
                require 1 < mem[_3893]
                mem[_3893 + 64] = _1808
                _5268 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5268] = 0
                mem[_5268 + 32] = 96
                mem[_5268 + 64] = 96
                mem[_5268 + 96] = 0
                mem[_5268 + 128] = 0
                mem[_5268 + 160] = 0
                mem[_5268 + 192] = 0
                mem[_5268 + 224] = 0
                require 0 < mem[_3893]
                _5550 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5550] = 0
                mem[_5550 + 32] = 96
                mem[_5550 + 64] = 96
                mem[_5550 + 96] = 0
                mem[_5550 + 128] = 0
                mem[_5550 + 160] = 0
                mem[_5550 + 192] = 0
                mem[_5550 + 224] = 0
                require 1 < mem[_3893]
                if mem[_3557 + 96] <= mem[_1808 + 96]:
                    idx = 12
                    s = mem[_3557 + 96]
                    while idx >= 4:
                        if not mem[_3557 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3557 + 96] - idx
                        continue 
                    _6279 = mem[_3557 + 96]
                    _6280 = mem[_3557 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6279 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1808 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                        if not _6280 / 10^(_6279 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6280 / 10^(_6279 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6280 / 10^(_6279 - s))
                    if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6280 / 10^(_6279 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6280 / 10^(_6279 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6280 / 10^(_6279 - s))
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _6281 = mem[_3557 + 96]
                _6282 = mem[_3557 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6281 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6282 / 10^(_6281 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6282 / 10^(_6281 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6282 / 10^(_6281 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6282 / 10^(_6281 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6282 / 10^(_6281 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6282 / 10^(_6281 - s))
            if wbnbAddress == address(_1828):
                _3939 = mem[64]
                mem[mem[64]] = 2
                _4979 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4979] = 0
                mem[_4979 + 32] = 96
                mem[_4979 + 64] = 96
                mem[_4979 + 96] = 0
                mem[_4979 + 128] = 0
                mem[_4979 + 160] = 0
                mem[_4979 + 192] = 0
                mem[_4979 + 224] = 0
                mem[var185001] = _4979
                s = var185001
                idx = var185002
                while idx - 1:
                    _4979 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4979] = 0
                    mem[_4979 + 32] = 96
                    mem[_4979 + 64] = 96
                    mem[_4979 + 96] = 0
                    mem[_4979 + 128] = 0
                    mem[_4979 + 160] = 0
                    mem[_4979 + 192] = 0
                    mem[_4979 + 224] = 0
                    mem[s + 32] = _4979
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3939]
                mem[_3939 + 32] = _1808
                require 1 < mem[_3939]
                mem[_3939 + 64] = _3557
                _5267 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5267] = 0
                mem[_5267 + 32] = 96
                mem[_5267 + 64] = 96
                mem[_5267 + 96] = 0
                mem[_5267 + 128] = 0
                mem[_5267 + 160] = 0
                mem[_5267 + 192] = 0
                mem[_5267 + 224] = 0
                require 0 < mem[_3939]
                _5549 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5549] = 0
                mem[_5549 + 32] = 96
                mem[_5549 + 64] = 96
                mem[_5549 + 96] = 0
                mem[_5549 + 128] = 0
                mem[_5549 + 160] = 0
                mem[_5549 + 192] = 0
                mem[_5549 + 224] = 0
                require 1 < mem[_3939]
                if mem[_1808 + 96] <= mem[_3557 + 96]:
                    idx = 12
                    s = mem[_1808 + 96]
                    while idx >= 4:
                        if not mem[_1808 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1808 + 96] - idx
                        continue 
                    _6275 = mem[_1808 + 96]
                    _6276 = mem[_1808 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6275 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3557 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3557 + 128] / 10^(mem[_3557 + 96] - s):
                        if not _6276 / 10^(_6275 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6276 / 10^(_6275 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6276 / 10^(_6275 - s))
                    if 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6276 / 10^(_6275 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _6276 / 10^(_6275 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _6276 / 10^(_6275 - s))
                idx = 12
                s = mem[_3557 + 96]
                while idx >= 4:
                    if not mem[_3557 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3557 + 96] - idx
                    continue 
                _6277 = mem[_1808 + 96]
                _6278 = mem[_1808 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6277 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3557 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3557 + 128] / 10^(mem[_3557 + 96] - s):
                    if not _6278 / 10^(_6277 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6278 / 10^(_6277 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6278 / 10^(_6277 - s))
                if 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6278 / 10^(_6277 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _6278 / 10^(_6277 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _6278 / 10^(_6277 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3987 = mem[64]
                mem[mem[64]] = 2
                _4978 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4978] = 0
                mem[_4978 + 32] = 96
                mem[_4978 + 64] = 96
                mem[_4978 + 96] = 0
                mem[_4978 + 128] = 0
                mem[_4978 + 160] = 0
                mem[_4978 + 192] = 0
                mem[_4978 + 224] = 0
                mem[var188001] = _4978
                s = var188001
                idx = var188002
                while idx - 1:
                    _4978 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4978] = 0
                    mem[_4978 + 32] = 96
                    mem[_4978 + 64] = 96
                    mem[_4978 + 96] = 0
                    mem[_4978 + 128] = 0
                    mem[_4978 + 160] = 0
                    mem[_4978 + 192] = 0
                    mem[_4978 + 224] = 0
                    mem[s + 32] = _4978
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3987]
                mem[_3987 + 32] = _3557
                require 1 < mem[_3987]
                mem[_3987 + 64] = _1808
                _5266 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5266] = 0
                mem[_5266 + 32] = 96
                mem[_5266 + 64] = 96
                mem[_5266 + 96] = 0
                mem[_5266 + 128] = 0
                mem[_5266 + 160] = 0
                mem[_5266 + 192] = 0
                mem[_5266 + 224] = 0
                require 0 < mem[_3987]
                _5548 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5548] = 0
                mem[_5548 + 32] = 96
                mem[_5548 + 64] = 96
                mem[_5548 + 96] = 0
                mem[_5548 + 128] = 0
                mem[_5548 + 160] = 0
                mem[_5548 + 192] = 0
                mem[_5548 + 224] = 0
                require 1 < mem[_3987]
                if mem[_3557 + 96] <= mem[_1808 + 96]:
                    idx = 12
                    s = mem[_3557 + 96]
                    while idx >= 4:
                        if not mem[_3557 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3557 + 96] - idx
                        continue 
                    _6271 = mem[_3557 + 96]
                    _6272 = mem[_3557 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6271 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1808 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                        if not _6272 / 10^(_6271 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6272 / 10^(_6271 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6272 / 10^(_6271 - s))
                    if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6272 / 10^(_6271 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6272 / 10^(_6271 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6272 / 10^(_6271 - s))
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _6273 = mem[_3557 + 96]
                _6274 = mem[_3557 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6273 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6274 / 10^(_6273 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6274 / 10^(_6273 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6274 / 10^(_6273 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6274 / 10^(_6273 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6274 / 10^(_6273 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6274 / 10^(_6273 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4035 = mem[64]
                mem[mem[64]] = 2
                _4977 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4977] = 0
                mem[_4977 + 32] = 96
                mem[_4977 + 64] = 96
                mem[_4977 + 96] = 0
                mem[_4977 + 128] = 0
                mem[_4977 + 160] = 0
                mem[_4977 + 192] = 0
                mem[_4977 + 224] = 0
                mem[var191001] = _4977
                s = var191001
                idx = var191002
                while idx - 1:
                    _4977 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4977] = 0
                    mem[_4977 + 32] = 96
                    mem[_4977 + 64] = 96
                    mem[_4977 + 96] = 0
                    mem[_4977 + 128] = 0
                    mem[_4977 + 160] = 0
                    mem[_4977 + 192] = 0
                    mem[_4977 + 224] = 0
                    mem[s + 32] = _4977
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4035]
                mem[_4035 + 32] = _3557
                require 1 < mem[_4035]
                mem[_4035 + 64] = _1808
                _5265 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5265] = 0
                mem[_5265 + 32] = 96
                mem[_5265 + 64] = 96
                mem[_5265 + 96] = 0
                mem[_5265 + 128] = 0
                mem[_5265 + 160] = 0
                mem[_5265 + 192] = 0
                mem[_5265 + 224] = 0
                require 0 < mem[_4035]
                _5547 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5547] = 0
                mem[_5547 + 32] = 96
                mem[_5547 + 64] = 96
                mem[_5547 + 96] = 0
                mem[_5547 + 128] = 0
                mem[_5547 + 160] = 0
                mem[_5547 + 192] = 0
                mem[_5547 + 224] = 0
                require 1 < mem[_4035]
                if mem[_3557 + 96] <= mem[_1808 + 96]:
                    idx = 12
                    s = mem[_3557 + 96]
                    while idx >= 4:
                        if not mem[_3557 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3557 + 96] - idx
                        continue 
                    _6267 = mem[_3557 + 96]
                    _6268 = mem[_3557 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6267 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1808 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                        if not _6268 / 10^(_6267 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6268 / 10^(_6267 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6268 / 10^(_6267 - s))
                    if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6268 / 10^(_6267 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6268 / 10^(_6267 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6268 / 10^(_6267 - s))
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _6269 = mem[_3557 + 96]
                _6270 = mem[_3557 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6269 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6270 / 10^(_6269 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6270 / 10^(_6269 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6270 / 10^(_6269 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6270 / 10^(_6269 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6270 / 10^(_6269 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6270 / 10^(_6269 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4445 = mem[64]
                mem[mem[64]] = 2
                _6010 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_6010] = 0
                mem[_6010 + 32] = 96
                mem[_6010 + 64] = 96
                mem[_6010 + 96] = 0
                mem[_6010 + 128] = 0
                mem[_6010 + 160] = 0
                mem[_6010 + 192] = 0
                mem[_6010 + 224] = 0
                mem[var200001] = _6010
                s = var200001
                idx = var200002
                while idx - 1:
                    _6010 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6010] = 0
                    mem[_6010 + 32] = 96
                    mem[_6010 + 64] = 96
                    mem[_6010 + 96] = 0
                    mem[_6010 + 128] = 0
                    mem[_6010 + 160] = 0
                    mem[_6010 + 192] = 0
                    mem[_6010 + 224] = 0
                    mem[s + 32] = _6010
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4445]
                mem[_4445 + 32] = _3557
                require 1 < mem[_4445]
                mem[_4445 + 64] = _1808
                _6586 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6586] = 0
                mem[_6586 + 32] = 96
                mem[_6586 + 64] = 96
                mem[_6586 + 96] = 0
                mem[_6586 + 128] = 0
                mem[_6586 + 160] = 0
                mem[_6586 + 192] = 0
                mem[_6586 + 224] = 0
                require 0 < mem[_4445]
                _6842 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6842] = 0
                mem[_6842 + 32] = 96
                mem[_6842 + 64] = 96
                mem[_6842 + 96] = 0
                mem[_6842 + 128] = 0
                mem[_6842 + 160] = 0
                mem[_6842 + 192] = 0
                mem[_6842 + 224] = 0
                require 1 < mem[_4445]
                if mem[_3557 + 96] <= mem[_1808 + 96]:
                    idx = 12
                    s = mem[_3557 + 96]
                    while idx >= 4:
                        if not mem[_3557 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3557 + 96] - idx
                        continue 
                    _13093 = mem[_3557 + 96]
                    _13094 = mem[_3557 + 128]
                    _13171 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13171] = 26
                    mem[_13171 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13093 - s):
                        _13811 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13811 + 68] = mem[idx + _13171 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13811 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13811 + -mem[64] + 100
                    _14949 = mem[_1808 + 96]
                    _14950 = mem[_1808 + 128]
                    _15077 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15077] = 26
                    mem[_15077 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14949 - s):
                        _15155 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15155 + 68] = mem[idx + _15077 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15155 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15155 + -mem[64] + 100
                    if not _14950 / 10^(_14949 - s):
                        _15539 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15539] = 26
                        mem[_15539 + 32] = 'SafeMath: division by zero'
                        if not _13094 / 10^(_13093 - s):
                            _15832 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15832 + 68] = mem[idx + _15539 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15832 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15832 + -mem[64] + 100
                        _16357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16357] = 26
                        mem[_16357 + 32] = 'SafeMath: division by zero'
                        if 0 / _13094 / 10^(_13093 - s):
                            return (1000000 * 10^18 / 0 / _13094 / 10^(_13093 - s))
                        _16601 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16601 + 68] = mem[idx + _16357 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16601 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16601 + -mem[64] + 100
                    if 10^12 * _14950 / 10^(_14949 - s) / _14950 / 10^(_14949 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15831 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15831] = 26
                    mem[_15831 + 32] = 'SafeMath: division by zero'
                    if not _13094 / 10^(_13093 - s):
                        _15973 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15973 + 68] = mem[idx + _15831 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15973 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15973 + -mem[64] + 100
                    _16599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16599] = 26
                    mem[_16599 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14950 / 10^(_14949 - s) / _13094 / 10^(_13093 - s):
                        return (1000000 * 10^18 / 10^12 * _14950 / 10^(_14949 - s) / _13094 / 10^(_13093 - s))
                    _16741 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16741 + 68] = mem[idx + _16599 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16741 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16741 + -mem[64] + 100
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _13095 = mem[_3557 + 96]
                _13096 = mem[_3557 + 128]
                _13172 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13172] = 26
                mem[_13172 + 32] = 'SafeMath: division by zero'
                if not 10^(_13095 - s):
                    _13812 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13812 + 68] = mem[idx + _13172 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13812 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13812 + -mem[64] + 100
                _14951 = mem[_1808 + 96]
                _14952 = mem[_1808 + 128]
                _15079 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15079] = 26
                mem[_15079 + 32] = 'SafeMath: division by zero'
                if not 10^(_14951 - s):
                    _15156 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15156 + 68] = mem[idx + _15079 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15156 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15156 + -mem[64] + 100
                if not _14952 / 10^(_14951 - s):
                    _15540 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15540] = 26
                    mem[_15540 + 32] = 'SafeMath: division by zero'
                    if not _13096 / 10^(_13095 - s):
                        _15835 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15835 + 68] = mem[idx + _15540 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15835 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15835 + -mem[64] + 100
                    _16359 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16359] = 26
                    mem[_16359 + 32] = 'SafeMath: division by zero'
                    if 0 / _13096 / 10^(_13095 - s):
                        return (1000000 * 10^18 / 0 / _13096 / 10^(_13095 - s))
                    _16604 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16604 + 68] = mem[idx + _16359 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16604 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16604 + -mem[64] + 100
                if 10^12 * _14952 / 10^(_14951 - s) / _14952 / 10^(_14951 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15834 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15834] = 26
                mem[_15834 + 32] = 'SafeMath: division by zero'
                if not _13096 / 10^(_13095 - s):
                    _15975 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15975 + 68] = mem[idx + _15834 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15975 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15975 + -mem[64] + 100
                _16602 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16602] = 26
                mem[_16602 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14952 / 10^(_14951 - s) / _13096 / 10^(_13095 - s):
                    return (1000000 * 10^18 / 10^12 * _14952 / 10^(_14951 - s) / _13096 / 10^(_13095 - s))
                _16743 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16743 + 68] = mem[idx + _16602 + 32]
                    idx = idx + 32
                    continue 
                mem[_16743 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16743 + -mem[64] + 100
            _4285 = mem[64]
            mem[mem[64]] = 2
            _6009 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6009] = 0
            mem[_6009 + 32] = 96
            mem[_6009 + 64] = 96
            mem[_6009 + 96] = 0
            mem[_6009 + 128] = 0
            mem[_6009 + 160] = 0
            mem[_6009 + 192] = 0
            mem[_6009 + 224] = 0
            mem[var196001] = _6009
            s = var196001
            idx = var196002
            while idx - 1:
                _6009 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6009] = 0
                mem[_6009 + 32] = 96
                mem[_6009 + 64] = 96
                mem[_6009 + 96] = 0
                mem[_6009 + 128] = 0
                mem[_6009 + 160] = 0
                mem[_6009 + 192] = 0
                mem[_6009 + 224] = 0
                mem[s + 32] = _6009
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4285]
            mem[_4285 + 32] = _1808
            require 1 < mem[_4285]
            mem[_4285 + 64] = _3557
            _6585 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6585] = 0
            mem[_6585 + 32] = 96
            mem[_6585 + 64] = 96
            mem[_6585 + 96] = 0
            mem[_6585 + 128] = 0
            mem[_6585 + 160] = 0
            mem[_6585 + 192] = 0
            mem[_6585 + 224] = 0
            require 0 < mem[_4285]
            _6841 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6841] = 0
            mem[_6841 + 32] = 96
            mem[_6841 + 64] = 96
            mem[_6841 + 96] = 0
            mem[_6841 + 128] = 0
            mem[_6841 + 160] = 0
            mem[_6841 + 192] = 0
            mem[_6841 + 224] = 0
            require 1 < mem[_4285]
            if mem[_1808 + 96] <= mem[_3557 + 96]:
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _13089 = mem[_1808 + 96]
                _13090 = mem[_1808 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13089 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3557 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3557 + 128] / 10^(mem[_3557 + 96] - s):
                    if not _13090 / 10^(_13089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13090 / 10^(_13089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13090 / 10^(_13089 - s))
                if 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13090 / 10^(_13089 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _13090 / 10^(_13089 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _13090 / 10^(_13089 - s))
            idx = 12
            s = mem[_3557 + 96]
            while idx >= 4:
                if not mem[_3557 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3557 + 96] - idx
                continue 
            _13091 = mem[_1808 + 96]
            _13092 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13091 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3557 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3557 + 128] / 10^(mem[_3557 + 96] - s):
                if not _13092 / 10^(_13091 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13092 / 10^(_13091 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13092 / 10^(_13091 - s))
            if 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13092 / 10^(_13091 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _13092 / 10^(_13091 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3557 + 128] / 10^(mem[_3557 + 96] - s) / _13092 / 10^(_13091 - s))
        mem[_2660 + ceil32(return_data.size) + _2676 + 32] = 0
        require ext_code.size(address(_1828))
        staticcall address(_1828).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3471 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3487 = mem[_3471]
        require mem[_3471] == mem[_3471 + 31 len 1]
        require ext_code.size(address(_1828))
        staticcall address(_1828).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3535 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3558 = mem[_3535]
        _3581 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3581] = address(_1828)
        mem[_3581 + 32] = _1844 + ceil32(return_data.size)
        mem[_3581 + 64] = _2660 + ceil32(return_data.size)
        mem[_3581 + 96] = uint8(_3487)
        mem[_3581 + 128] = 0
        mem[_3581 + 160] = _3558
        mem[_3581 + 192] = 0
        mem[_3581 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3615 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3631 = mem[_3615]
        require mem[_3615] == mem[_3615 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3631))
        staticcall address(_3631).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3679 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1808 + 128] = mem[_3679]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3743 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3759 = mem[_3743]
        require mem[_3743] == mem[_3743 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3759))
        staticcall address(_3759).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3807 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3581 + 128] = mem[_3807]
        _3839 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3839] = 0
        mem[_3839 + 32] = 96
        mem[_3839 + 64] = 96
        mem[_3839 + 96] = 0
        mem[_3839 + 128] = 0
        mem[_3839 + 160] = 0
        mem[_3839 + 192] = 0
        mem[_3839 + 224] = 0
        _3862 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3862] = 0
        mem[_3862 + 32] = 96
        mem[_3862 + 64] = 96
        mem[_3862 + 96] = 0
        mem[_3862 + 128] = 0
        mem[_3862 + 160] = 0
        mem[_3862 + 192] = 0
        mem[_3862 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3903 = mem[64]
            mem[mem[64]] = 2
            _4984 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4984] = 0
            mem[_4984 + 32] = 96
            mem[_4984 + 64] = 96
            mem[_4984 + 96] = 0
            mem[_4984 + 128] = 0
            mem[_4984 + 160] = 0
            mem[_4984 + 192] = 0
            mem[_4984 + 224] = 0
            mem[var183001] = _4984
            s = var183001
            idx = var183002
            while idx - 1:
                _4984 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4984] = 0
                mem[_4984 + 32] = 96
                mem[_4984 + 64] = 96
                mem[_4984 + 96] = 0
                mem[_4984 + 128] = 0
                mem[_4984 + 160] = 0
                mem[_4984 + 192] = 0
                mem[_4984 + 224] = 0
                mem[s + 32] = _4984
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3903]
            mem[_3903 + 32] = _3581
            require 1 < mem[_3903]
            mem[_3903 + 64] = _1808
            _5272 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5272] = 0
            mem[_5272 + 32] = 96
            mem[_5272 + 64] = 96
            mem[_5272 + 96] = 0
            mem[_5272 + 128] = 0
            mem[_5272 + 160] = 0
            mem[_5272 + 192] = 0
            mem[_5272 + 224] = 0
            require 0 < mem[_3903]
            _5556 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5556] = 0
            mem[_5556 + 32] = 96
            mem[_5556 + 64] = 96
            mem[_5556 + 96] = 0
            mem[_5556 + 128] = 0
            mem[_5556 + 160] = 0
            mem[_5556 + 192] = 0
            mem[_5556 + 224] = 0
            require 1 < mem[_3903]
            if mem[_3581 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3581 + 96]
                while idx >= 4:
                    if not mem[_3581 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3581 + 96] - idx
                    continue 
                _6297 = mem[_3581 + 96]
                _6298 = mem[_3581 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6297 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6298 / 10^(_6297 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6298 / 10^(_6297 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6298 / 10^(_6297 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6298 / 10^(_6297 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6298 / 10^(_6297 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6298 / 10^(_6297 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6299 = mem[_3581 + 96]
            _6300 = mem[_3581 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6299 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6300 / 10^(_6299 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6300 / 10^(_6299 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6300 / 10^(_6299 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6300 / 10^(_6299 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6300 / 10^(_6299 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6300 / 10^(_6299 - s))
        if wbnbAddress == address(_1828):
            _3951 = mem[64]
            mem[mem[64]] = 2
            _4983 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4983] = 0
            mem[_4983 + 32] = 96
            mem[_4983 + 64] = 96
            mem[_4983 + 96] = 0
            mem[_4983 + 128] = 0
            mem[_4983 + 160] = 0
            mem[_4983 + 192] = 0
            mem[_4983 + 224] = 0
            mem[var186001] = _4983
            s = var186001
            idx = var186002
            while idx - 1:
                _4983 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4983] = 0
                mem[_4983 + 32] = 96
                mem[_4983 + 64] = 96
                mem[_4983 + 96] = 0
                mem[_4983 + 128] = 0
                mem[_4983 + 160] = 0
                mem[_4983 + 192] = 0
                mem[_4983 + 224] = 0
                mem[s + 32] = _4983
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3951]
            mem[_3951 + 32] = _1808
            require 1 < mem[_3951]
            mem[_3951 + 64] = _3581
            _5271 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5271] = 0
            mem[_5271 + 32] = 96
            mem[_5271 + 64] = 96
            mem[_5271 + 96] = 0
            mem[_5271 + 128] = 0
            mem[_5271 + 160] = 0
            mem[_5271 + 192] = 0
            mem[_5271 + 224] = 0
            require 0 < mem[_3951]
            _5555 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5555] = 0
            mem[_5555 + 32] = 96
            mem[_5555 + 64] = 96
            mem[_5555 + 96] = 0
            mem[_5555 + 128] = 0
            mem[_5555 + 160] = 0
            mem[_5555 + 192] = 0
            mem[_5555 + 224] = 0
            require 1 < mem[_3951]
            if mem[_1808 + 96] <= mem[_3581 + 96]:
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _6293 = mem[_1808 + 96]
                _6294 = mem[_1808 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6293 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3581 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3581 + 128] / 10^(mem[_3581 + 96] - s):
                    if not _6294 / 10^(_6293 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6294 / 10^(_6293 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6294 / 10^(_6293 - s))
                if 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6294 / 10^(_6293 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _6294 / 10^(_6293 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _6294 / 10^(_6293 - s))
            idx = 12
            s = mem[_3581 + 96]
            while idx >= 4:
                if not mem[_3581 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3581 + 96] - idx
                continue 
            _6295 = mem[_1808 + 96]
            _6296 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6295 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3581 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3581 + 128] / 10^(mem[_3581 + 96] - s):
                if not _6296 / 10^(_6295 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6296 / 10^(_6295 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6296 / 10^(_6295 - s))
            if 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6296 / 10^(_6295 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _6296 / 10^(_6295 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _6296 / 10^(_6295 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3999 = mem[64]
            mem[mem[64]] = 2
            _4982 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4982] = 0
            mem[_4982 + 32] = 96
            mem[_4982 + 64] = 96
            mem[_4982 + 96] = 0
            mem[_4982 + 128] = 0
            mem[_4982 + 160] = 0
            mem[_4982 + 192] = 0
            mem[_4982 + 224] = 0
            mem[var189001] = _4982
            s = var189001
            idx = var189002
            while idx - 1:
                _4982 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4982] = 0
                mem[_4982 + 32] = 96
                mem[_4982 + 64] = 96
                mem[_4982 + 96] = 0
                mem[_4982 + 128] = 0
                mem[_4982 + 160] = 0
                mem[_4982 + 192] = 0
                mem[_4982 + 224] = 0
                mem[s + 32] = _4982
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3999]
            mem[_3999 + 32] = _3581
            require 1 < mem[_3999]
            mem[_3999 + 64] = _1808
            _5270 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5270] = 0
            mem[_5270 + 32] = 96
            mem[_5270 + 64] = 96
            mem[_5270 + 96] = 0
            mem[_5270 + 128] = 0
            mem[_5270 + 160] = 0
            mem[_5270 + 192] = 0
            mem[_5270 + 224] = 0
            require 0 < mem[_3999]
            _5554 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5554] = 0
            mem[_5554 + 32] = 96
            mem[_5554 + 64] = 96
            mem[_5554 + 96] = 0
            mem[_5554 + 128] = 0
            mem[_5554 + 160] = 0
            mem[_5554 + 192] = 0
            mem[_5554 + 224] = 0
            require 1 < mem[_3999]
            if mem[_3581 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3581 + 96]
                while idx >= 4:
                    if not mem[_3581 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3581 + 96] - idx
                    continue 
                _6289 = mem[_3581 + 96]
                _6290 = mem[_3581 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6289 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6290 / 10^(_6289 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6290 / 10^(_6289 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6290 / 10^(_6289 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6290 / 10^(_6289 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6290 / 10^(_6289 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6290 / 10^(_6289 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6291 = mem[_3581 + 96]
            _6292 = mem[_3581 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6291 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6292 / 10^(_6291 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6292 / 10^(_6291 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6292 / 10^(_6291 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6292 / 10^(_6291 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6292 / 10^(_6291 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6292 / 10^(_6291 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4047 = mem[64]
            mem[mem[64]] = 2
            _4981 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4981] = 0
            mem[_4981 + 32] = 96
            mem[_4981 + 64] = 96
            mem[_4981 + 96] = 0
            mem[_4981 + 128] = 0
            mem[_4981 + 160] = 0
            mem[_4981 + 192] = 0
            mem[_4981 + 224] = 0
            mem[var192001] = _4981
            s = var192001
            idx = var192002
            while idx - 1:
                _4981 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4981] = 0
                mem[_4981 + 32] = 96
                mem[_4981 + 64] = 96
                mem[_4981 + 96] = 0
                mem[_4981 + 128] = 0
                mem[_4981 + 160] = 0
                mem[_4981 + 192] = 0
                mem[_4981 + 224] = 0
                mem[s + 32] = _4981
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4047]
            mem[_4047 + 32] = _3581
            require 1 < mem[_4047]
            mem[_4047 + 64] = _1808
            _5269 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5269] = 0
            mem[_5269 + 32] = 96
            mem[_5269 + 64] = 96
            mem[_5269 + 96] = 0
            mem[_5269 + 128] = 0
            mem[_5269 + 160] = 0
            mem[_5269 + 192] = 0
            mem[_5269 + 224] = 0
            require 0 < mem[_4047]
            _5553 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5553] = 0
            mem[_5553 + 32] = 96
            mem[_5553 + 64] = 96
            mem[_5553 + 96] = 0
            mem[_5553 + 128] = 0
            mem[_5553 + 160] = 0
            mem[_5553 + 192] = 0
            mem[_5553 + 224] = 0
            require 1 < mem[_4047]
            if mem[_3581 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3581 + 96]
                while idx >= 4:
                    if not mem[_3581 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3581 + 96] - idx
                    continue 
                _6285 = mem[_3581 + 96]
                _6286 = mem[_3581 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6285 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6286 / 10^(_6285 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6286 / 10^(_6285 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6286 / 10^(_6285 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6286 / 10^(_6285 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6286 / 10^(_6285 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6286 / 10^(_6285 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6287 = mem[_3581 + 96]
            _6288 = mem[_3581 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6287 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6288 / 10^(_6287 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6288 / 10^(_6287 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6288 / 10^(_6287 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6288 / 10^(_6287 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6288 / 10^(_6287 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6288 / 10^(_6287 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4450 = mem[64]
            mem[mem[64]] = 2
            _6012 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6012] = 0
            mem[_6012 + 32] = 96
            mem[_6012 + 64] = 96
            mem[_6012 + 96] = 0
            mem[_6012 + 128] = 0
            mem[_6012 + 160] = 0
            mem[_6012 + 192] = 0
            mem[_6012 + 224] = 0
            mem[var201001] = _6012
            s = var201001
            idx = var201002
            while idx - 1:
                _6012 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6012] = 0
                mem[_6012 + 32] = 96
                mem[_6012 + 64] = 96
                mem[_6012 + 96] = 0
                mem[_6012 + 128] = 0
                mem[_6012 + 160] = 0
                mem[_6012 + 192] = 0
                mem[_6012 + 224] = 0
                mem[s + 32] = _6012
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4450]
            mem[_4450 + 32] = _3581
            require 1 < mem[_4450]
            mem[_4450 + 64] = _1808
            _6596 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6596] = 0
            mem[_6596 + 32] = 96
            mem[_6596 + 64] = 96
            mem[_6596 + 96] = 0
            mem[_6596 + 128] = 0
            mem[_6596 + 160] = 0
            mem[_6596 + 192] = 0
            mem[_6596 + 224] = 0
            require 0 < mem[_4450]
            _6844 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6844] = 0
            mem[_6844 + 32] = 96
            mem[_6844 + 64] = 96
            mem[_6844 + 96] = 0
            mem[_6844 + 128] = 0
            mem[_6844 + 160] = 0
            mem[_6844 + 192] = 0
            mem[_6844 + 224] = 0
            require 1 < mem[_4450]
            if mem[_3581 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3581 + 96]
                while idx >= 4:
                    if not mem[_3581 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3581 + 96] - idx
                    continue 
                _13101 = mem[_3581 + 96]
                _13102 = mem[_3581 + 128]
                _13175 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13175] = 26
                mem[_13175 + 32] = 'SafeMath: division by zero'
                if not 10^(_13101 - s):
                    _13863 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13863 + 68] = mem[idx + _13175 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13863 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13863 + -mem[64] + 100
                _14957 = mem[_1808 + 96]
                _14958 = mem[_1808 + 128]
                _15085 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15085] = 26
                mem[_15085 + 32] = 'SafeMath: division by zero'
                if not 10^(_14957 - s):
                    _15159 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15159 + 68] = mem[idx + _15085 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15159 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15159 + -mem[64] + 100
                if not _14958 / 10^(_14957 - s):
                    _15543 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15543] = 26
                    mem[_15543 + 32] = 'SafeMath: division by zero'
                    if not _13102 / 10^(_13101 - s):
                        _15844 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15844 + 68] = mem[idx + _15543 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15844 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15844 + -mem[64] + 100
                    _16365 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16365] = 26
                    mem[_16365 + 32] = 'SafeMath: division by zero'
                    if 0 / _13102 / 10^(_13101 - s):
                        return (1000000 * 10^18 / 0 / _13102 / 10^(_13101 - s))
                    _16613 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16613 + 68] = mem[idx + _16365 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16613 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16613 + -mem[64] + 100
                if 10^12 * _14958 / 10^(_14957 - s) / _14958 / 10^(_14957 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15843 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15843] = 26
                mem[_15843 + 32] = 'SafeMath: division by zero'
                if not _13102 / 10^(_13101 - s):
                    _15981 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15981 + 68] = mem[idx + _15843 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15981 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15981 + -mem[64] + 100
                _16611 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16611] = 26
                mem[_16611 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14958 / 10^(_14957 - s) / _13102 / 10^(_13101 - s):
                    return (1000000 * 10^18 / 10^12 * _14958 / 10^(_14957 - s) / _13102 / 10^(_13101 - s))
                _16749 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16749 + 68] = mem[idx + _16611 + 32]
                    idx = idx + 32
                    continue 
                mem[_16749 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16749 + -mem[64] + 100
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _13103 = mem[_3581 + 96]
            _13104 = mem[_3581 + 128]
            _13176 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13176] = 26
            mem[_13176 + 32] = 'SafeMath: division by zero'
            if not 10^(_13103 - s):
                _13864 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13864 + 68] = mem[idx + _13176 + 32]
                    idx = idx + 32
                    continue 
                mem[_13864 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13864 + -mem[64] + 100
            _14959 = mem[_1808 + 96]
            _14960 = mem[_1808 + 128]
            _15087 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15087] = 26
            mem[_15087 + 32] = 'SafeMath: division by zero'
            if not 10^(_14959 - s):
                _15160 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15160 + 68] = mem[idx + _15087 + 32]
                    idx = idx + 32
                    continue 
                mem[_15160 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15160 + -mem[64] + 100
            if not _14960 / 10^(_14959 - s):
                _15544 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15544] = 26
                mem[_15544 + 32] = 'SafeMath: division by zero'
                if not _13104 / 10^(_13103 - s):
                    _15847 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15847 + 68] = mem[idx + _15544 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15847 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15847 + -mem[64] + 100
                _16367 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16367] = 26
                mem[_16367 + 32] = 'SafeMath: division by zero'
                if 0 / _13104 / 10^(_13103 - s):
                    return (1000000 * 10^18 / 0 / _13104 / 10^(_13103 - s))
                _16616 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16616 + 68] = mem[idx + _16367 + 32]
                    idx = idx + 32
                    continue 
                mem[_16616 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16616 + -mem[64] + 100
            if 10^12 * _14960 / 10^(_14959 - s) / _14960 / 10^(_14959 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15846 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15846] = 26
            mem[_15846 + 32] = 'SafeMath: division by zero'
            if not _13104 / 10^(_13103 - s):
                _15983 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15983 + 68] = mem[idx + _15846 + 32]
                    idx = idx + 32
                    continue 
                mem[_15983 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15983 + -mem[64] + 100
            _16614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16614] = 26
            mem[_16614 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14960 / 10^(_14959 - s) / _13104 / 10^(_13103 - s):
                return (1000000 * 10^18 / 10^12 * _14960 / 10^(_14959 - s) / _13104 / 10^(_13103 - s))
            _16751 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16751 + 68] = mem[idx + _16614 + 32]
                idx = idx + 32
                continue 
            mem[_16751 + 94] = 0
            revert with memory
              from mem[64]
               len _16751 + -mem[64] + 100
        _4290 = mem[64]
        mem[mem[64]] = 2
        _6011 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_6011] = 0
        mem[_6011 + 32] = 96
        mem[_6011 + 64] = 96
        mem[_6011 + 96] = 0
        mem[_6011 + 128] = 0
        mem[_6011 + 160] = 0
        mem[_6011 + 192] = 0
        mem[_6011 + 224] = 0
        mem[var197001] = _6011
        s = var197001
        idx = var197002
        while idx - 1:
            _6011 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6011] = 0
            mem[_6011 + 32] = 96
            mem[_6011 + 64] = 96
            mem[_6011 + 96] = 0
            mem[_6011 + 128] = 0
            mem[_6011 + 160] = 0
            mem[_6011 + 192] = 0
            mem[_6011 + 224] = 0
            mem[s + 32] = _6011
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4290]
        mem[_4290 + 32] = _1808
        require 1 < mem[_4290]
        mem[_4290 + 64] = _3581
        _6595 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6595] = 0
        mem[_6595 + 32] = 96
        mem[_6595 + 64] = 96
        mem[_6595 + 96] = 0
        mem[_6595 + 128] = 0
        mem[_6595 + 160] = 0
        mem[_6595 + 192] = 0
        mem[_6595 + 224] = 0
        require 0 < mem[_4290]
        _6843 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6843] = 0
        mem[_6843 + 32] = 96
        mem[_6843 + 64] = 96
        mem[_6843 + 96] = 0
        mem[_6843 + 128] = 0
        mem[_6843 + 160] = 0
        mem[_6843 + 192] = 0
        mem[_6843 + 224] = 0
        require 1 < mem[_4290]
        if mem[_1808 + 96] <= mem[_3581 + 96]:
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _13097 = mem[_1808 + 96]
            _13098 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13097 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3581 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3581 + 128] / 10^(mem[_3581 + 96] - s):
                if not _13098 / 10^(_13097 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13098 / 10^(_13097 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13098 / 10^(_13097 - s))
            if 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13098 / 10^(_13097 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _13098 / 10^(_13097 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _13098 / 10^(_13097 - s))
        idx = 12
        s = mem[_3581 + 96]
        while idx >= 4:
            if not mem[_3581 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3581 + 96] - idx
            continue 
        _13099 = mem[_1808 + 96]
        _13100 = mem[_1808 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13099 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3581 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3581 + 128] / 10^(mem[_3581 + 96] - s):
            if not _13100 / 10^(_13099 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13100 / 10^(_13099 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13100 / 10^(_13099 - s))
        if 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13100 / 10^(_13099 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _13100 / 10^(_13099 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3581 + 128] / 10^(mem[_3581 + 96] - s) / _13100 / 10^(_13099 - s))
    mem[_1844 + ceil32(return_data.size) + _1852 + 32] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(_1828))
    staticcall address(_1828).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _2664 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2672 = mem[_2664]
    require mem[_2664] <= test266151307()
    require _2664 + mem[_2664] + 31 < _2664 + return_data.size
    _2680 = mem[_2664 + mem[_2664]]
    require mem[_2664 + mem[_2664]] <= test266151307()
    require ceil32(mem[_2664 + mem[_2664]]) + 32 >= 0 and _2664 + ceil32(return_data.size) + ceil32(mem[_2664 + mem[_2664]]) + 32 <= test266151307()
    mem[64] = _2664 + ceil32(return_data.size) + ceil32(mem[_2664 + mem[_2664]]) + 32
    mem[_2664 + ceil32(return_data.size)] = _2680
    require _2672 + _2680 + 32 <= return_data.size
    mem[_2664 + ceil32(return_data.size) + 32 len ceil32(_2680)] = mem[_2664 + _2672 + 32 len ceil32(_2680)]
    if ceil32(_2680) <= _2680:
        require ext_code.size(address(_1828))
        staticcall address(_1828).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3464 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3480 = mem[_3464]
        require mem[_3464] == mem[_3464 + 31 len 1]
        require ext_code.size(address(_1828))
        staticcall address(_1828).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3528 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3544 = mem[_3528]
        _3559 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3559] = address(_1828)
        mem[_3559 + 32] = _1844 + ceil32(return_data.size)
        mem[_3559 + 64] = _2664 + ceil32(return_data.size)
        mem[_3559 + 96] = uint8(_3480)
        mem[_3559 + 128] = 0
        mem[_3559 + 160] = _3544
        mem[_3559 + 192] = 0
        mem[_3559 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3608 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3624 = mem[_3608]
        require mem[_3608] == mem[_3608 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3624))
        staticcall address(_3624).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3672 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1808 + 128] = mem[_3672]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3736 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3752 = mem[_3736]
        require mem[_3736] == mem[_3736 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3752))
        staticcall address(_3752).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3800 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3559 + 128] = mem[_3800]
        _3832 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3832] = 0
        mem[_3832 + 32] = 96
        mem[_3832 + 64] = 96
        mem[_3832 + 96] = 0
        mem[_3832 + 128] = 0
        mem[_3832 + 160] = 0
        mem[_3832 + 192] = 0
        mem[_3832 + 224] = 0
        _3848 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3848] = 0
        mem[_3848 + 32] = 96
        mem[_3848 + 64] = 96
        mem[_3848 + 96] = 0
        mem[_3848 + 128] = 0
        mem[_3848 + 160] = 0
        mem[_3848 + 192] = 0
        mem[_3848 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3895 = mem[64]
            mem[mem[64]] = 2
            _4988 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4988] = 0
            mem[_4988 + 32] = 96
            mem[_4988 + 64] = 96
            mem[_4988 + 96] = 0
            mem[_4988 + 128] = 0
            mem[_4988 + 160] = 0
            mem[_4988 + 192] = 0
            mem[_4988 + 224] = 0
            mem[var183001] = _4988
            s = var183001
            idx = var183002
            while idx - 1:
                _4988 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4988] = 0
                mem[_4988 + 32] = 96
                mem[_4988 + 64] = 96
                mem[_4988 + 96] = 0
                mem[_4988 + 128] = 0
                mem[_4988 + 160] = 0
                mem[_4988 + 192] = 0
                mem[_4988 + 224] = 0
                mem[s + 32] = _4988
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3895]
            mem[_3895 + 32] = _3559
            require 1 < mem[_3895]
            mem[_3895 + 64] = _1808
            _5276 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5276] = 0
            mem[_5276 + 32] = 96
            mem[_5276 + 64] = 96
            mem[_5276 + 96] = 0
            mem[_5276 + 128] = 0
            mem[_5276 + 160] = 0
            mem[_5276 + 192] = 0
            mem[_5276 + 224] = 0
            require 0 < mem[_3895]
            _5562 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5562] = 0
            mem[_5562 + 32] = 96
            mem[_5562 + 64] = 96
            mem[_5562 + 96] = 0
            mem[_5562 + 128] = 0
            mem[_5562 + 160] = 0
            mem[_5562 + 192] = 0
            mem[_5562 + 224] = 0
            require 1 < mem[_3895]
            if mem[_3559 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3559 + 96]
                while idx >= 4:
                    if not mem[_3559 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3559 + 96] - idx
                    continue 
                _6315 = mem[_3559 + 96]
                _6316 = mem[_3559 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6315 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6316 / 10^(_6315 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6316 / 10^(_6315 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6316 / 10^(_6315 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6316 / 10^(_6315 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6316 / 10^(_6315 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6316 / 10^(_6315 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6317 = mem[_3559 + 96]
            _6318 = mem[_3559 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6317 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6318 / 10^(_6317 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6318 / 10^(_6317 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6318 / 10^(_6317 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6318 / 10^(_6317 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6318 / 10^(_6317 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6318 / 10^(_6317 - s))
        if wbnbAddress == address(_1828):
            _3942 = mem[64]
            mem[mem[64]] = 2
            _4987 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4987] = 0
            mem[_4987 + 32] = 96
            mem[_4987 + 64] = 96
            mem[_4987 + 96] = 0
            mem[_4987 + 128] = 0
            mem[_4987 + 160] = 0
            mem[_4987 + 192] = 0
            mem[_4987 + 224] = 0
            mem[var186001] = _4987
            s = var186001
            idx = var186002
            while idx - 1:
                _4987 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4987] = 0
                mem[_4987 + 32] = 96
                mem[_4987 + 64] = 96
                mem[_4987 + 96] = 0
                mem[_4987 + 128] = 0
                mem[_4987 + 160] = 0
                mem[_4987 + 192] = 0
                mem[_4987 + 224] = 0
                mem[s + 32] = _4987
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3942]
            mem[_3942 + 32] = _1808
            require 1 < mem[_3942]
            mem[_3942 + 64] = _3559
            _5275 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5275] = 0
            mem[_5275 + 32] = 96
            mem[_5275 + 64] = 96
            mem[_5275 + 96] = 0
            mem[_5275 + 128] = 0
            mem[_5275 + 160] = 0
            mem[_5275 + 192] = 0
            mem[_5275 + 224] = 0
            require 0 < mem[_3942]
            _5561 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5561] = 0
            mem[_5561 + 32] = 96
            mem[_5561 + 64] = 96
            mem[_5561 + 96] = 0
            mem[_5561 + 128] = 0
            mem[_5561 + 160] = 0
            mem[_5561 + 192] = 0
            mem[_5561 + 224] = 0
            require 1 < mem[_3942]
            if mem[_1808 + 96] <= mem[_3559 + 96]:
                idx = 12
                s = mem[_1808 + 96]
                while idx >= 4:
                    if not mem[_1808 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1808 + 96] - idx
                    continue 
                _6311 = mem[_1808 + 96]
                _6312 = mem[_1808 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6311 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3559 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3559 + 128] / 10^(mem[_3559 + 96] - s):
                    if not _6312 / 10^(_6311 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6312 / 10^(_6311 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6312 / 10^(_6311 - s))
                if 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6312 / 10^(_6311 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _6312 / 10^(_6311 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _6312 / 10^(_6311 - s))
            idx = 12
            s = mem[_3559 + 96]
            while idx >= 4:
                if not mem[_3559 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3559 + 96] - idx
                continue 
            _6313 = mem[_1808 + 96]
            _6314 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6313 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3559 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3559 + 128] / 10^(mem[_3559 + 96] - s):
                if not _6314 / 10^(_6313 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6314 / 10^(_6313 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6314 / 10^(_6313 - s))
            if 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6314 / 10^(_6313 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _6314 / 10^(_6313 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _6314 / 10^(_6313 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3990 = mem[64]
            mem[mem[64]] = 2
            _4986 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4986] = 0
            mem[_4986 + 32] = 96
            mem[_4986 + 64] = 96
            mem[_4986 + 96] = 0
            mem[_4986 + 128] = 0
            mem[_4986 + 160] = 0
            mem[_4986 + 192] = 0
            mem[_4986 + 224] = 0
            mem[var189001] = _4986
            s = var189001
            idx = var189002
            while idx - 1:
                _4986 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4986] = 0
                mem[_4986 + 32] = 96
                mem[_4986 + 64] = 96
                mem[_4986 + 96] = 0
                mem[_4986 + 128] = 0
                mem[_4986 + 160] = 0
                mem[_4986 + 192] = 0
                mem[_4986 + 224] = 0
                mem[s + 32] = _4986
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3990]
            mem[_3990 + 32] = _3559
            require 1 < mem[_3990]
            mem[_3990 + 64] = _1808
            _5274 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5274] = 0
            mem[_5274 + 32] = 96
            mem[_5274 + 64] = 96
            mem[_5274 + 96] = 0
            mem[_5274 + 128] = 0
            mem[_5274 + 160] = 0
            mem[_5274 + 192] = 0
            mem[_5274 + 224] = 0
            require 0 < mem[_3990]
            _5560 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5560] = 0
            mem[_5560 + 32] = 96
            mem[_5560 + 64] = 96
            mem[_5560 + 96] = 0
            mem[_5560 + 128] = 0
            mem[_5560 + 160] = 0
            mem[_5560 + 192] = 0
            mem[_5560 + 224] = 0
            require 1 < mem[_3990]
            if mem[_3559 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3559 + 96]
                while idx >= 4:
                    if not mem[_3559 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3559 + 96] - idx
                    continue 
                _6307 = mem[_3559 + 96]
                _6308 = mem[_3559 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6307 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6308 / 10^(_6307 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6308 / 10^(_6307 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6308 / 10^(_6307 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6308 / 10^(_6307 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6308 / 10^(_6307 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6308 / 10^(_6307 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6309 = mem[_3559 + 96]
            _6310 = mem[_3559 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6309 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6310 / 10^(_6309 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6310 / 10^(_6309 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6310 / 10^(_6309 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6310 / 10^(_6309 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6310 / 10^(_6309 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6310 / 10^(_6309 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4038 = mem[64]
            mem[mem[64]] = 2
            _4985 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4985] = 0
            mem[_4985 + 32] = 96
            mem[_4985 + 64] = 96
            mem[_4985 + 96] = 0
            mem[_4985 + 128] = 0
            mem[_4985 + 160] = 0
            mem[_4985 + 192] = 0
            mem[_4985 + 224] = 0
            mem[var192001] = _4985
            s = var192001
            idx = var192002
            while idx - 1:
                _4985 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4985] = 0
                mem[_4985 + 32] = 96
                mem[_4985 + 64] = 96
                mem[_4985 + 96] = 0
                mem[_4985 + 128] = 0
                mem[_4985 + 160] = 0
                mem[_4985 + 192] = 0
                mem[_4985 + 224] = 0
                mem[s + 32] = _4985
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4038]
            mem[_4038 + 32] = _3559
            require 1 < mem[_4038]
            mem[_4038 + 64] = _1808
            _5273 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5273] = 0
            mem[_5273 + 32] = 96
            mem[_5273 + 64] = 96
            mem[_5273 + 96] = 0
            mem[_5273 + 128] = 0
            mem[_5273 + 160] = 0
            mem[_5273 + 192] = 0
            mem[_5273 + 224] = 0
            require 0 < mem[_4038]
            _5559 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5559] = 0
            mem[_5559 + 32] = 96
            mem[_5559 + 64] = 96
            mem[_5559 + 96] = 0
            mem[_5559 + 128] = 0
            mem[_5559 + 160] = 0
            mem[_5559 + 192] = 0
            mem[_5559 + 224] = 0
            require 1 < mem[_4038]
            if mem[_3559 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3559 + 96]
                while idx >= 4:
                    if not mem[_3559 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3559 + 96] - idx
                    continue 
                _6303 = mem[_3559 + 96]
                _6304 = mem[_3559 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6303 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1808 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                    if not _6304 / 10^(_6303 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6304 / 10^(_6303 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6304 / 10^(_6303 - s))
                if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6304 / 10^(_6303 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6304 / 10^(_6303 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6304 / 10^(_6303 - s))
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6305 = mem[_3559 + 96]
            _6306 = mem[_3559 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6305 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6306 / 10^(_6305 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6306 / 10^(_6305 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6306 / 10^(_6305 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6306 / 10^(_6305 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6306 / 10^(_6305 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6306 / 10^(_6305 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4455 = mem[64]
            mem[mem[64]] = 2
            _6014 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_6014] = 0
            mem[_6014 + 32] = 96
            mem[_6014 + 64] = 96
            mem[_6014 + 96] = 0
            mem[_6014 + 128] = 0
            mem[_6014 + 160] = 0
            mem[_6014 + 192] = 0
            mem[_6014 + 224] = 0
            mem[var201001] = _6014
            s = var201001
            idx = var201002
            while idx - 1:
                _6014 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6014] = 0
                mem[_6014 + 32] = 96
                mem[_6014 + 64] = 96
                mem[_6014 + 96] = 0
                mem[_6014 + 128] = 0
                mem[_6014 + 160] = 0
                mem[_6014 + 192] = 0
                mem[_6014 + 224] = 0
                mem[s + 32] = _6014
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4455]
            mem[_4455 + 32] = _3559
            require 1 < mem[_4455]
            mem[_4455 + 64] = _1808
            _6606 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6606] = 0
            mem[_6606 + 32] = 96
            mem[_6606 + 64] = 96
            mem[_6606 + 96] = 0
            mem[_6606 + 128] = 0
            mem[_6606 + 160] = 0
            mem[_6606 + 192] = 0
            mem[_6606 + 224] = 0
            require 0 < mem[_4455]
            _6846 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6846] = 0
            mem[_6846 + 32] = 96
            mem[_6846 + 64] = 96
            mem[_6846 + 96] = 0
            mem[_6846 + 128] = 0
            mem[_6846 + 160] = 0
            mem[_6846 + 192] = 0
            mem[_6846 + 224] = 0
            require 1 < mem[_4455]
            if mem[_3559 + 96] <= mem[_1808 + 96]:
                idx = 12
                s = mem[_3559 + 96]
                while idx >= 4:
                    if not mem[_3559 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3559 + 96] - idx
                    continue 
                _13109 = mem[_3559 + 96]
                _13110 = mem[_3559 + 128]
                _13179 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13179] = 26
                mem[_13179 + 32] = 'SafeMath: division by zero'
                if not 10^(_13109 - s):
                    _13915 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13915 + 68] = mem[idx + _13179 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13915 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13915 + -mem[64] + 100
                _14965 = mem[_1808 + 96]
                _14966 = mem[_1808 + 128]
                _15093 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15093] = 26
                mem[_15093 + 32] = 'SafeMath: division by zero'
                if not 10^(_14965 - s):
                    _15163 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15163 + 68] = mem[idx + _15093 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15163 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15163 + -mem[64] + 100
                if not _14966 / 10^(_14965 - s):
                    _15547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15547] = 26
                    mem[_15547 + 32] = 'SafeMath: division by zero'
                    if not _13110 / 10^(_13109 - s):
                        _15856 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15856 + 68] = mem[idx + _15547 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15856 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15856 + -mem[64] + 100
                    _16373 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16373] = 26
                    mem[_16373 + 32] = 'SafeMath: division by zero'
                    if 0 / _13110 / 10^(_13109 - s):
                        return (1000000 * 10^18 / 0 / _13110 / 10^(_13109 - s))
                    _16625 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16625 + 68] = mem[idx + _16373 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16625 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16625 + -mem[64] + 100
                if 10^12 * _14966 / 10^(_14965 - s) / _14966 / 10^(_14965 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15855 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15855] = 26
                mem[_15855 + 32] = 'SafeMath: division by zero'
                if not _13110 / 10^(_13109 - s):
                    _15989 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15989 + 68] = mem[idx + _15855 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15989 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15989 + -mem[64] + 100
                _16623 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16623] = 26
                mem[_16623 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14966 / 10^(_14965 - s) / _13110 / 10^(_13109 - s):
                    return (1000000 * 10^18 / 10^12 * _14966 / 10^(_14965 - s) / _13110 / 10^(_13109 - s))
                _16757 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16757 + 68] = mem[idx + _16623 + 32]
                    idx = idx + 32
                    continue 
                mem[_16757 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16757 + -mem[64] + 100
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _13111 = mem[_3559 + 96]
            _13112 = mem[_3559 + 128]
            _13180 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13180] = 26
            mem[_13180 + 32] = 'SafeMath: division by zero'
            if not 10^(_13111 - s):
                _13916 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13916 + 68] = mem[idx + _13180 + 32]
                    idx = idx + 32
                    continue 
                mem[_13916 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13916 + -mem[64] + 100
            _14967 = mem[_1808 + 96]
            _14968 = mem[_1808 + 128]
            _15095 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15095] = 26
            mem[_15095 + 32] = 'SafeMath: division by zero'
            if not 10^(_14967 - s):
                _15164 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15164 + 68] = mem[idx + _15095 + 32]
                    idx = idx + 32
                    continue 
                mem[_15164 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15164 + -mem[64] + 100
            if not _14968 / 10^(_14967 - s):
                _15548 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15548] = 26
                mem[_15548 + 32] = 'SafeMath: division by zero'
                if not _13112 / 10^(_13111 - s):
                    _15859 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15859 + 68] = mem[idx + _15548 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15859 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15859 + -mem[64] + 100
                _16375 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16375] = 26
                mem[_16375 + 32] = 'SafeMath: division by zero'
                if 0 / _13112 / 10^(_13111 - s):
                    return (1000000 * 10^18 / 0 / _13112 / 10^(_13111 - s))
                _16628 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16628 + 68] = mem[idx + _16375 + 32]
                    idx = idx + 32
                    continue 
                mem[_16628 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16628 + -mem[64] + 100
            if 10^12 * _14968 / 10^(_14967 - s) / _14968 / 10^(_14967 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15858 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15858] = 26
            mem[_15858 + 32] = 'SafeMath: division by zero'
            if not _13112 / 10^(_13111 - s):
                _15991 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15991 + 68] = mem[idx + _15858 + 32]
                    idx = idx + 32
                    continue 
                mem[_15991 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15991 + -mem[64] + 100
            _16626 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16626] = 26
            mem[_16626 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14968 / 10^(_14967 - s) / _13112 / 10^(_13111 - s):
                return (1000000 * 10^18 / 10^12 * _14968 / 10^(_14967 - s) / _13112 / 10^(_13111 - s))
            _16759 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16759 + 68] = mem[idx + _16626 + 32]
                idx = idx + 32
                continue 
            mem[_16759 + 94] = 0
            revert with memory
              from mem[64]
               len _16759 + -mem[64] + 100
        _4295 = mem[64]
        mem[mem[64]] = 2
        _6013 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_6013] = 0
        mem[_6013 + 32] = 96
        mem[_6013 + 64] = 96
        mem[_6013 + 96] = 0
        mem[_6013 + 128] = 0
        mem[_6013 + 160] = 0
        mem[_6013 + 192] = 0
        mem[_6013 + 224] = 0
        mem[var197001] = _6013
        s = var197001
        idx = var197002
        while idx - 1:
            _6013 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6013] = 0
            mem[_6013 + 32] = 96
            mem[_6013 + 64] = 96
            mem[_6013 + 96] = 0
            mem[_6013 + 128] = 0
            mem[_6013 + 160] = 0
            mem[_6013 + 192] = 0
            mem[_6013 + 224] = 0
            mem[s + 32] = _6013
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4295]
        mem[_4295 + 32] = _1808
        require 1 < mem[_4295]
        mem[_4295 + 64] = _3559
        _6605 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6605] = 0
        mem[_6605 + 32] = 96
        mem[_6605 + 64] = 96
        mem[_6605 + 96] = 0
        mem[_6605 + 128] = 0
        mem[_6605 + 160] = 0
        mem[_6605 + 192] = 0
        mem[_6605 + 224] = 0
        require 0 < mem[_4295]
        _6845 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6845] = 0
        mem[_6845 + 32] = 96
        mem[_6845 + 64] = 96
        mem[_6845 + 96] = 0
        mem[_6845 + 128] = 0
        mem[_6845 + 160] = 0
        mem[_6845 + 192] = 0
        mem[_6845 + 224] = 0
        require 1 < mem[_4295]
        if mem[_1808 + 96] <= mem[_3559 + 96]:
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _13105 = mem[_1808 + 96]
            _13106 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13105 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3559 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3559 + 128] / 10^(mem[_3559 + 96] - s):
                if not _13106 / 10^(_13105 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13106 / 10^(_13105 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13106 / 10^(_13105 - s))
            if 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13106 / 10^(_13105 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _13106 / 10^(_13105 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _13106 / 10^(_13105 - s))
        idx = 12
        s = mem[_3559 + 96]
        while idx >= 4:
            if not mem[_3559 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3559 + 96] - idx
            continue 
        _13107 = mem[_1808 + 96]
        _13108 = mem[_1808 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13107 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3559 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3559 + 128] / 10^(mem[_3559 + 96] - s):
            if not _13108 / 10^(_13107 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13108 / 10^(_13107 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13108 / 10^(_13107 - s))
        if 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13108 / 10^(_13107 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _13108 / 10^(_13107 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3559 + 128] / 10^(mem[_3559 + 96] - s) / _13108 / 10^(_13107 - s))
    mem[_2664 + ceil32(return_data.size) + _2680 + 32] = 0
    require ext_code.size(address(_1828))
    staticcall address(_1828).0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3472 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3488 = mem[_3472]
    require mem[_3472] == mem[_3472 + 31 len 1]
    require ext_code.size(address(_1828))
    staticcall address(_1828).0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3536 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3560 = mem[_3536]
    _3584 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3584] = address(_1828)
    mem[_3584 + 32] = _1844 + ceil32(return_data.size)
    mem[_3584 + 64] = _2664 + ceil32(return_data.size)
    mem[_3584 + 96] = uint8(_3488)
    mem[_3584 + 128] = 0
    mem[_3584 + 160] = _3560
    mem[_3584 + 192] = 0
    mem[_3584 + 224] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3616 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3632 = mem[_3616]
    require mem[_3616] == mem[_3616 + 12 len 20]
    mem[mem[64] + 4] = arg1
    require ext_code.size(address(_3632))
    staticcall address(_3632).0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3680 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    mem[_1808 + 128] = mem[_3680]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3744 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3760 = mem[_3744]
    require mem[_3744] == mem[_3744 + 12 len 20]
    mem[mem[64] + 4] = arg1
    require ext_code.size(address(_3760))
    staticcall address(_3760).0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3808 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    mem[_3584 + 128] = mem[_3808]
    _3840 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3840] = 0
    mem[_3840 + 32] = 96
    mem[_3840 + 64] = 96
    mem[_3840 + 96] = 0
    mem[_3840 + 128] = 0
    mem[_3840 + 160] = 0
    mem[_3840 + 192] = 0
    mem[_3840 + 224] = 0
    _3864 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3864] = 0
    mem[_3864 + 32] = 96
    mem[_3864 + 64] = 96
    mem[_3864 + 96] = 0
    mem[_3864 + 128] = 0
    mem[_3864 + 160] = 0
    mem[_3864 + 192] = 0
    mem[_3864 + 224] = 0
    if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
        _3904 = mem[64]
        mem[mem[64]] = 2
        _4992 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4992] = 0
        mem[_4992 + 32] = 96
        mem[_4992 + 64] = 96
        mem[_4992 + 96] = 0
        mem[_4992 + 128] = 0
        mem[_4992 + 160] = 0
        mem[_4992 + 192] = 0
        mem[_4992 + 224] = 0
        mem[var184001] = _4992
        s = var184001
        idx = var184002
        while idx - 1:
            _4992 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4992] = 0
            mem[_4992 + 32] = 96
            mem[_4992 + 64] = 96
            mem[_4992 + 96] = 0
            mem[_4992 + 128] = 0
            mem[_4992 + 160] = 0
            mem[_4992 + 192] = 0
            mem[_4992 + 224] = 0
            mem[s + 32] = _4992
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_3904]
        mem[_3904 + 32] = _3584
        require 1 < mem[_3904]
        mem[_3904 + 64] = _1808
        _5280 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5280] = 0
        mem[_5280 + 32] = 96
        mem[_5280 + 64] = 96
        mem[_5280 + 96] = 0
        mem[_5280 + 128] = 0
        mem[_5280 + 160] = 0
        mem[_5280 + 192] = 0
        mem[_5280 + 224] = 0
        require 0 < mem[_3904]
        _5568 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5568] = 0
        mem[_5568 + 32] = 96
        mem[_5568 + 64] = 96
        mem[_5568 + 96] = 0
        mem[_5568 + 128] = 0
        mem[_5568 + 160] = 0
        mem[_5568 + 192] = 0
        mem[_5568 + 224] = 0
        require 1 < mem[_3904]
        if mem[_3584 + 96] <= mem[_1808 + 96]:
            idx = 12
            s = mem[_3584 + 96]
            while idx >= 4:
                if not mem[_3584 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3584 + 96] - idx
                continue 
            _6333 = mem[_3584 + 96]
            _6334 = mem[_3584 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6333 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6334 / 10^(_6333 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6334 / 10^(_6333 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6334 / 10^(_6333 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6334 / 10^(_6333 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6334 / 10^(_6333 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6334 / 10^(_6333 - s))
        idx = 12
        s = mem[_1808 + 96]
        while idx >= 4:
            if not mem[_1808 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1808 + 96] - idx
            continue 
        _6335 = mem[_3584 + 96]
        _6336 = mem[_3584 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6335 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1808 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
            if not _6336 / 10^(_6335 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6336 / 10^(_6335 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6336 / 10^(_6335 - s))
        if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6336 / 10^(_6335 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6336 / 10^(_6335 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6336 / 10^(_6335 - s))
    if wbnbAddress == address(_1828):
        _3952 = mem[64]
        mem[mem[64]] = 2
        _4991 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4991] = 0
        mem[_4991 + 32] = 96
        mem[_4991 + 64] = 96
        mem[_4991 + 96] = 0
        mem[_4991 + 128] = 0
        mem[_4991 + 160] = 0
        mem[_4991 + 192] = 0
        mem[_4991 + 224] = 0
        mem[var187001] = _4991
        s = var187001
        idx = var187002
        while idx - 1:
            _4991 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4991] = 0
            mem[_4991 + 32] = 96
            mem[_4991 + 64] = 96
            mem[_4991 + 96] = 0
            mem[_4991 + 128] = 0
            mem[_4991 + 160] = 0
            mem[_4991 + 192] = 0
            mem[_4991 + 224] = 0
            mem[s + 32] = _4991
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_3952]
        mem[_3952 + 32] = _1808
        require 1 < mem[_3952]
        mem[_3952 + 64] = _3584
        _5279 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5279] = 0
        mem[_5279 + 32] = 96
        mem[_5279 + 64] = 96
        mem[_5279 + 96] = 0
        mem[_5279 + 128] = 0
        mem[_5279 + 160] = 0
        mem[_5279 + 192] = 0
        mem[_5279 + 224] = 0
        require 0 < mem[_3952]
        _5567 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5567] = 0
        mem[_5567 + 32] = 96
        mem[_5567 + 64] = 96
        mem[_5567 + 96] = 0
        mem[_5567 + 128] = 0
        mem[_5567 + 160] = 0
        mem[_5567 + 192] = 0
        mem[_5567 + 224] = 0
        require 1 < mem[_3952]
        if mem[_1808 + 96] <= mem[_3584 + 96]:
            idx = 12
            s = mem[_1808 + 96]
            while idx >= 4:
                if not mem[_1808 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1808 + 96] - idx
                continue 
            _6329 = mem[_1808 + 96]
            _6330 = mem[_1808 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6329 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3584 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3584 + 128] / 10^(mem[_3584 + 96] - s):
                if not _6330 / 10^(_6329 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6330 / 10^(_6329 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6330 / 10^(_6329 - s))
            if 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6330 / 10^(_6329 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _6330 / 10^(_6329 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _6330 / 10^(_6329 - s))
        idx = 12
        s = mem[_3584 + 96]
        while idx >= 4:
            if not mem[_3584 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3584 + 96] - idx
            continue 
        _6331 = mem[_1808 + 96]
        _6332 = mem[_1808 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6331 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3584 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3584 + 128] / 10^(mem[_3584 + 96] - s):
            if not _6332 / 10^(_6331 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6332 / 10^(_6331 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6332 / 10^(_6331 - s))
        if 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6332 / 10^(_6331 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _6332 / 10^(_6331 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _6332 / 10^(_6331 - s))
    if busdAddress == uint64(ext_call.return_data[0]) << 96:
        _4000 = mem[64]
        mem[mem[64]] = 2
        _4990 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4990] = 0
        mem[_4990 + 32] = 96
        mem[_4990 + 64] = 96
        mem[_4990 + 96] = 0
        mem[_4990 + 128] = 0
        mem[_4990 + 160] = 0
        mem[_4990 + 192] = 0
        mem[_4990 + 224] = 0
        mem[var190001] = _4990
        s = var190001
        idx = var190002
        while idx - 1:
            _4990 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4990] = 0
            mem[_4990 + 32] = 96
            mem[_4990 + 64] = 96
            mem[_4990 + 96] = 0
            mem[_4990 + 128] = 0
            mem[_4990 + 160] = 0
            mem[_4990 + 192] = 0
            mem[_4990 + 224] = 0
            mem[s + 32] = _4990
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4000]
        mem[_4000 + 32] = _3584
        require 1 < mem[_4000]
        mem[_4000 + 64] = _1808
        _5278 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5278] = 0
        mem[_5278 + 32] = 96
        mem[_5278 + 64] = 96
        mem[_5278 + 96] = 0
        mem[_5278 + 128] = 0
        mem[_5278 + 160] = 0
        mem[_5278 + 192] = 0
        mem[_5278 + 224] = 0
        require 0 < mem[_4000]
        _5566 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5566] = 0
        mem[_5566 + 32] = 96
        mem[_5566 + 64] = 96
        mem[_5566 + 96] = 0
        mem[_5566 + 128] = 0
        mem[_5566 + 160] = 0
        mem[_5566 + 192] = 0
        mem[_5566 + 224] = 0
        require 1 < mem[_4000]
        if mem[_3584 + 96] <= mem[_1808 + 96]:
            idx = 12
            s = mem[_3584 + 96]
            while idx >= 4:
                if not mem[_3584 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3584 + 96] - idx
                continue 
            _6325 = mem[_3584 + 96]
            _6326 = mem[_3584 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6325 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6326 / 10^(_6325 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6326 / 10^(_6325 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6326 / 10^(_6325 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6326 / 10^(_6325 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6326 / 10^(_6325 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6326 / 10^(_6325 - s))
        idx = 12
        s = mem[_1808 + 96]
        while idx >= 4:
            if not mem[_1808 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1808 + 96] - idx
            continue 
        _6327 = mem[_3584 + 96]
        _6328 = mem[_3584 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6327 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1808 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
            if not _6328 / 10^(_6327 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6328 / 10^(_6327 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6328 / 10^(_6327 - s))
        if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6328 / 10^(_6327 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6328 / 10^(_6327 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6328 / 10^(_6327 - s))
    if usdtAddress == uint64(ext_call.return_data[0]) << 96:
        _4048 = mem[64]
        mem[mem[64]] = 2
        _4989 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4989] = 0
        mem[_4989 + 32] = 96
        mem[_4989 + 64] = 96
        mem[_4989 + 96] = 0
        mem[_4989 + 128] = 0
        mem[_4989 + 160] = 0
        mem[_4989 + 192] = 0
        mem[_4989 + 224] = 0
        mem[var193001] = _4989
        s = var193001
        idx = var193002
        while idx - 1:
            _4989 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4989] = 0
            mem[_4989 + 32] = 96
            mem[_4989 + 64] = 96
            mem[_4989 + 96] = 0
            mem[_4989 + 128] = 0
            mem[_4989 + 160] = 0
            mem[_4989 + 192] = 0
            mem[_4989 + 224] = 0
            mem[s + 32] = _4989
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4048]
        mem[_4048 + 32] = _3584
        require 1 < mem[_4048]
        mem[_4048 + 64] = _1808
        _5277 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5277] = 0
        mem[_5277 + 32] = 96
        mem[_5277 + 64] = 96
        mem[_5277 + 96] = 0
        mem[_5277 + 128] = 0
        mem[_5277 + 160] = 0
        mem[_5277 + 192] = 0
        mem[_5277 + 224] = 0
        require 0 < mem[_4048]
        _5565 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5565] = 0
        mem[_5565 + 32] = 96
        mem[_5565 + 64] = 96
        mem[_5565 + 96] = 0
        mem[_5565 + 128] = 0
        mem[_5565 + 160] = 0
        mem[_5565 + 192] = 0
        mem[_5565 + 224] = 0
        require 1 < mem[_4048]
        if mem[_3584 + 96] <= mem[_1808 + 96]:
            idx = 12
            s = mem[_3584 + 96]
            while idx >= 4:
                if not mem[_3584 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3584 + 96] - idx
                continue 
            _6321 = mem[_3584 + 96]
            _6322 = mem[_3584 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6321 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1808 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
                if not _6322 / 10^(_6321 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6322 / 10^(_6321 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6322 / 10^(_6321 - s))
            if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6322 / 10^(_6321 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6322 / 10^(_6321 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6322 / 10^(_6321 - s))
        idx = 12
        s = mem[_1808 + 96]
        while idx >= 4:
            if not mem[_1808 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1808 + 96] - idx
            continue 
        _6323 = mem[_3584 + 96]
        _6324 = mem[_3584 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6323 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1808 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1808 + 128] / 10^(mem[_1808 + 96] - s):
            if not _6324 / 10^(_6323 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6324 / 10^(_6323 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6324 / 10^(_6323 - s))
        if 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6324 / 10^(_6323 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6324 / 10^(_6323 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1808 + 128] / 10^(mem[_1808 + 96] - s) / _6324 / 10^(_6323 - s))
    idx = 0
    while idx < sub_27d312da.length:
        mem[0] = 1
        if sub_27d312da[idx] != address(ext_call.return_data[0]):
            idx = idx + 1
            continue 
        _4460 = mem[64]
        mem[mem[64]] = 2
        _6016 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_6016] = 0
        mem[_6016 + 32] = 96
        mem[_6016 + 64] = 96
        mem[_6016 + 96] = 0
        mem[_6016 + 128] = 0
        mem[_6016 + 160] = 0
        mem[_6016 + 192] = 0
        mem[_6016 + 224] = 0
        mem[var202001] = _6016
        s = var202001
        idx = var202002
        while idx - 1:
            _6016 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6016] = 0
            mem[_6016 + 32] = 96
            mem[_6016 + 64] = 96
            mem[_6016 + 96] = 0
            mem[_6016 + 128] = 0
            mem[_6016 + 160] = 0
            mem[_6016 + 192] = 0
            mem[_6016 + 224] = 0
            mem[s + 32] = _6016
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4460]
        mem[_4460 + 32] = _3584
        require 1 < mem[_4460]
        mem[_4460 + 64] = _1808
        _6616 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6616] = 0
        mem[_6616 + 32] = 96
        mem[_6616 + 64] = 96
        mem[_6616 + 96] = 0
        mem[_6616 + 128] = 0
        mem[_6616 + 160] = 0
        mem[_6616 + 192] = 0
        mem[_6616 + 224] = 0
        require 0 < mem[_4460]
        _6848 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6848] = 0
        mem[_6848 + 32] = 96
        mem[_6848 + 64] = 96
        mem[_6848 + 96] = 0
        mem[_6848 + 128] = 0
        mem[_6848 + 160] = 0
        mem[_6848 + 192] = 0
        mem[_6848 + 224] = 0
        require 1 < mem[_4460]
        if mem[_3584 + 96] <= mem[_1808 + 96]:
            idx = 12
            s = mem[_3584 + 96]
            while idx >= 4:
                if not mem[_3584 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3584 + 96] - idx
                continue 
            _13117 = mem[_3584 + 96]
            _13118 = mem[_3584 + 128]
            _13183 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13183] = 26
            mem[_13183 + 32] = 'SafeMath: division by zero'
            if not 10^(_13117 - s):
                _13967 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13967 + 68] = mem[idx + _13183 + 32]
                    idx = idx + 32
                    continue 
                mem[_13967 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13967 + -mem[64] + 100
            _14973 = mem[_1808 + 96]
            _14974 = mem[_1808 + 128]
            _15101 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15101] = 26
            mem[_15101 + 32] = 'SafeMath: division by zero'
            if not 10^(_14973 - s):
                _15167 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15167 + 68] = mem[idx + _15101 + 32]
                    idx = idx + 32
                    continue 
                mem[_15167 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15167 + -mem[64] + 100
            if not _14974 / 10^(_14973 - s):
                _15551 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15551] = 26
                mem[_15551 + 32] = 'SafeMath: division by zero'
                if not _13118 / 10^(_13117 - s):
                    _15868 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15868 + 68] = mem[idx + _15551 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15868 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15868 + -mem[64] + 100
                _16381 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16381] = 26
                mem[_16381 + 32] = 'SafeMath: division by zero'
                if 0 / _13118 / 10^(_13117 - s):
                    return (1000000 * 10^18 / 0 / _13118 / 10^(_13117 - s))
                _16637 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16637 + 68] = mem[idx + _16381 + 32]
                    idx = idx + 32
                    continue 
                mem[_16637 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16637 + -mem[64] + 100
            if 10^12 * _14974 / 10^(_14973 - s) / _14974 / 10^(_14973 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15867 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15867] = 26
            mem[_15867 + 32] = 'SafeMath: division by zero'
            if not _13118 / 10^(_13117 - s):
                _15997 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15997 + 68] = mem[idx + _15867 + 32]
                    idx = idx + 32
                    continue 
                mem[_15997 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15997 + -mem[64] + 100
            _16635 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16635] = 26
            mem[_16635 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14974 / 10^(_14973 - s) / _13118 / 10^(_13117 - s):
                return (1000000 * 10^18 / 10^12 * _14974 / 10^(_14973 - s) / _13118 / 10^(_13117 - s))
            _16765 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16765 + 68] = mem[idx + _16635 + 32]
                idx = idx + 32
                continue 
            mem[_16765 + 94] = 0
            revert with memory
              from mem[64]
               len _16765 + -mem[64] + 100
        idx = 12
        s = mem[_1808 + 96]
        while idx >= 4:
            if not mem[_1808 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1808 + 96] - idx
            continue 
        _13119 = mem[_3584 + 96]
        _13120 = mem[_3584 + 128]
        _13184 = mem[64]
        mem[64] = mem[64] + 64
        mem[_13184] = 26
        mem[_13184 + 32] = 'SafeMath: division by zero'
        if not 10^(_13119 - s):
            _13968 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _13968 + 68] = mem[idx + _13184 + 32]
                idx = idx + 32
                continue 
            mem[_13968 + 94] = 0
            revert with memory
              from mem[64]
               len _13968 + -mem[64] + 100
        _14975 = mem[_1808 + 96]
        _14976 = mem[_1808 + 128]
        _15103 = mem[64]
        mem[64] = mem[64] + 64
        mem[_15103] = 26
        mem[_15103 + 32] = 'SafeMath: division by zero'
        if not 10^(_14975 - s):
            _15168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _15168 + 68] = mem[idx + _15103 + 32]
                idx = idx + 32
                continue 
            mem[_15168 + 94] = 0
            revert with memory
              from mem[64]
               len _15168 + -mem[64] + 100
        if not _14976 / 10^(_14975 - s):
            _15552 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15552] = 26
            mem[_15552 + 32] = 'SafeMath: division by zero'
            if not _13120 / 10^(_13119 - s):
                _15871 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15871 + 68] = mem[idx + _15552 + 32]
                    idx = idx + 32
                    continue 
                mem[_15871 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15871 + -mem[64] + 100
            _16383 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16383] = 26
            mem[_16383 + 32] = 'SafeMath: division by zero'
            if 0 / _13120 / 10^(_13119 - s):
                return (1000000 * 10^18 / 0 / _13120 / 10^(_13119 - s))
            _16640 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16640 + 68] = mem[idx + _16383 + 32]
                idx = idx + 32
                continue 
            mem[_16640 + 94] = 0
            revert with memory
              from mem[64]
               len _16640 + -mem[64] + 100
        if 10^12 * _14976 / 10^(_14975 - s) / _14976 / 10^(_14975 - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _15870 = mem[64]
        mem[64] = mem[64] + 64
        mem[_15870] = 26
        mem[_15870 + 32] = 'SafeMath: division by zero'
        if not _13120 / 10^(_13119 - s):
            _15999 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _15999 + 68] = mem[idx + _15870 + 32]
                idx = idx + 32
                continue 
            mem[_15999 + 94] = 0
            revert with memory
              from mem[64]
               len _15999 + -mem[64] + 100
        _16638 = mem[64]
        mem[64] = mem[64] + 64
        mem[_16638] = 26
        mem[_16638 + 32] = 'SafeMath: division by zero'
        if 10^12 * _14976 / 10^(_14975 - s) / _13120 / 10^(_13119 - s):
            return (1000000 * 10^18 / 10^12 * _14976 / 10^(_14975 - s) / _13120 / 10^(_13119 - s))
        _16767 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _16767 + 68] = mem[idx + _16638 + 32]
            idx = idx + 32
            continue 
        mem[_16767 + 94] = 0
        revert with memory
          from mem[64]
           len _16767 + -mem[64] + 100
    _4300 = mem[64]
    mem[mem[64]] = 2
    _6015 = mem[64] + 96
    mem[64] = mem[64] + 352
    mem[_6015] = 0
    mem[_6015 + 32] = 96
    mem[_6015 + 64] = 96
    mem[_6015 + 96] = 0
    mem[_6015 + 128] = 0
    mem[_6015 + 160] = 0
    mem[_6015 + 192] = 0
    mem[_6015 + 224] = 0
    mem[var198001] = _6015
    s = var198001
    idx = var198002
    while idx - 1:
        _6015 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6015] = 0
        mem[_6015 + 32] = 96
        mem[_6015 + 64] = 96
        mem[_6015 + 96] = 0
        mem[_6015 + 128] = 0
        mem[_6015 + 160] = 0
        mem[_6015 + 192] = 0
        mem[_6015 + 224] = 0
        mem[s + 32] = _6015
        s = s + 32
        idx = idx - 1
        continue 
    require 0 < mem[_4300]
    mem[_4300 + 32] = _1808
    require 1 < mem[_4300]
    mem[_4300 + 64] = _3584
    _6615 = mem[64]
    mem[64] = mem[64] + 256
    mem[_6615] = 0
    mem[_6615 + 32] = 96
    mem[_6615 + 64] = 96
    mem[_6615 + 96] = 0
    mem[_6615 + 128] = 0
    mem[_6615 + 160] = 0
    mem[_6615 + 192] = 0
    mem[_6615 + 224] = 0
    require 0 < mem[_4300]
    _6847 = mem[64]
    mem[64] = mem[64] + 256
    mem[_6847] = 0
    mem[_6847 + 32] = 96
    mem[_6847 + 64] = 96
    mem[_6847 + 96] = 0
    mem[_6847 + 128] = 0
    mem[_6847 + 160] = 0
    mem[_6847 + 192] = 0
    mem[_6847 + 224] = 0
    require 1 < mem[_4300]
    if mem[_1808 + 96] <= mem[_3584 + 96]:
        idx = 12
        s = mem[_1808 + 96]
        while idx >= 4:
            if not mem[_1808 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1808 + 96] - idx
            continue 
        _13113 = mem[_1808 + 96]
        _13114 = mem[_1808 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13113 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3584 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3584 + 128] / 10^(mem[_3584 + 96] - s):
            if not _13114 / 10^(_13113 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13114 / 10^(_13113 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13114 / 10^(_13113 - s))
        if 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13114 / 10^(_13113 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _13114 / 10^(_13113 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _13114 / 10^(_13113 - s))
    idx = 12
    s = mem[_3584 + 96]
    while idx >= 4:
        if not mem[_3584 + 96] - idx:
            idx = idx - 1
            s = s
            continue 
        idx = idx - 1
        s = mem[_3584 + 96] - idx
        continue 
    _13115 = mem[_1808 + 96]
    _13116 = mem[_1808 + 128]
    mem[mem[64]] = 26
    mem[mem[64] + 32] = 'SafeMath: division by zero'
    if not 10^(_13115 - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not 10^(mem[_3584 + 96] - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not mem[_3584 + 128] / 10^(mem[_3584 + 96] - s):
        if not _13116 / 10^(_13115 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / _13116 / 10^(_13115 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 0 / _13116 / 10^(_13115 - s))
    if 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if not _13116 / 10^(_13115 - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _13116 / 10^(_13115 - s):
        revert with 0, 'SafeMath: division by zero', 0
    return (1000000 * 10^18 / 10^12 * mem[_3584 + 128] / 10^(mem[_3584 + 96] - s) / _13116 / 10^(_13115 - s))
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
address _owner;
address stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
uint256 totalSupply;
uint256 stor6;
uint256 totalFees;
array of struct stor8;
array of struct stor9;
uint256 decimals;
uint256 _taxFee;
uint256 _liquidityFee;
uint256 _destroyFee;
address sub_c41d28c5Address;
address uniswapV2PairAddress;

function totalFees() {
    return totalFees
}

function totalSupply() {
    return totalSupply
}

function decimals() {
    return decimals
}

function _taxFee() {
    return _taxFee
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function isExcludedFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function _liquidityFee() {
    return _liquidityFee
}

function owner() {
    return _owner
}

function _destroyFee() {
    return _destroyFee
}

function _owner() {
    return _owner
}

function sub_c41d28c5(?) {
    return sub_c41d28c5Address
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function setLiquidityFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _liquidityFee = arg1
}

function changeOwner(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _owner = arg1
}

function includeInFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor4[address(arg1)] = 0
}

function excludeFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor4[address(arg1)] = 1
}

function changeRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    uniswapV2PairAddress = arg1
}

function sub_17906aa0(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_c41d28c5Address = address(arg1)
    _taxFee = arg2
    _destroyFee = arg3
}

function tokenFromReflection(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor6 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor6 / totalSupply)
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor6 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor2[address(arg1)] / stor6 / totalSupply)
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function sub_0512e486(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if stor1 != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not arg2:
        stor2[address(arg1)] = 0
    else:
        if arg2 and stor6 / totalSupply > -1 / arg2:
            revert with 0, 17
        if not arg2:
            revert with 0, 18
        if arg2 * stor6 / totalSupply / arg2 != stor6 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        stor2[address(arg1)] = arg2 * stor6 / totalSupply
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function name() {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function symbol() {
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor9.length):
                if 31 < uint255(stor9.length) * 0.5:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor9.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        else:
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 0, 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        mem[ceil32(uint255(stor9.length) * 0.5) + 192 len ceil32(uint255(stor9.length) * 0.5)] = mem[128 len ceil32(uint255(stor9.length) * 0.5)]
        if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
            mem[ceil32(uint255(stor9.length) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
    if bool(stor9.length) == stor9.length.field_1 < 32:
        revert with 0, 34
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor9.length):
            if 31 < uint255(stor9.length) * 0.5:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while (uint255(stor9.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    else:
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 0, 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
    if ceil32(stor9.length.field_1) > stor9.length.field_1:
        mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if stor4[address(msg.sender)]:
        if not arg2:
            if 0 > stor2[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor2[address(msg.sender)] < 0:
                revert with 0, 17
            if stor2[address(arg1)] > -1:
                revert with 0, 17
            if stor2[address(arg1)] < stor2[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
        else:
            if arg2 and stor6 / totalSupply > -1 / arg2:
                revert with 0, 17
            if not arg2:
                revert with 0, 18
            if arg2 * stor6 / totalSupply / arg2 != stor6 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg2 * stor6 / totalSupply > stor2[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor2[address(msg.sender)] < arg2 * stor6 / totalSupply:
                revert with 0, 17
            stor2[address(msg.sender)] += -1 * arg2 * stor6 / totalSupply
            if not arg2 * stor6 / totalSupply / 100:
                if stor2[address(arg1)] > -1:
                    revert with 0, 17
                if stor2[address(arg1)] < stor2[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if arg2 * stor6 / totalSupply / 100 and 100 > -1 / arg2 * stor6 / totalSupply / 100:
                    revert with 0, 17
                if not arg2 * stor6 / totalSupply / 100:
                    revert with 0, 18
                if 100 * arg2 * stor6 / totalSupply / 100 / arg2 * stor6 / totalSupply / 100 != 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                if stor2[address(arg1)] > !(100 * arg2 * stor6 / totalSupply / 100):
                    revert with 0, 17
                if stor2[address(arg1)] + (100 * arg2 * stor6 / totalSupply / 100) < stor2[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor2[address(arg1)] += 100 * arg2 * stor6 / totalSupply / 100
        if not arg2 / 100:
            emit Transfer(0, msg.sender, arg1);
        else:
            if arg2 / 100 and 100 > -1 / arg2 / 100:
                revert with 0, 17
            if not arg2 / 100:
                revert with 0, 18
            if 100 * arg2 / 100 / arg2 / 100 != 100:
                revert with 0, 'SafeMath: multiplication overflow'
            emit Transfer((100 * arg2 / 100), msg.sender, arg1);
    else:
        if stor4[address(arg1)]:
            if not arg2:
                if 0 > stor2[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor2[address(msg.sender)] < 0:
                    revert with 0, 17
                if stor2[address(arg1)] > -1:
                    revert with 0, 17
                if stor2[address(arg1)] < stor2[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if arg2 and stor6 / totalSupply > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * stor6 / totalSupply / arg2 != stor6 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg2 * stor6 / totalSupply > stor2[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor2[address(msg.sender)] < arg2 * stor6 / totalSupply:
                    revert with 0, 17
                stor2[address(msg.sender)] += -1 * arg2 * stor6 / totalSupply
                if not arg2 * stor6 / totalSupply / 100:
                    if stor2[address(arg1)] > -1:
                        revert with 0, 17
                    if stor2[address(arg1)] < stor2[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if arg2 * stor6 / totalSupply / 100 and 100 > -1 / arg2 * stor6 / totalSupply / 100:
                        revert with 0, 17
                    if not arg2 * stor6 / totalSupply / 100:
                        revert with 0, 18
                    if 100 * arg2 * stor6 / totalSupply / 100 / arg2 * stor6 / totalSupply / 100 != 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if stor2[address(arg1)] > !(100 * arg2 * stor6 / totalSupply / 100):
                        revert with 0, 17
                    if stor2[address(arg1)] + (100 * arg2 * stor6 / totalSupply / 100) < stor2[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor2[address(arg1)] += 100 * arg2 * stor6 / totalSupply / 100
            if not arg2 / 100:
                emit Transfer(0, msg.sender, arg1);
            else:
                if arg2 / 100 and 100 > -1 / arg2 / 100:
                    revert with 0, 17
                if not arg2 / 100:
                    revert with 0, 18
                if 100 * arg2 / 100 / arg2 / 100 != 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                emit Transfer((100 * arg2 / 100), msg.sender, arg1);
        else:
            if not arg2:
                if 0 > stor2[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor2[address(msg.sender)] < 0:
                    revert with 0, 17
                if not arg2 / 100:
                    if stor2[stor14] > -1:
                        revert with 0, 17
                    if stor2[stor14] < stor2[stor14]:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, msg.sender, sub_c41d28c5Address);
                else:
                    if arg2 / 100 and _destroyFee > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if arg2 / 100 * _destroyFee / arg2 / 100 != _destroyFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg2 / 100 * _destroyFee:
                        if stor2[stor14] > -1:
                            revert with 0, 17
                        if stor2[stor14] < stor2[stor14]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 * _destroyFee and stor6 / totalSupply > -1 / arg2 / 100 * _destroyFee:
                            revert with 0, 17
                        if not arg2 / 100 * _destroyFee:
                            revert with 0, 18
                        if arg2 / 100 * _destroyFee * stor6 / totalSupply / arg2 / 100 * _destroyFee != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[stor14] > !(arg2 / 100 * _destroyFee * stor6 / totalSupply):
                            revert with 0, 17
                        if stor2[stor14] + (arg2 / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[stor14] += arg2 / 100 * _destroyFee * stor6 / totalSupply
                    emit Transfer((arg2 / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                if not arg2 / 100:
                    if stor2[stor15] > -1:
                        revert with 0, 17
                    if stor2[stor15] < stor2[stor15]:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                else:
                    if arg2 / 100 and _liquidityFee > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if arg2 / 100 * _liquidityFee / arg2 / 100 != _liquidityFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg2 / 100 * _liquidityFee:
                        if stor2[stor15] > -1:
                            revert with 0, 17
                        if stor2[stor15] < stor2[stor15]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 * _liquidityFee and stor6 / totalSupply > -1 / arg2 / 100 * _liquidityFee:
                            revert with 0, 17
                        if not arg2 / 100 * _liquidityFee:
                            revert with 0, 18
                        if arg2 / 100 * _liquidityFee * stor6 / totalSupply / arg2 / 100 * _liquidityFee != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[stor15] > !(arg2 / 100 * _liquidityFee * stor6 / totalSupply):
                            revert with 0, 17
                        if stor2[stor15] + (arg2 / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[stor15] += arg2 / 100 * _liquidityFee * stor6 / totalSupply
                    emit Transfer((arg2 / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                if not arg2 / 100:
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if arg2 / 100 and _taxFee > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if arg2 / 100 * _taxFee / arg2 / 100 != _taxFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > !(arg2 / 100 * _taxFee):
                        revert with 0, 17
                    if totalFees + (arg2 / 100 * _taxFee) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg2 / 100 * _taxFee
                if _taxFee > !_liquidityFee:
                    revert with 0, 17
                if _taxFee + _liquidityFee > !_destroyFee:
                    revert with 0, 17
                if 100 < _taxFee + _liquidityFee + _destroyFee:
                    revert with 0, 17
                if stor2[address(arg1)] > -1:
                    revert with 0, 17
                if stor2[address(arg1)] < stor2[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if arg2 and stor6 / totalSupply > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * stor6 / totalSupply / arg2 != stor6 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg2 * stor6 / totalSupply > stor2[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor2[address(msg.sender)] < arg2 * stor6 / totalSupply:
                    revert with 0, 17
                stor2[address(msg.sender)] += -1 * arg2 * stor6 / totalSupply
                if not arg2 / 100:
                    if stor2[stor14] > -1:
                        revert with 0, 17
                    if stor2[stor14] < stor2[stor14]:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, msg.sender, sub_c41d28c5Address);
                else:
                    if arg2 / 100 and _destroyFee > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if arg2 / 100 * _destroyFee / arg2 / 100 != _destroyFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg2 / 100 * _destroyFee:
                        if stor2[stor14] > -1:
                            revert with 0, 17
                        if stor2[stor14] < stor2[stor14]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 * _destroyFee and stor6 / totalSupply > -1 / arg2 / 100 * _destroyFee:
                            revert with 0, 17
                        if not arg2 / 100 * _destroyFee:
                            revert with 0, 18
                        if arg2 / 100 * _destroyFee * stor6 / totalSupply / arg2 / 100 * _destroyFee != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[stor14] > !(arg2 / 100 * _destroyFee * stor6 / totalSupply):
                            revert with 0, 17
                        if stor2[stor14] + (arg2 / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[stor14] += arg2 / 100 * _destroyFee * stor6 / totalSupply
                    emit Transfer((arg2 / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                if not arg2 / 100:
                    if stor2[stor15] > -1:
                        revert with 0, 17
                    if stor2[stor15] < stor2[stor15]:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                else:
                    if arg2 / 100 and _liquidityFee > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if arg2 / 100 * _liquidityFee / arg2 / 100 != _liquidityFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg2 / 100 * _liquidityFee:
                        if stor2[stor15] > -1:
                            revert with 0, 17
                        if stor2[stor15] < stor2[stor15]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 * _liquidityFee and stor6 / totalSupply > -1 / arg2 / 100 * _liquidityFee:
                            revert with 0, 17
                        if not arg2 / 100 * _liquidityFee:
                            revert with 0, 18
                        if arg2 / 100 * _liquidityFee * stor6 / totalSupply / arg2 / 100 * _liquidityFee != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[stor15] > !(arg2 / 100 * _liquidityFee * stor6 / totalSupply):
                            revert with 0, 17
                        if stor2[stor15] + (arg2 / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[stor15] += arg2 / 100 * _liquidityFee * stor6 / totalSupply
                    emit Transfer((arg2 / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                if not arg2 * stor6 / totalSupply / 100:
                    if not arg2 / 100:
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 and _taxFee > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if arg2 / 100 * _taxFee / arg2 / 100 != _taxFee:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !(arg2 / 100 * _taxFee):
                            revert with 0, 17
                        if totalFees + (arg2 / 100 * _taxFee) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * _taxFee
                else:
                    if arg2 * stor6 / totalSupply / 100 and _taxFee > -1 / arg2 * stor6 / totalSupply / 100:
                        revert with 0, 17
                    if not arg2 * stor6 / totalSupply / 100:
                        revert with 0, 18
                    if arg2 * stor6 / totalSupply / 100 * _taxFee / arg2 * stor6 / totalSupply / 100 != _taxFee:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg2 / 100:
                        if arg2 * stor6 / totalSupply / 100 * _taxFee > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < arg2 * stor6 / totalSupply / 100 * _taxFee:
                            revert with 0, 17
                        stor6 += -1 * arg2 * stor6 / totalSupply / 100 * _taxFee
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 / 100 and _taxFee > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if arg2 / 100 * _taxFee / arg2 / 100 != _taxFee:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * stor6 / totalSupply / 100 * _taxFee > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < arg2 * stor6 / totalSupply / 100 * _taxFee:
                            revert with 0, 17
                        stor6 += -1 * arg2 * stor6 / totalSupply / 100 * _taxFee
                        if totalFees > !(arg2 / 100 * _taxFee):
                            revert with 0, 17
                        if totalFees + (arg2 / 100 * _taxFee) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * _taxFee
                if _taxFee > !_liquidityFee:
                    revert with 0, 17
                if _taxFee + _liquidityFee > !_destroyFee:
                    revert with 0, 17
                if 100 < _taxFee + _liquidityFee + _destroyFee:
                    revert with 0, 17
                if not arg2 * stor6 / totalSupply / 100:
                    if stor2[address(arg1)] > -1:
                        revert with 0, 17
                    if stor2[address(arg1)] < stor2[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if arg2 * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / arg2 * stor6 / totalSupply / 100:
                        revert with 0, 17
                    if not arg2 * stor6 / totalSupply / 100:
                        revert with 0, 18
                    if (100 * arg2 * stor6 / totalSupply / 100) - (_taxFee * arg2 * stor6 / totalSupply / 100) - (_liquidityFee * arg2 * stor6 / totalSupply / 100) - (_destroyFee * arg2 * stor6 / totalSupply / 100) / arg2 * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if stor2[address(arg1)] > !((100 * arg2 * stor6 / totalSupply / 100) - (_taxFee * arg2 * stor6 / totalSupply / 100) - (_liquidityFee * arg2 * stor6 / totalSupply / 100) - (_destroyFee * arg2 * stor6 / totalSupply / 100)):
                        revert with 0, 17
                    if stor2[address(arg1)] + (100 * arg2 * stor6 / totalSupply / 100) - (_taxFee * arg2 * stor6 / totalSupply / 100) - (_liquidityFee * arg2 * stor6 / totalSupply / 100) - (_destroyFee * arg2 * stor6 / totalSupply / 100) < stor2[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor2[address(arg1)] = stor2[address(arg1)] + (100 * arg2 * stor6 / totalSupply / 100) - (_taxFee * arg2 * stor6 / totalSupply / 100) - (_liquidityFee * arg2 * stor6 / totalSupply / 100) - (_destroyFee * arg2 * stor6 / totalSupply / 100)
            if not arg2 / 100:
                emit Transfer(0, msg.sender, arg1);
            else:
                if arg2 / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / arg2 / 100:
                    revert with 0, 17
                if not arg2 / 100:
                    revert with 0, 18
                if (100 * arg2 / 100) - (_taxFee * arg2 / 100) - (_liquidityFee * arg2 / 100) - (_destroyFee * arg2 / 100) / arg2 / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                emit Transfer(((100 * arg2 / 100) - (_taxFee * arg2 / 100) - (_liquidityFee * arg2 / 100) - (_destroyFee * arg2 / 100)), msg.sender, arg1);
    return 1
}

function sub_d30b2036(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 > test266151307() or ceil32(32 * ('cd', 4).length) + 97 < 96:
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require (32 * ('cd', 4).length) + cd[4] + 36 <= calldata.size
    s = 128
    idx = cd[4] + 36
    while idx < (32 * ('cd', 4).length) + cd[4] + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        s = s + 32
        idx = idx + 32
        continue 
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _5626 = mem[(32 * idx) + 128]
        if not msg.sender:
            revert with 0, 'ERC20: transfer from the zero address'
        if not mem[(32 * idx) + 140 len 20]:
            revert with 0, 'ERC20: transfer to the zero address'
        if cd[36] <= 0:
            revert with 0, 'Transfer amount must be greater than zero'
        mem[0] = msg.sender
        mem[32] = 4
        if stor4[address(msg.sender)]:
            _5635 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5635] = 26
            mem[_5635 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _5638 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5638 + 68] = mem[idx + _5635 + 32]
                    idx = idx + 32
                    continue 
                mem[_5638 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5638 + -mem[64] + 100
            if stor6 >= stor6 / totalSupply:
                _5653 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5653] = 26
                mem[_5653 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _5659 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5659 + 68] = mem[idx + _5653 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5659 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5659 + -mem[64] + 100
                if not cd[36]:
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5693 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5693] = 30
                    mem[_5693 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor2[address(msg.sender)]:
                        _5701 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5701 + 68] = mem[idx + _5693 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5701 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5701 + -mem[64] + 100
                    if stor2[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5779 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5779] = 26
                    mem[_5779 + 32] = 'SafeMath: division by zero'
                    if stor2[address(_5626)] > -1:
                        revert with 0, 17
                    if stor2[address(_5626)] < stor2[address(_5626)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(_5626)
                    mem[32] = 2
                    _5829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5829] = 26
                    mem[_5829 + 32] = 'SafeMath: division by zero'
                else:
                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                        revert with 0, 17
                    if not cd[36]:
                        revert with 0, 18
                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5731] = 30
                    mem[_5731 + 32] = 'SafeMath: subtraction overflow'
                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                        _5751 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5751 + 68] = mem[idx + _5731 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5751 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5751 + -mem[64] + 100
                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                    _5805 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5805] = 26
                    mem[_5805 + 32] = 'SafeMath: division by zero'
                    if not cd[36] * stor6 / totalSupply / 100:
                        if stor2[address(_5626)] > -1:
                            revert with 0, 17
                        if stor2[address(_5626)] < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        _5875 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5875] = 26
                        mem[_5875 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 17
                        if not cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 18
                        if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[address(_5626)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                            revert with 0, 17
                        if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        stor2[address(_5626)] += 100 * cd[36] * stor6 / totalSupply / 100
                        _5931 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5931] = 26
                        mem[_5931 + 32] = 'SafeMath: division by zero'
            else:
                _5654 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5654] = 26
                mem[_5654 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _5660 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5660 + 68] = mem[idx + _5654 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5660 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5660 + -mem[64] + 100
                if not cd[36]:
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5694] = 30
                    mem[_5694 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor2[address(msg.sender)]:
                        _5702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5702 + 68] = mem[idx + _5694 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5702 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5702 + -mem[64] + 100
                    if stor2[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5780 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5780] = 26
                    mem[_5780 + 32] = 'SafeMath: division by zero'
                    if stor2[address(_5626)] > -1:
                        revert with 0, 17
                    if stor2[address(_5626)] < stor2[address(_5626)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(_5626)
                    mem[32] = 2
                    _5830 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5830] = 26
                    mem[_5830 + 32] = 'SafeMath: division by zero'
                else:
                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                        revert with 0, 17
                    if not cd[36]:
                        revert with 0, 18
                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = msg.sender
                    mem[32] = 2
                    _5732 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5732] = 30
                    mem[_5732 + 32] = 'SafeMath: subtraction overflow'
                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                        _5753 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5753 + 68] = mem[idx + _5732 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5753 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5753 + -mem[64] + 100
                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                    _5806 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5806] = 26
                    mem[_5806 + 32] = 'SafeMath: division by zero'
                    if not cd[36] * stor6 / totalSupply / 100:
                        if stor2[address(_5626)] > -1:
                            revert with 0, 17
                        if stor2[address(_5626)] < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        _5876 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5876] = 26
                        mem[_5876 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 17
                        if not cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 18
                        if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[address(_5626)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                            revert with 0, 17
                        if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        stor2[address(_5626)] += 100 * cd[36] * stor6 / totalSupply / 100
                        _5932 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5932] = 26
                        mem[_5932 + 32] = 'SafeMath: division by zero'
            if not cd[36] / 100:
                mem[mem[64]] = 0
                emit Transfer(0, msg.sender, address(_5626));
            else:
                if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                    revert with 0, 17
                if not cd[36] / 100:
                    revert with 0, 18
                if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[mem[64]] = 100 * cd[36] / 100
                emit Transfer((100 * cd[36] / 100), msg.sender, address(_5626));
        else:
            mem[0] = mem[(32 * idx) + 140 len 20]
            mem[32] = 4
            if stor4[address(mem[(32 * idx) + 128])]:
                _5637 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5637] = 26
                mem[_5637 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _5642 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5642 + 68] = mem[idx + _5637 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5642 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5642 + -mem[64] + 100
                if stor6 >= stor6 / totalSupply:
                    _5657 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5657] = 26
                    mem[_5657 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5667 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5667 + 68] = mem[idx + _5657 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5667 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5667 + -mem[64] + 100
                    if not cd[36]:
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5699] = 30
                        mem[_5699 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor2[address(msg.sender)]:
                            _5709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5709 + 68] = mem[idx + _5699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5709 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5709 + -mem[64] + 100
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5791] = 26
                        mem[_5791 + 32] = 'SafeMath: division by zero'
                        if stor2[address(_5626)] > -1:
                            revert with 0, 17
                        if stor2[address(_5626)] < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        _5851 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5851] = 26
                        mem[_5851 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5749] = 30
                        mem[_5749 + 32] = 'SafeMath: subtraction overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            _5769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5769 + 68] = mem[idx + _5749 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5769 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5769 + -mem[64] + 100
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        _5807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5807] = 26
                        mem[_5807 + 32] = 'SafeMath: division by zero'
                        if not cd[36] * stor6 / totalSupply / 100:
                            if stor2[address(_5626)] > -1:
                                revert with 0, 17
                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = address(_5626)
                            mem[32] = 2
                            _5909 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5909] = 26
                            mem[_5909 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(_5626)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                revert with 0, 17
                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = address(_5626)
                            mem[32] = 2
                            stor2[address(_5626)] += 100 * cd[36] * stor6 / totalSupply / 100
                            _5963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5963] = 26
                            mem[_5963 + 32] = 'SafeMath: division by zero'
                else:
                    _5658 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5658] = 26
                    mem[_5658 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5668 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5668 + 68] = mem[idx + _5658 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5668 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5668 + -mem[64] + 100
                    if not cd[36]:
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5700] = 30
                        mem[_5700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor2[address(msg.sender)]:
                            _5710 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5710 + 68] = mem[idx + _5700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5710 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5710 + -mem[64] + 100
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5792] = 26
                        mem[_5792 + 32] = 'SafeMath: division by zero'
                        if stor2[address(_5626)] > -1:
                            revert with 0, 17
                        if stor2[address(_5626)] < stor2[address(_5626)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(_5626)
                        mem[32] = 2
                        _5852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5852] = 26
                        mem[_5852 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5750] = 30
                        mem[_5750 + 32] = 'SafeMath: subtraction overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            _5771 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5771 + 68] = mem[idx + _5750 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5771 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5771 + -mem[64] + 100
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        _5808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5808] = 26
                        mem[_5808 + 32] = 'SafeMath: division by zero'
                        if not cd[36] * stor6 / totalSupply / 100:
                            if stor2[address(_5626)] > -1:
                                revert with 0, 17
                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = address(_5626)
                            mem[32] = 2
                            _5910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5910] = 26
                            mem[_5910 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(_5626)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                revert with 0, 17
                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = address(_5626)
                            mem[32] = 2
                            stor2[address(_5626)] += 100 * cd[36] * stor6 / totalSupply / 100
                            _5964 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5964] = 26
                            mem[_5964 + 32] = 'SafeMath: division by zero'
                if not cd[36] / 100:
                    mem[mem[64]] = 0
                    emit Transfer(0, msg.sender, address(_5626));
                else:
                    if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                        revert with 0, 17
                    if not cd[36] / 100:
                        revert with 0, 18
                    if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = 100 * cd[36] / 100
                    emit Transfer((100 * cd[36] / 100), msg.sender, address(_5626));
            else:
                _5636 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5636] = 26
                mem[_5636 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _5639 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5639 + 68] = mem[idx + _5636 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5639 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5639 + -mem[64] + 100
                if stor6 >= stor6 / totalSupply:
                    _5655 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5655] = 26
                    mem[_5655 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5661 + 68] = mem[idx + _5655 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5661 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5661 + -mem[64] + 100
                    if not cd[36]:
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5695] = 30
                        mem[_5695 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor2[address(msg.sender)]:
                            _5703 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5703 + 68] = mem[idx + _5695 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5703 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5703 + -mem[64] + 100
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5766] = 26
                        mem[_5766 + 32] = 'SafeMath: division by zero'
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = sub_c41d28c5Address
                            mem[32] = 2
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                            _5861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5861] = 26
                            mem[_5861 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = uniswapV2PairAddress
                                mem[32] = 2
                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                _6071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6071] = 26
                                mem[_6071 + 32] = 'SafeMath: division by zero'
                                _6216 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6216] = 26
                                mem[_6216 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    _6361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6361] = 30
                                    mem[_6361 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _6368 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6368 + 68] = mem[idx + _6361 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6368 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6368 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if _taxFee > !_liquidityFee:
                                        revert with 0, 17
                                    if _taxFee + _liquidityFee > !_destroyFee:
                                        revert with 0, 17
                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                        revert with 0, 17
                                    _6865 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6865] = 26
                                    mem[_6865 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_5626)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_5626)
                                    mem[32] = 2
                                    _7417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7417] = 26
                                    mem[_7417 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6410] = 30
                                    mem[_6410 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _6420 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6420 + 68] = mem[idx + _6410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6420 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6420 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                        revert with 0, 17
                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += cd[36] / 100 * _taxFee
                                    if _taxFee > !_liquidityFee:
                                        revert with 0, 17
                                    if _taxFee + _liquidityFee > !_destroyFee:
                                        revert with 0, 17
                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                        revert with 0, 17
                                    _7090 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7090] = 26
                                    mem[_7090 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_5626)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_5626)
                                    mem[32] = 2
                                    _7536 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7536] = 26
                                    mem[_7536 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not cd[36] / 100 * _liquidityFee:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6135] = 26
                                    mem[_6135 + 32] = 'SafeMath: division by zero'
                                    _6294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6294] = 26
                                    mem[_6294 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6409] = 30
                                        mem[_6409 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6419 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6419 + 68] = mem[idx + _6409 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6419 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6419 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7089] = 26
                                        mem[_7089 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7535] = 26
                                        mem[_7535 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6487 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6487] = 30
                                        mem[_6487 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6519 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6519 + 68] = mem[idx + _6487 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6519 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6519 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7279 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7279] = 26
                                        mem[_7279 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7696 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7696] = 26
                                        mem[_7696 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                        revert with 0, 17
                                    if not cd[36] / 100 * _liquidityFee:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                        revert with 0, 17
                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6215 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6215] = 26
                                    mem[_6215 + 32] = 'SafeMath: division by zero'
                                    _6351 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6351] = 26
                                    mem[_6351 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6486] = 30
                                        mem[_6486 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6518 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6518 + 68] = mem[idx + _6486 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6518 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6518 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7278] = 26
                                        mem[_7278 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7695] = 26
                                        mem[_7695 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6623] = 30
                                        mem[_6623 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6688 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6688 + 68] = mem[idx + _6623 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6688 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6688 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7416 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7416] = 26
                                        mem[_7416 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7937 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7937] = 26
                                        mem[_7937 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5918 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5918] = 26
                                mem[_5918 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6134] = 26
                                    mem[_6134 + 32] = 'SafeMath: division by zero'
                                    _6293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6293] = 26
                                    mem[_6293 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6408 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6408] = 30
                                        mem[_6408 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6418 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6418 + 68] = mem[idx + _6408 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6418 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6418 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7087 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7087] = 26
                                        mem[_7087 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7534 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7534] = 26
                                        mem[_7534 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6485 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6485] = 30
                                        mem[_6485 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6516 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6516 + 68] = mem[idx + _6485 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6516 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6516 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7277] = 26
                                        mem[_7277 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7694] = 26
                                        mem[_7694 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6214] = 26
                                        mem[_6214 + 32] = 'SafeMath: division by zero'
                                        _6350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6350] = 26
                                        mem[_6350 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6484 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6484] = 30
                                            mem[_6484 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6515 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6515 + 68] = mem[idx + _6484 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6515 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6515 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7276 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7276] = 26
                                            mem[_7276 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7693 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7693] = 26
                                            mem[_7693 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6621 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6621] = 30
                                            mem[_6621 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6685 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6685 + 68] = mem[idx + _6621 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6685 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6685 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7415 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7415] = 26
                                            mem[_7415 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7936 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7936] = 26
                                            mem[_7936 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6292] = 26
                                        mem[_6292 + 32] = 'SafeMath: division by zero'
                                        _6396 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6396] = 26
                                        mem[_6396 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6620 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6620] = 30
                                            mem[_6620 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6684 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6684 + 68] = mem[idx + _6620 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6684 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6684 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7414 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7414] = 26
                                            mem[_7414 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7935 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7935] = 26
                                            mem[_7935 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6816 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6816] = 30
                                            mem[_6816 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6911 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6911 + 68] = mem[idx + _6816 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6911 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6911 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7533 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7533] = 26
                                            mem[_7533 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8256 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8256] = 26
                                            mem[_8256 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5972] = 26
                                mem[_5972 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6213] = 26
                                    mem[_6213 + 32] = 'SafeMath: division by zero'
                                    _6349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6349] = 26
                                    mem[_6349 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6483] = 30
                                        mem[_6483 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6514 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6514 + 68] = mem[idx + _6483 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6514 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6514 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7274] = 26
                                        mem[_7274 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7692] = 26
                                        mem[_7692 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6619 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6619] = 30
                                        mem[_6619 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6682 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6682 + 68] = mem[idx + _6619 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6682 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6682 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7413] = 26
                                        mem[_7413 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7934 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7934] = 26
                                        mem[_7934 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6291 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6291] = 26
                                        mem[_6291 + 32] = 'SafeMath: division by zero'
                                        _6395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6395] = 26
                                        mem[_6395 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6618] = 30
                                            mem[_6618 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6681 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6681 + 68] = mem[idx + _6618 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6681 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6681 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7412 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7412] = 26
                                            mem[_7412 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7933] = 26
                                            mem[_7933 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6814 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6814] = 30
                                            mem[_6814 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6908 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6908 + 68] = mem[idx + _6814 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6908 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6908 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7532 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7532] = 26
                                            mem[_7532 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8255 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8255] = 26
                                            mem[_8255 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6348] = 26
                                        mem[_6348 + 32] = 'SafeMath: division by zero'
                                        _6465 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6465] = 26
                                        mem[_6465 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6813 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6813] = 30
                                            mem[_6813 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6907 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6907 + 68] = mem[idx + _6813 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6907 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6907 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7531] = 26
                                            mem[_7531 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8254 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8254] = 26
                                            mem[_8254 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7033 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7033] = 30
                                            mem[_7033 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _7139 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7139 + 68] = mem[idx + _7033 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7139 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7139 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7691 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7691] = 26
                                            mem[_7691 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8615 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8615] = 26
                                            mem[_8615 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5733 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5733] = 30
                        mem[_5733 + 32] = 'SafeMath: subtraction overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            _5755 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5755 + 68] = mem[idx + _5733 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5755 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5755 + -mem[64] + 100
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        _5801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5801] = 26
                        mem[_5801 + 32] = 'SafeMath: division by zero'
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = sub_c41d28c5Address
                            mem[32] = 2
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                            _5917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5917] = 26
                            mem[_5917 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = uniswapV2PairAddress
                                mem[32] = 2
                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                _6133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6133] = 26
                                mem[_6133 + 32] = 'SafeMath: division by zero'
                                if not cd[36] * stor6 / totalSupply / 100:
                                    _6290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6290] = 26
                                    mem[_6290 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6407 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6407] = 30
                                        mem[_6407 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6417 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6417 + 68] = mem[idx + _6407 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6417 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6417 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7079] = 26
                                        mem[_7079 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7530 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7530] = 26
                                            mem[_7530 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7690] = 26
                                            mem[_7690 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6482 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6482] = 30
                                        mem[_6482 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6512 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6512 + 68] = mem[idx + _6482 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6512 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6512 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7270 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7270] = 26
                                        mem[_7270 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7689 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7689] = 26
                                            mem[_7689 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7932 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7932] = 26
                                            mem[_7932 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 17
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6347] = 26
                                    mem[_6347 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6481 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6481] = 30
                                        mem[_6481 + 32] = 'SafeMath: subtraction overflow'
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                            _6511 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6511 + 68] = mem[idx + _6481 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6511 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6511 + -mem[64] + 100
                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                            revert with 0, 17
                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7269] = 26
                                        mem[_7269 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7688 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7688] = 26
                                            mem[_7688 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7931 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7931] = 26
                                            mem[_7931 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6616 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6616] = 30
                                        mem[_6616 + 32] = 'SafeMath: subtraction overflow'
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                            _6678 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6678 + 68] = mem[idx + _6616 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6678 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6678 + -mem[64] + 100
                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                            revert with 0, 17
                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7410] = 26
                                        mem[_7410 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7930 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7930] = 26
                                            mem[_7930 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _8253 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8253] = 26
                                            mem[_8253 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not cd[36] / 100 * _liquidityFee:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6212 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6212] = 26
                                    mem[_6212 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6346] = 26
                                        mem[_6346 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6480 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6480] = 30
                                            mem[_6480 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6510 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6510 + 68] = mem[idx + _6480 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6510 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6510 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7268 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7268] = 26
                                            mem[_7268 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7687 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7687] = 26
                                                mem[_7687 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _7929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7929] = 26
                                                mem[_7929 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6615 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6615] = 30
                                            mem[_6615 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6676 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6676 + 68] = mem[idx + _6615 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6676 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6676 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7409] = 26
                                            mem[_7409 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7928 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7928] = 26
                                                mem[_7928 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8252 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8252] = 26
                                                mem[_8252 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6394] = 26
                                        mem[_6394 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6614 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6614] = 30
                                            mem[_6614 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6675 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6675 + 68] = mem[idx + _6614 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6675 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6675 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7408 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7408] = 26
                                            mem[_7408 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7927 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7927] = 26
                                                mem[_7927 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8251 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8251] = 26
                                                mem[_8251 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6809 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6809] = 30
                                            mem[_6809 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6903 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6903 + 68] = mem[idx + _6809 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6903 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6903 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7529 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7529] = 26
                                            mem[_7529 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8250 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8250] = 26
                                                mem[_8250 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8614 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8614] = 26
                                                mem[_8614 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                        revert with 0, 17
                                    if not cd[36] / 100 * _liquidityFee:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                        revert with 0, 17
                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6289] = 26
                                    mem[_6289 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6393 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6393] = 26
                                        mem[_6393 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6613 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6613] = 30
                                            mem[_6613 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6674 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6674 + 68] = mem[idx + _6613 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6674 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6674 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7407 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7407] = 26
                                            mem[_7407 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7926 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7926] = 26
                                                mem[_7926 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8249 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8249] = 26
                                                mem[_8249 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6808 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6808] = 30
                                            mem[_6808 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6901 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6901 + 68] = mem[idx + _6808 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6901 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6901 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7528 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7528] = 26
                                            mem[_7528 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8248 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8248] = 26
                                                mem[_8248 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8613 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8613] = 26
                                                mem[_8613 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6463 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6463] = 26
                                        mem[_6463 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6807 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6807] = 30
                                            mem[_6807 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6900 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6900 + 68] = mem[idx + _6807 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6900 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6900 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7527 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7527] = 26
                                            mem[_7527 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8247 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8247] = 26
                                                mem[_8247 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8612] = 26
                                                mem[_8612 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7028 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7028] = 30
                                            mem[_7028 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _7135 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7135 + 68] = mem[idx + _7028 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7135 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7135 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7686] = 26
                                            mem[_7686 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8611 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8611] = 26
                                                mem[_8611 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8964 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8964] = 26
                                                mem[_8964 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5971 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5971] = 26
                                mem[_5971 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6211] = 26
                                    mem[_6211 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6345 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6345] = 26
                                        mem[_6345 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6479 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6479] = 30
                                            mem[_6479 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6509 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6509 + 68] = mem[idx + _6479 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6509 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6509 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7263 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7263] = 26
                                            mem[_7263 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7685 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7685] = 26
                                                mem[_7685 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _7925 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7925] = 26
                                                mem[_7925 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6612 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6612] = 30
                                            mem[_6612 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6672 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6672 + 68] = mem[idx + _6612 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6672 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6672 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7405 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7405] = 26
                                            mem[_7405 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7924 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7924] = 26
                                                mem[_7924 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8246 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8246] = 26
                                                mem[_8246 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6392 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6392] = 26
                                        mem[_6392 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6611 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6611] = 30
                                            mem[_6611 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6671 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6671 + 68] = mem[idx + _6611 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6671 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6671 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7404 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7404] = 26
                                            mem[_7404 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7923 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7923] = 26
                                                mem[_7923 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8245 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8245] = 26
                                                mem[_8245 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6805 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6805] = 30
                                            mem[_6805 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6897 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6897 + 68] = mem[idx + _6805 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6897 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6897 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7526 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7526] = 26
                                            mem[_7526 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8244 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8244] = 26
                                                mem[_8244 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8610] = 26
                                                mem[_8610 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6288] = 26
                                        mem[_6288 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6391 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6391] = 26
                                            mem[_6391 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6610] = 30
                                                mem[_6610 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6670 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6670 + 68] = mem[idx + _6610 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6670 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6670 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7403 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7403] = 26
                                                mem[_7403 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _7922 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7922] = 26
                                                    mem[_7922 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8243 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8243] = 26
                                                    mem[_8243 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6804 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6804] = 30
                                                mem[_6804 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6895 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6895 + 68] = mem[idx + _6804 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6895 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6895 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7525 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7525] = 26
                                                mem[_7525 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8242 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8242] = 26
                                                    mem[_8242 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8609 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8609] = 26
                                                    mem[_8609 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6462 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6462] = 26
                                            mem[_6462 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6803 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6803] = 30
                                                mem[_6803 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _6894 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6894 + 68] = mem[idx + _6803 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6894 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6894 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7524 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7524] = 26
                                                mem[_7524 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8241 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8241] = 26
                                                    mem[_8241 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8608 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8608] = 26
                                                    mem[_8608 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7024 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7024] = 30
                                                mem[_7024 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7131 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7131 + 68] = mem[idx + _7024 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7131 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7131 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7684 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7684] = 26
                                                mem[_7684 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8607 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8607] = 26
                                                    mem[_8607 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8963 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8963] = 26
                                                    mem[_8963 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6344] = 26
                                        mem[_6344 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6461 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6461] = 26
                                            mem[_6461 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6802 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6802] = 30
                                                mem[_6802 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6893 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6893 + 68] = mem[idx + _6802 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6893 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6893 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7523 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7523] = 26
                                                mem[_7523 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8240 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8240] = 26
                                                    mem[_8240 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8606 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8606] = 26
                                                    mem[_8606 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7023 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7023] = 30
                                                mem[_7023 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7129 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7129 + 68] = mem[idx + _7023 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7129 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7129 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7683 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7683] = 26
                                                mem[_7683 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8605 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8605] = 26
                                                    mem[_8605 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8962 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8962] = 26
                                                    mem[_8962 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6587] = 26
                                            mem[_6587 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7022 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7022] = 30
                                                mem[_7022 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7128 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7128 + 68] = mem[idx + _7022 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7128 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7128 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7682 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7682] = 26
                                                mem[_7682 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8604 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8604] = 26
                                                    mem[_8604 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8961 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8961] = 26
                                                    mem[_8961 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7219 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7219] = 30
                                                mem[_7219 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7318 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7318 + 68] = mem[idx + _7219 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7318 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7318 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7921 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7921] = 26
                                                mem[_7921 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8960 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8960] = 26
                                                    mem[_8960 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9648 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9648] = 26
                                                    mem[_9648 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _6015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6015] = 26
                                mem[_6015 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6287] = 26
                                    mem[_6287 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6390 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6390] = 26
                                        mem[_6390 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6609 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6609] = 30
                                            mem[_6609 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6669 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6669 + 68] = mem[idx + _6609 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6669 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6669 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7398] = 26
                                            mem[_7398 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7920 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7920] = 26
                                                mem[_7920 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8239 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8239] = 26
                                                mem[_8239 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6801 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6801] = 30
                                            mem[_6801 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6891 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6891 + 68] = mem[idx + _6801 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6891 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6891 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7521 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7521] = 26
                                            mem[_7521 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8238 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8238] = 26
                                                mem[_8238 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8603 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8603] = 26
                                                mem[_8603 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6460] = 26
                                        mem[_6460 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6800 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6800] = 30
                                            mem[_6800 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6890 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6890 + 68] = mem[idx + _6800 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6890 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6890 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7520 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7520] = 26
                                            mem[_7520 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8237 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8237] = 26
                                                mem[_8237 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8602 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8602] = 26
                                                mem[_8602 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7020 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7020] = 30
                                            mem[_7020 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _7125 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7125 + 68] = mem[idx + _7020 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7125 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7125 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7681 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7681] = 26
                                            mem[_7681 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8601 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8601] = 26
                                                mem[_8601 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8959 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8959] = 26
                                                mem[_8959 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6343 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6343] = 26
                                        mem[_6343 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6459 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6459] = 26
                                            mem[_6459 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6799 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6799] = 30
                                                mem[_6799 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6889 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6889 + 68] = mem[idx + _6799 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6889 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6889 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7519 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7519] = 26
                                                mem[_7519 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8236 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8236] = 26
                                                    mem[_8236 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8600 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8600] = 26
                                                    mem[_8600 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7019 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7019] = 30
                                                mem[_7019 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7123 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7123 + 68] = mem[idx + _7019 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7123 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7123 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7680 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7680] = 26
                                                mem[_7680 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8599 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8599] = 26
                                                    mem[_8599 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8958 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8958] = 26
                                                    mem[_8958 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6586] = 26
                                            mem[_6586 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7018 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7018] = 30
                                                mem[_7018 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7122 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7122 + 68] = mem[idx + _7018 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7122 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7122 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7679 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7679] = 26
                                                mem[_7679 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8598 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8598] = 26
                                                    mem[_8598 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8957 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8957] = 26
                                                    mem[_8957 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7215 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7215] = 30
                                                mem[_7215 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7314 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7314 + 68] = mem[idx + _7215 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7314 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7314 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7919 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7919] = 26
                                                mem[_7919 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8956 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8956] = 26
                                                    mem[_8956 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9647 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9647] = 26
                                                    mem[_9647 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6389 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6389] = 26
                                        mem[_6389 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6585 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6585] = 26
                                            mem[_6585 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7017 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7017] = 30
                                                mem[_7017 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7121 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7121 + 68] = mem[idx + _7017 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7121 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7121 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7678 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7678] = 26
                                                mem[_7678 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8597 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8597] = 26
                                                    mem[_8597 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8955 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8955] = 26
                                                    mem[_8955 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7214 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7214] = 30
                                                mem[_7214 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7312 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7312 + 68] = mem[idx + _7214 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7312 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7312 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7918 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7918] = 26
                                                mem[_7918 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8954 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8954] = 26
                                                    mem[_8954 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9646 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9646] = 26
                                                    mem[_9646 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6771 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6771] = 26
                                            mem[_6771 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7213 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7213] = 30
                                                mem[_7213 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7311 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7311 + 68] = mem[idx + _7213 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7311 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7311 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7917 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7917] = 26
                                                mem[_7917 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8953 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8953] = 26
                                                    mem[_8953 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9645 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9645] = 26
                                                    mem[_9645 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7359 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7359] = 30
                                                mem[_7359 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7445 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7445 + 68] = mem[idx + _7359 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7445 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7445 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _8235 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8235] = 26
                                                mem[_8235 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _9644 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9644] = 26
                                                    mem[_9644 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9860 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9860] = 26
                                                    mem[_9860 + 32] = 'SafeMath: division by zero'
                else:
                    _5656 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5656] = 26
                    mem[_5656 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5662 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5662 + 68] = mem[idx + _5656 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5662 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5662 + -mem[64] + 100
                    if not cd[36]:
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5696] = 30
                        mem[_5696 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor2[address(msg.sender)]:
                            _5704 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5704 + 68] = mem[idx + _5696 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5704 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5704 + -mem[64] + 100
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5768] = 26
                        mem[_5768 + 32] = 'SafeMath: division by zero'
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = sub_c41d28c5Address
                            mem[32] = 2
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                            _5862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5862] = 26
                            mem[_5862 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = uniswapV2PairAddress
                                mem[32] = 2
                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                _6072 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6072] = 26
                                mem[_6072 + 32] = 'SafeMath: division by zero'
                                _6222 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6222] = 26
                                mem[_6222 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    _6362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6362] = 30
                                    mem[_6362 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _6372 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6372 + 68] = mem[idx + _6362 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6372 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6372 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if _taxFee > !_liquidityFee:
                                        revert with 0, 17
                                    if _taxFee + _liquidityFee > !_destroyFee:
                                        revert with 0, 17
                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                        revert with 0, 17
                                    _6888 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6888] = 26
                                    mem[_6888 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_5626)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_5626)
                                    mem[32] = 2
                                    _7444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7444] = 26
                                    mem[_7444 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6414] = 30
                                    mem[_6414 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _6425 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6425 + 68] = mem[idx + _6414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6425 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6425 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                        revert with 0, 17
                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += cd[36] / 100 * _taxFee
                                    if _taxFee > !_liquidityFee:
                                        revert with 0, 17
                                    if _taxFee + _liquidityFee > !_destroyFee:
                                        revert with 0, 17
                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                        revert with 0, 17
                                    _7120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7120] = 26
                                    mem[_7120 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_5626)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_5626)
                                    mem[32] = 2
                                    _7558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7558] = 26
                                    mem[_7558 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not cd[36] / 100 * _liquidityFee:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6138 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6138] = 26
                                    mem[_6138 + 32] = 'SafeMath: division by zero'
                                    _6302 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6302] = 26
                                    mem[_6302 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6413] = 30
                                        mem[_6413 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6424 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6424 + 68] = mem[idx + _6413 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6424 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6424 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7119] = 26
                                        mem[_7119 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7557 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7557] = 26
                                        mem[_7557 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6497] = 30
                                        mem[_6497 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6532 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6532 + 68] = mem[idx + _6497 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6532 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6532 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7310 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7310] = 26
                                        mem[_7310 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7716] = 26
                                        mem[_7716 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                        revert with 0, 17
                                    if not cd[36] / 100 * _liquidityFee:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                        revert with 0, 17
                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6221 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6221] = 26
                                    mem[_6221 + 32] = 'SafeMath: division by zero'
                                    _6360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6360] = 26
                                    mem[_6360 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6496 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6496] = 30
                                        mem[_6496 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6531 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6531 + 68] = mem[idx + _6496 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6531 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6531 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7309 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7309] = 26
                                        mem[_7309 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7715] = 26
                                        mem[_7715 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6640] = 30
                                        mem[_6640 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6710 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6710 + 68] = mem[idx + _6640 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6710 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6710 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7443] = 26
                                        mem[_7443 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7958 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7958] = 26
                                        mem[_7958 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5920 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5920] = 26
                                mem[_5920 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6137 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6137] = 26
                                    mem[_6137 + 32] = 'SafeMath: division by zero'
                                    _6301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6301] = 26
                                    mem[_6301 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6412 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6412] = 30
                                        mem[_6412 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6423 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6423 + 68] = mem[idx + _6412 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6423 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6423 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7117 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7117] = 26
                                        mem[_7117 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7556] = 26
                                        mem[_7556 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6495] = 30
                                        mem[_6495 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6529 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6529 + 68] = mem[idx + _6495 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6529 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6529 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7308 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7308] = 26
                                        mem[_7308 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7714] = 26
                                        mem[_7714 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6220 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6220] = 26
                                        mem[_6220 + 32] = 'SafeMath: division by zero'
                                        _6359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6359] = 26
                                        mem[_6359 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6494 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6494] = 30
                                            mem[_6494 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6528 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6528 + 68] = mem[idx + _6494 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6528 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6528 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7307 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7307] = 26
                                            mem[_7307 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7713 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7713] = 26
                                            mem[_7713 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6638 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6638] = 30
                                            mem[_6638 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6707 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6707 + 68] = mem[idx + _6638 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6707 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6707 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7442 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7442] = 26
                                            mem[_7442 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7957 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7957] = 26
                                            mem[_7957 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6300] = 26
                                        mem[_6300 + 32] = 'SafeMath: division by zero'
                                        _6405 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6405] = 26
                                        mem[_6405 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6637] = 30
                                            mem[_6637 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6706 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6706 + 68] = mem[idx + _6637 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6706 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6706 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7441 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7441] = 26
                                            mem[_7441 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7956 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7956] = 26
                                            mem[_7956 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6838 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6838] = 30
                                            mem[_6838 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6937 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6937 + 68] = mem[idx + _6838 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6937 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6937 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7555 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7555] = 26
                                            mem[_7555 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8278 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8278] = 26
                                            mem[_8278 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5974 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5974] = 26
                                mem[_5974 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6219 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6219] = 26
                                    mem[_6219 + 32] = 'SafeMath: division by zero'
                                    _6358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6358] = 26
                                    mem[_6358 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6493 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6493] = 30
                                        mem[_6493 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6527 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6527 + 68] = mem[idx + _6493 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6527 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6527 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7305 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7305] = 26
                                        mem[_7305 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7712] = 26
                                        mem[_7712 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6636] = 30
                                        mem[_6636 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6704 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6704 + 68] = mem[idx + _6636 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6704 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6704 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7440] = 26
                                        mem[_7440 + 32] = 'SafeMath: division by zero'
                                        if stor2[address(_5626)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_5626)] < stor2[address(_5626)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_5626)
                                        mem[32] = 2
                                        _7955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7955] = 26
                                        mem[_7955 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6299] = 26
                                        mem[_6299 + 32] = 'SafeMath: division by zero'
                                        _6404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6404] = 26
                                        mem[_6404 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6635 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6635] = 30
                                            mem[_6635 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6703 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6703 + 68] = mem[idx + _6635 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6703 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6703 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7439 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7439] = 26
                                            mem[_7439 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7954] = 26
                                            mem[_7954 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6836 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6836] = 30
                                            mem[_6836 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6934 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6934 + 68] = mem[idx + _6836 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6934 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6934 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7554 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7554] = 26
                                            mem[_7554 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8277 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8277] = 26
                                            mem[_8277 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6357] = 26
                                        mem[_6357 + 32] = 'SafeMath: division by zero'
                                        _6475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6475] = 26
                                        mem[_6475 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6835 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6835] = 30
                                            mem[_6835 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6933 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6933 + 68] = mem[idx + _6835 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6933 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6933 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7553 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7553] = 26
                                            mem[_7553 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8276 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8276] = 26
                                            mem[_8276 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7055 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7055] = 30
                                            mem[_7055 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _7161 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7161 + 68] = mem[idx + _7055 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7161 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7161 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7711 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7711] = 26
                                            mem[_7711 + 32] = 'SafeMath: division by zero'
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _8634 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8634] = 26
                                            mem[_8634 + 32] = 'SafeMath: division by zero'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _5734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5734] = 30
                        mem[_5734 + 32] = 'SafeMath: subtraction overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            _5757 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5757 + 68] = mem[idx + _5734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5757 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5757 + -mem[64] + 100
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        _5802 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5802] = 26
                        mem[_5802 + 32] = 'SafeMath: division by zero'
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = sub_c41d28c5Address
                            mem[32] = 2
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                            _5919 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5919] = 26
                            mem[_5919 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = uniswapV2PairAddress
                                mem[32] = 2
                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                _6136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6136] = 26
                                mem[_6136 + 32] = 'SafeMath: division by zero'
                                if not cd[36] * stor6 / totalSupply / 100:
                                    _6298 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6298] = 26
                                    mem[_6298 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6411] = 30
                                        mem[_6411 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6422 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6422 + 68] = mem[idx + _6411 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6422 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6422 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7109 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7109] = 26
                                        mem[_7109 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7552 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7552] = 26
                                            mem[_7552 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7710 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7710] = 26
                                            mem[_7710 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6492] = 30
                                        mem[_6492 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _6525 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6525 + 68] = mem[idx + _6492 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6525 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6525 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7301] = 26
                                        mem[_7301 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7709 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7709] = 26
                                            mem[_7709 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7953 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7953] = 26
                                            mem[_7953 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 17
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6356] = 26
                                    mem[_6356 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        _6491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6491] = 30
                                        mem[_6491 + 32] = 'SafeMath: subtraction overflow'
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                            _6524 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6524 + 68] = mem[idx + _6491 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6524 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6524 + -mem[64] + 100
                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                            revert with 0, 17
                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7300] = 26
                                        mem[_7300 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7708 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7708] = 26
                                            mem[_7708 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _7952 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7952] = 26
                                            mem[_7952 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6633] = 30
                                        mem[_6633 + 32] = 'SafeMath: subtraction overflow'
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                            _6700 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6700 + 68] = mem[idx + _6633 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6700 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6700 + -mem[64] + 100
                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                            revert with 0, 17
                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                            revert with 0, 17
                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += cd[36] / 100 * _taxFee
                                        if _taxFee > !_liquidityFee:
                                            revert with 0, 17
                                        if _taxFee + _liquidityFee > !_destroyFee:
                                            revert with 0, 17
                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                            revert with 0, 17
                                        _7437 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7437] = 26
                                        mem[_7437 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            if stor2[address(_5626)] > -1:
                                                revert with 0, 17
                                            if stor2[address(_5626)] < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            _7951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7951] = 26
                                            mem[_7951 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                revert with 0, 17
                                            if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = address(_5626)
                                            mem[32] = 2
                                            stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                            _8275 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8275] = 26
                                            mem[_8275 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not cd[36] / 100 * _liquidityFee:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6218] = 26
                                    mem[_6218 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6355] = 26
                                        mem[_6355 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6490 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6490] = 30
                                            mem[_6490 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6523 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6523 + 68] = mem[idx + _6490 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6523 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6523 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7299 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7299] = 26
                                            mem[_7299 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7707 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7707] = 26
                                                mem[_7707 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _7950 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7950] = 26
                                                mem[_7950 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6632 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6632] = 30
                                            mem[_6632 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6698 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6698 + 68] = mem[idx + _6632 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6698 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6698 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7436] = 26
                                            mem[_7436 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7949 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7949] = 26
                                                mem[_7949 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8274 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8274] = 26
                                                mem[_8274 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6403] = 26
                                        mem[_6403 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6631 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6631] = 30
                                            mem[_6631 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6697 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6697 + 68] = mem[idx + _6631 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6697 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6697 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7435 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7435] = 26
                                            mem[_7435 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7948 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7948] = 26
                                                mem[_7948 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8273 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8273] = 26
                                                mem[_8273 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6831 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6831] = 30
                                            mem[_6831 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6929 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6929 + 68] = mem[idx + _6831 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6929 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6929 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7551 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7551] = 26
                                            mem[_7551 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8272 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8272] = 26
                                                mem[_8272 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8633 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8633] = 26
                                                mem[_8633 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                        revert with 0, 17
                                    if not cd[36] / 100 * _liquidityFee:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                        revert with 0, 17
                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                    _6297 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6297] = 26
                                    mem[_6297 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6402 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6402] = 26
                                        mem[_6402 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6630 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6630] = 30
                                            mem[_6630 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6696 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6696 + 68] = mem[idx + _6630 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6696 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6696 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7434 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7434] = 26
                                            mem[_7434 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7947 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7947] = 26
                                                mem[_7947 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8271 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8271] = 26
                                                mem[_8271 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6830 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6830] = 30
                                            mem[_6830 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6927 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6927 + 68] = mem[idx + _6830 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6927 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6927 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7550 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7550] = 26
                                            mem[_7550 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8270 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8270] = 26
                                                mem[_8270 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8632 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8632] = 26
                                                mem[_8632 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6473 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6473] = 26
                                        mem[_6473 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6829] = 30
                                            mem[_6829 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6926 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6926 + 68] = mem[idx + _6829 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6926 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6926 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7549 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7549] = 26
                                            mem[_7549 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8269 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8269] = 26
                                                mem[_8269 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8631 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8631] = 26
                                                mem[_8631 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7050 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7050] = 30
                                            mem[_7050 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _7157 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7157 + 68] = mem[idx + _7050 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7157 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7157 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7706 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7706] = 26
                                            mem[_7706 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8630 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8630] = 26
                                                mem[_8630 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8976 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8976] = 26
                                                mem[_8976 + 32] = 'SafeMath: division by zero'
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _5973 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5973] = 26
                                mem[_5973 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6217] = 26
                                    mem[_6217 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6354] = 26
                                        mem[_6354 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6489 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6489] = 30
                                            mem[_6489 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6522 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6522 + 68] = mem[idx + _6489 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6522 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6522 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7294 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7294] = 26
                                            mem[_7294 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7705 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7705] = 26
                                                mem[_7705 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _7946 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7946] = 26
                                                mem[_7946 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6629 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6629] = 30
                                            mem[_6629 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6694 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6694 + 68] = mem[idx + _6629 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6694 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6694 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7432 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7432] = 26
                                            mem[_7432 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7945 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7945] = 26
                                                mem[_7945 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8268 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8268] = 26
                                                mem[_8268 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6401] = 26
                                        mem[_6401 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6628 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6628] = 30
                                            mem[_6628 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6693 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6693 + 68] = mem[idx + _6628 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6693 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6693 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7431 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7431] = 26
                                            mem[_7431 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7944 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7944] = 26
                                                mem[_7944 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8267 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8267] = 26
                                                mem[_8267 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6827 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6827] = 30
                                            mem[_6827 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6923 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6923 + 68] = mem[idx + _6827 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6923 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6923 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7548 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7548] = 26
                                            mem[_7548 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8266 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8266] = 26
                                                mem[_8266 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8629 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8629] = 26
                                                mem[_8629 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6296] = 26
                                        mem[_6296 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6400 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6400] = 26
                                            mem[_6400 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6627 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6627] = 30
                                                mem[_6627 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6692 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6692 + 68] = mem[idx + _6627 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6692 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6692 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7430 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7430] = 26
                                                mem[_7430 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _7943 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7943] = 26
                                                    mem[_7943 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8265 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8265] = 26
                                                    mem[_8265 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6826 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6826] = 30
                                                mem[_6826 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6921 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6921 + 68] = mem[idx + _6826 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6921 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6921 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7547 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7547] = 26
                                                mem[_7547 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8264 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8264] = 26
                                                    mem[_8264 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8628 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8628] = 26
                                                    mem[_8628 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6472 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6472] = 26
                                            mem[_6472 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6825 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6825] = 30
                                                mem[_6825 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _6920 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6920 + 68] = mem[idx + _6825 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6920 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6920 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7546 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7546] = 26
                                                mem[_7546 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8263 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8263] = 26
                                                    mem[_8263 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8627 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8627] = 26
                                                    mem[_8627 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7046 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7046] = 30
                                                mem[_7046 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7153 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7153 + 68] = mem[idx + _7046 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7153 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7153 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7704 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7704] = 26
                                                mem[_7704 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8626 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8626] = 26
                                                    mem[_8626 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8975 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8975] = 26
                                                    mem[_8975 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6353] = 26
                                        mem[_6353 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6471 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6471] = 26
                                            mem[_6471 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6824 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6824] = 30
                                                mem[_6824 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6919 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6919 + 68] = mem[idx + _6824 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6919 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6919 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7545 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7545] = 26
                                                mem[_7545 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8262 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8262] = 26
                                                    mem[_8262 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8625 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8625] = 26
                                                    mem[_8625 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7045 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7045] = 30
                                                mem[_7045 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7151 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7151 + 68] = mem[idx + _7045 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7151 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7151 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7703 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7703] = 26
                                                mem[_7703 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8624 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8624] = 26
                                                    mem[_8624 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8974 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8974] = 26
                                                    mem[_8974 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6599] = 26
                                            mem[_6599 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7044 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7044] = 30
                                                mem[_7044 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7150 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7150 + 68] = mem[idx + _7044 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7150 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7150 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7702 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7702] = 26
                                                mem[_7702 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8623 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8623] = 26
                                                    mem[_8623 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8973 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8973] = 26
                                                    mem[_8973 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7237 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7237] = 30
                                                mem[_7237 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7331 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7331 + 68] = mem[idx + _7237 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7331 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7331 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7942 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7942] = 26
                                                mem[_7942 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8972 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8972] = 26
                                                    mem[_8972 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9653 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9653] = 26
                                                    mem[_9653 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = sub_c41d28c5Address
                                mem[32] = 2
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                _6016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6016] = 26
                                mem[_6016 + 32] = 'SafeMath: division by zero'
                                if not cd[36] / 100:
                                    if stor2[stor15] > -1:
                                        revert with 0, 17
                                    if stor2[stor15] < stor2[stor15]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = uniswapV2PairAddress
                                    mem[32] = 2
                                    emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                    _6295 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6295] = 26
                                    mem[_6295 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        _6399 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6399] = 26
                                        mem[_6399 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6626 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6626] = 30
                                            mem[_6626 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6691 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6691 + 68] = mem[idx + _6626 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6691 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6691 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7425 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7425] = 26
                                            mem[_7425 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _7941 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7941] = 26
                                                mem[_7941 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8261 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8261] = 26
                                                mem[_8261 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6823 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6823] = 30
                                            mem[_6823 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _6917 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6917 + 68] = mem[idx + _6823 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6917 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6917 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7543 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7543] = 26
                                            mem[_7543 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8260 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8260] = 26
                                                mem[_8260 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8622 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8622] = 26
                                                mem[_8622 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6470 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6470] = 26
                                        mem[_6470 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            _6822 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6822] = 30
                                            mem[_6822 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _6916 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _6916 + 68] = mem[idx + _6822 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6916 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6916 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7542 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7542] = 26
                                            mem[_7542 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8259 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8259] = 26
                                                mem[_8259 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8621 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8621] = 26
                                                mem[_8621 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _7042 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7042] = 30
                                            mem[_7042 + 32] = 'SafeMath: subtraction overflow'
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                _7147 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _7147 + 68] = mem[idx + _7042 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7147 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7147 + -mem[64] + 100
                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                revert with 0, 17
                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                revert with 0, 17
                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += cd[36] / 100 * _taxFee
                                            if _taxFee > !_liquidityFee:
                                                revert with 0, 17
                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                revert with 0, 17
                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                revert with 0, 17
                                            _7701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7701] = 26
                                            mem[_7701 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                if stor2[address(_5626)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_5626)] < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                _8620 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8620] = 26
                                                mem[_8620 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                    revert with 0, 17
                                                if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_5626)
                                                mem[32] = 2
                                                stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                _8971 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8971] = 26
                                                mem[_8971 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                        revert with 0, 17
                                    if not cd[36] / 100:
                                        revert with 0, 18
                                    if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not cd[36] / 100 * _liquidityFee:
                                        if stor2[stor15] > -1:
                                            revert with 0, 17
                                        if stor2[stor15] < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6352 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6352] = 26
                                        mem[_6352 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6469 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6469] = 26
                                            mem[_6469 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _6821 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6821] = 30
                                                mem[_6821 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _6915 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _6915 + 68] = mem[idx + _6821 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6915 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6915 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7541 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7541] = 26
                                                mem[_7541 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8258 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8258] = 26
                                                    mem[_8258 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8619 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8619] = 26
                                                    mem[_8619 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7041 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7041] = 30
                                                mem[_7041 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7145 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7145 + 68] = mem[idx + _7041 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7145 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7145 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7700 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7700] = 26
                                                mem[_7700 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8618 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8618] = 26
                                                    mem[_8618 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8970 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8970] = 26
                                                    mem[_8970 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6598 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6598] = 26
                                            mem[_6598 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7040 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7040] = 30
                                                mem[_7040 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7144 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7144 + 68] = mem[idx + _7040 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7144 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7144 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7699 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7699] = 26
                                                mem[_7699 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8617 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8617] = 26
                                                    mem[_8617 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8969 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8969] = 26
                                                    mem[_8969 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7233 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7233] = 30
                                                mem[_7233 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7327 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7327 + 68] = mem[idx + _7233 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7327 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7327 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7940 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7940] = 26
                                                mem[_7940 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8968 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8968] = 26
                                                    mem[_8968 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9652 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9652] = 26
                                                    mem[_9652 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                            revert with 0, 17
                                        if not cd[36] / 100 * _liquidityFee:
                                            revert with 0, 18
                                        if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                            revert with 0, 17
                                        if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 2
                                        stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                        emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                        _6398 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6398] = 26
                                        mem[_6398 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            _6597 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6597] = 26
                                            mem[_6597 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7039 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7039] = 30
                                                mem[_7039 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7143 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7143 + 68] = mem[idx + _7039 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7143 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7143 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7698 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7698] = 26
                                                mem[_7698 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8616 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8616] = 26
                                                    mem[_8616 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _8967 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8967] = 26
                                                    mem[_8967 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7232 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7232] = 30
                                                mem[_7232 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _7325 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7325 + 68] = mem[idx + _7232 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7325 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7325 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7939 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7939] = 26
                                                mem[_7939 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8966 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8966] = 26
                                                    mem[_8966 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9651 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9651] = 26
                                                    mem[_9651 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 17
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                revert with 0, 18
                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6785 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6785] = 26
                                            mem[_6785 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _7231 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7231] = 30
                                                mem[_7231 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7324 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7324 + 68] = mem[idx + _7231 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7324 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7324 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _7938 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7938] = 26
                                                mem[_7938 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _8965 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8965] = 26
                                                    mem[_8965 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9650 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9650] = 26
                                                    mem[_9650 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _7375 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_7375] = 30
                                                mem[_7375 + 32] = 'SafeMath: subtraction overflow'
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                    _7450 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _7450 + 68] = mem[idx + _7375 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7450 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7450 + -mem[64] + 100
                                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                    revert with 0, 17
                                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _8257 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8257] = 26
                                                mem[_8257 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    if stor2[address(_5626)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    _9649 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9649] = 26
                                                    mem[_9649 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[address(_5626)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                        revert with 0, 17
                                                    if stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_5626)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_5626)
                                                    mem[32] = 2
                                                    stor2[address(_5626)] = stor2[address(_5626)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                    _9861 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9861] = 26
                                                    mem[_9861 + 32] = 'SafeMath: division by zero'
                if not cd[36] / 100:
                    mem[mem[64]] = 0
                    emit Transfer(0, msg.sender, address(_5626));
                else:
                    if cd[36] / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] / 100:
                        revert with 0, 17
                    if not cd[36] / 100:
                        revert with 0, 18
                    if (100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100) / cd[36] / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = (100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100)
                    emit Transfer(((100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100)), msg.sender, address(_5626));
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
    if unknown_0x49bd5a5e(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0xa457c2d7(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x70a08231(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return uniswapV2PairAddress
                if uint32(call.func_hash) >> 224 != unknown_0x5342acb4(?????):
                    require unknown_0x6bc87c3a(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    return _liquidityFee
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                return bool(stor4[address(cd[4])])
            if unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not stor6 / totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                return (stor2[address(cd[4])] / stor6 / totalSupply)
            if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return _owner
            if uint32(call.func_hash) >> 224 != unknown_0x95d89b41(?????):
                require unknown_0x964e45f5(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                return _destroyFee
            require not msg.value
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor9.length):
                        if 31 < uint255(stor9.length) * 0.5:
                            mem[160] = uint256(stor9.field_0)
                            idx = 160
                            s = 0
                            while (uint255(stor9.length) * 0.5) + 128 > idx:
                                mem[idx + 32] = stor9[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor9.length), data=mem[160 len ceil32(uint255(stor9.length) * 0.5)])
                        mem[160] = 256 * stor9.length.field_8
                else:
                    if bool(stor9.length) == stor9.length.field_1 < 32:
                        revert with 0, 34
                    if stor9.length.field_1:
                        if 31 < stor9.length.field_1:
                            mem[160] = uint256(stor9.field_0)
                            idx = 160
                            s = 0
                            while stor9.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor9[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor9.length), data=mem[160 len ceil32(uint255(stor9.length) * 0.5)])
                        mem[160] = 256 * stor9.length.field_8
                mem[ceil32(uint255(stor9.length) * 0.5) + 224 len ceil32(uint255(stor9.length) * 0.5)] = mem[160 len ceil32(uint255(stor9.length) * 0.5)]
                if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
                    mem[ceil32(uint255(stor9.length) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                return Array(len=2 * Mask(256, -1, stor9.length), data=mem[160 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 0, 34
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor9.length):
                    if 31 < uint255(stor9.length) * 0.5:
                        mem[160] = uint256(stor9.field_0)
                        idx = 160
                        s = 0
                        while (uint255(stor9.length) * 0.5) + 128 > idx:
                            mem[idx + 32] = stor9[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor9.length % 128, data=mem[160 len ceil32(stor9.length.field_1)])
                    mem[160] = 256 * stor9.length.field_8
            else:
                if bool(stor9.length) == stor9.length.field_1 < 32:
                    revert with 0, 34
                if stor9.length.field_1:
                    if 31 < stor9.length.field_1:
                        mem[160] = uint256(stor9.field_0)
                        idx = 160
                        s = 0
                        while stor9.length.field_1 + 128 > idx:
                            mem[idx + 32] = stor9[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor9.length % 128, data=mem[160 len ceil32(stor9.length.field_1)])
                    mem[160] = 256 * stor9.length.field_8
            mem[ceil32(stor9.length.field_1) + 224 len ceil32(stor9.length.field_1)] = mem[160 len ceil32(stor9.length.field_1)]
            if ceil32(stor9.length.field_1) > stor9.length.field_1:
                mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 224] = 0
            return Array(len=stor9.length % 128, data=mem[160 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 224 len 2 * ceil32(stor9.length.field_1)]), 
        if unknown_0xc41d28c5(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xc41d28c5(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_c41d28c5Address
            if uint32(call.func_hash) >> 224 != unknown_0xd30b2036(?????):
                if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == address(cd[36])
                    return allowance[address(cd[4])][address(cd[36])]
                require unknown_0xea2f0b37(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                stor4[address(cd[4])] = 0
            else:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] <= test266151307()
                require cd[4] + 35 < calldata.size
                if ('cd', 4).length > test266151307():
                    revert with 0, 65
                if ceil32(32 * ('cd', 4).length) + 129 > test266151307() or ceil32(32 * ('cd', 4).length) + 129 < 128:
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + 129
                mem[128] = ('cd', 4).length
                require (32 * ('cd', 4).length) + cd[4] + 36 <= calldata.size
                s = 160
                idx = cd[4] + 36
                while idx < (32 * ('cd', 4).length) + cd[4] + 36:
                    require cd[idx] == address(cd[idx])
                    mem[s] = cd[idx]
                    s = s + 32
                    idx = idx + 32
                    continue 
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[128]:
                        revert with 0, 50
                    _22676 = mem[(32 * idx) + 160]
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not mem[(32 * idx) + 172 len 20]:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if cd[36] <= 0:
                        revert with 0, 'Transfer amount must be greater than zero'
                    mem[0] = msg.sender
                    mem[32] = 4
                    if stor4[address(msg.sender)]:
                        _23417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23417] = 26
                        mem[_23417 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _23420 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _23420 + 68] = mem[idx + _23417 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23420 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _23420 + -mem[64] + 100
                        if stor6 >= stor6 / totalSupply:
                            _23435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23435] = 26
                            mem[_23435 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _23441 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _23441 + 68] = mem[idx + _23435 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23441 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _23441 + -mem[64] + 100
                            if not cd[36]:
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23475] = 30
                                mem[_23475 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor2[address(msg.sender)]:
                                    _23483 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23483 + 68] = mem[idx + _23475 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23483 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23483 + -mem[64] + 100
                                if stor2[address(msg.sender)] < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23561 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23561] = 26
                                mem[_23561 + 32] = 'SafeMath: division by zero'
                                if stor2[address(_22676)] > -1:
                                    revert with 0, 17
                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = address(_22676)
                                mem[32] = 2
                                _23611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23611] = 26
                                mem[_23611 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                    revert with 0, 17
                                if not cd[36]:
                                    revert with 0, 18
                                if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23513 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23513] = 30
                                mem[_23513 + 32] = 'SafeMath: subtraction overflow'
                                if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                    _23533 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23533 + 68] = mem[idx + _23513 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23533 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23533 + -mem[64] + 100
                                if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 2
                                stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                _23587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23587] = 26
                                mem[_23587 + 32] = 'SafeMath: division by zero'
                                if not cd[36] * stor6 / totalSupply / 100:
                                    if stor2[address(_22676)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    _23657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23657] = 26
                                    mem[_23657 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 17
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 18
                                    if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[address(_22676)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                        revert with 0, 17
                                    if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    stor2[address(_22676)] += 100 * cd[36] * stor6 / totalSupply / 100
                                    _23713 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23713] = 26
                                    mem[_23713 + 32] = 'SafeMath: division by zero'
                        else:
                            _23436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23436] = 26
                            mem[_23436 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _23442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _23442 + 68] = mem[idx + _23436 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23442 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _23442 + -mem[64] + 100
                            if not cd[36]:
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23476 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23476] = 30
                                mem[_23476 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor2[address(msg.sender)]:
                                    _23484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23484 + 68] = mem[idx + _23476 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23484 + -mem[64] + 100
                                if stor2[address(msg.sender)] < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23562] = 26
                                mem[_23562 + 32] = 'SafeMath: division by zero'
                                if stor2[address(_22676)] > -1:
                                    revert with 0, 17
                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = address(_22676)
                                mem[32] = 2
                                _23612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23612] = 26
                                mem[_23612 + 32] = 'SafeMath: division by zero'
                            else:
                                if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                    revert with 0, 17
                                if not cd[36]:
                                    revert with 0, 18
                                if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _23514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23514] = 30
                                mem[_23514 + 32] = 'SafeMath: subtraction overflow'
                                if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                    _23535 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23535 + 68] = mem[idx + _23514 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23535 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23535 + -mem[64] + 100
                                if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 2
                                stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                _23588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23588] = 26
                                mem[_23588 + 32] = 'SafeMath: division by zero'
                                if not cd[36] * stor6 / totalSupply / 100:
                                    if stor2[address(_22676)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    _23658 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23658] = 26
                                    mem[_23658 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 17
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        revert with 0, 18
                                    if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor2[address(_22676)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                        revert with 0, 17
                                    if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    stor2[address(_22676)] += 100 * cd[36] * stor6 / totalSupply / 100
                                    _23714 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23714] = 26
                                    mem[_23714 + 32] = 'SafeMath: division by zero'
                        if not cd[36] / 100:
                            mem[mem[64]] = 0
                            emit Transfer(0, msg.sender, address(_22676));
                        else:
                            if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = 100 * cd[36] / 100
                            emit Transfer((100 * cd[36] / 100), msg.sender, address(_22676));
                    else:
                        mem[0] = mem[(32 * idx) + 172 len 20]
                        mem[32] = 4
                        if stor4[address(mem[(32 * idx) + 160])]:
                            _23419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23419] = 26
                            mem[_23419 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _23424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _23424 + 68] = mem[idx + _23419 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23424 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _23424 + -mem[64] + 100
                            if stor6 >= stor6 / totalSupply:
                                _23439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23439] = 26
                                mem[_23439 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _23449 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _23449 + 68] = mem[idx + _23439 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23449 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23449 + -mem[64] + 100
                                if not cd[36]:
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23481 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23481] = 30
                                    mem[_23481 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor2[address(msg.sender)]:
                                        _23491 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23491 + 68] = mem[idx + _23481 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23491 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23491 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23573 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23573] = 26
                                    mem[_23573 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_22676)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    _23633 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23633] = 26
                                    mem[_23633 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23531 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23531] = 30
                                    mem[_23531 + 32] = 'SafeMath: subtraction overflow'
                                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                        _23551 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23551 + 68] = mem[idx + _23531 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23551 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23551 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                    _23589 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23589] = 26
                                    mem[_23589 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        if stor2[address(_22676)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_22676)
                                        mem[32] = 2
                                        _23691 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23691] = 26
                                        mem[_23691 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[address(_22676)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                            revert with 0, 17
                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_22676)
                                        mem[32] = 2
                                        stor2[address(_22676)] += 100 * cd[36] * stor6 / totalSupply / 100
                                        _23745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23745] = 26
                                        mem[_23745 + 32] = 'SafeMath: division by zero'
                            else:
                                _23440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23440] = 26
                                mem[_23440 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _23450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _23450 + 68] = mem[idx + _23440 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23450 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23450 + -mem[64] + 100
                                if not cd[36]:
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23482 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23482] = 30
                                    mem[_23482 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor2[address(msg.sender)]:
                                        _23492 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23492 + 68] = mem[idx + _23482 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23492 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23492 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23574 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23574] = 26
                                    mem[_23574 + 32] = 'SafeMath: division by zero'
                                    if stor2[address(_22676)] > -1:
                                        revert with 0, 17
                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = address(_22676)
                                    mem[32] = 2
                                    _23634 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23634] = 26
                                    mem[_23634 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23532] = 30
                                    mem[_23532 + 32] = 'SafeMath: subtraction overflow'
                                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                        _23553 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23553 + 68] = mem[idx + _23532 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23553 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23553 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                    _23590 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23590] = 26
                                    mem[_23590 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] * stor6 / totalSupply / 100:
                                        if stor2[address(_22676)] > -1:
                                            revert with 0, 17
                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_22676)
                                        mem[32] = 2
                                        _23692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23692] = 26
                                        mem[_23692 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 17
                                        if not cd[36] * stor6 / totalSupply / 100:
                                            revert with 0, 18
                                        if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor2[address(_22676)] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                            revert with 0, 17
                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = address(_22676)
                                        mem[32] = 2
                                        stor2[address(_22676)] += 100 * cd[36] * stor6 / totalSupply / 100
                                        _23746 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23746] = 26
                                        mem[_23746 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                mem[mem[64]] = 0
                                emit Transfer(0, msg.sender, address(_22676));
                            else:
                                if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = 100 * cd[36] / 100
                                emit Transfer((100 * cd[36] / 100), msg.sender, address(_22676));
                        else:
                            _23418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23418] = 26
                            mem[_23418 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _23421 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _23421 + 68] = mem[idx + _23418 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23421 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _23421 + -mem[64] + 100
                            if stor6 >= stor6 / totalSupply:
                                _23437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23437] = 26
                                mem[_23437 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _23443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _23443 + 68] = mem[idx + _23437 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23443 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23443 + -mem[64] + 100
                                if not cd[36]:
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23477 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23477] = 30
                                    mem[_23477 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor2[address(msg.sender)]:
                                        _23485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23485 + 68] = mem[idx + _23477 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23485 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23485 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23548 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23548] = 26
                                    mem[_23548 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        if stor2[stor14] > -1:
                                            revert with 0, 17
                                        if stor2[stor14] < stor2[stor14]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_c41d28c5Address
                                        mem[32] = 2
                                        emit Transfer(0, msg.sender, sub_c41d28c5Address);
                                        _23643 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23643] = 26
                                        mem[_23643 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            if stor2[stor15] > -1:
                                                revert with 0, 17
                                            if stor2[stor15] < stor2[stor15]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 2
                                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                            _23853 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23853] = 26
                                            mem[_23853 + 32] = 'SafeMath: division by zero'
                                            _23998 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23998] = 26
                                            mem[_23998 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _24143 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24143] = 30
                                                mem[_24143 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _24150 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _24150 + 68] = mem[idx + _24143 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_24150 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _24150 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _24647 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24647] = 26
                                                mem[_24647 + 32] = 'SafeMath: division by zero'
                                                if stor2[address(_22676)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_22676)
                                                mem[32] = 2
                                                _25199 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25199] = 26
                                                mem[_25199 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _24192 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24192] = 30
                                                mem[_24192 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _24202 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _24202 + 68] = mem[idx + _24192 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_24202 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _24202 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _24872 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24872] = 26
                                                mem[_24872 + 32] = 'SafeMath: division by zero'
                                                if stor2[address(_22676)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_22676)
                                                mem[32] = 2
                                                _25318 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25318] = 26
                                                mem[_25318 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not cd[36] / 100 * _liquidityFee:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _23917 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23917] = 26
                                                mem[_23917 + 32] = 'SafeMath: division by zero'
                                                _24076 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24076] = 26
                                                mem[_24076 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24191 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24191] = 30
                                                    mem[_24191 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24201 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24201 + 68] = mem[idx + _24191 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24201 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24201 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24871 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24871] = 26
                                                    mem[_24871 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25317 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25317] = 26
                                                    mem[_25317 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24269 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24269] = 30
                                                    mem[_24269 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24301 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24301 + 68] = mem[idx + _24269 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24301 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24301 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25061 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25061] = 26
                                                    mem[_25061 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25478 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25478] = 26
                                                    mem[_25478 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 17
                                                if not cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                    revert with 0, 17
                                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _23997 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23997] = 26
                                                mem[_23997 + 32] = 'SafeMath: division by zero'
                                                _24133 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24133] = 26
                                                mem[_24133 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24268 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24268] = 30
                                                    mem[_24268 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24300 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24300 + 68] = mem[idx + _24268 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24300 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24300 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25060 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25060] = 26
                                                    mem[_25060 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25477 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25477] = 26
                                                    mem[_25477 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24405 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24405] = 30
                                                    mem[_24405 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24470 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24470 + 68] = mem[idx + _24405 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24470 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24470 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25198 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25198] = 26
                                                    mem[_25198 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25719 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25719] = 26
                                                    mem[_25719 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not cd[36] / 100 * _destroyFee:
                                            if stor2[stor14] > -1:
                                                revert with 0, 17
                                            if stor2[stor14] < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23700] = 26
                                            mem[_23700 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _23916 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23916] = 26
                                                mem[_23916 + 32] = 'SafeMath: division by zero'
                                                _24075 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24075] = 26
                                                mem[_24075 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24190 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24190] = 30
                                                    mem[_24190 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24200 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24200 + 68] = mem[idx + _24190 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24200 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24200 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24869 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24869] = 26
                                                    mem[_24869 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25316 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25316] = 26
                                                    mem[_25316 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24267 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24267] = 30
                                                    mem[_24267 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24298 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24298 + 68] = mem[idx + _24267 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24298 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24298 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25059 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25059] = 26
                                                    mem[_25059 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25476 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25476] = 26
                                                    mem[_25476 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _23996 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_23996] = 26
                                                    mem[_23996 + 32] = 'SafeMath: division by zero'
                                                    _24132 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24132] = 26
                                                    mem[_24132 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24266 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24266] = 30
                                                        mem[_24266 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24297 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24297 + 68] = mem[idx + _24266 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24297 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24297 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25058 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25058] = 26
                                                        mem[_25058 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25475 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25475] = 26
                                                        mem[_25475 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24403 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24403] = 30
                                                        mem[_24403 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24467 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24467 + 68] = mem[idx + _24403 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24467 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24467 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25197 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25197] = 26
                                                        mem[_25197 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25718 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25718] = 26
                                                        mem[_25718 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24074 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24074] = 26
                                                    mem[_24074 + 32] = 'SafeMath: division by zero'
                                                    _24178 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24178] = 26
                                                    mem[_24178 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24402 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24402] = 30
                                                        mem[_24402 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24466 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24466 + 68] = mem[idx + _24402 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24466 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24466 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25196 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25196] = 26
                                                        mem[_25196 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25717 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25717] = 26
                                                        mem[_25717 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24598 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24598] = 30
                                                        mem[_24598 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24693 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24693 + 68] = mem[idx + _24598 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24693 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24693 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25315 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25315] = 26
                                                        mem[_25315 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26038 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26038] = 26
                                                        mem[_26038 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                                revert with 0, 17
                                            if not cd[36] / 100 * _destroyFee:
                                                revert with 0, 18
                                            if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                                revert with 0, 17
                                            if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23754 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23754] = 26
                                            mem[_23754 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _23995 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23995] = 26
                                                mem[_23995 + 32] = 'SafeMath: division by zero'
                                                _24131 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24131] = 26
                                                mem[_24131 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24265 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24265] = 30
                                                    mem[_24265 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24296 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24296 + 68] = mem[idx + _24265 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24296 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24296 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25056 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25056] = 26
                                                    mem[_25056 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25474 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25474] = 26
                                                    mem[_25474 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24401 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24401] = 30
                                                    mem[_24401 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24464 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24464 + 68] = mem[idx + _24401 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24464 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24464 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25195 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25195] = 26
                                                    mem[_25195 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25716 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25716] = 26
                                                    mem[_25716 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24073 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24073] = 26
                                                    mem[_24073 + 32] = 'SafeMath: division by zero'
                                                    _24177 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24177] = 26
                                                    mem[_24177 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24400 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24400] = 30
                                                        mem[_24400 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24463 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24463 + 68] = mem[idx + _24400 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24463 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24463 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25194 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25194] = 26
                                                        mem[_25194 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25715 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25715] = 26
                                                        mem[_25715 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24596 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24596] = 30
                                                        mem[_24596 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24690 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24690 + 68] = mem[idx + _24596 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24690 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24690 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25314 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25314] = 26
                                                        mem[_25314 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26037 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26037] = 26
                                                        mem[_26037 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24130 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24130] = 26
                                                    mem[_24130 + 32] = 'SafeMath: division by zero'
                                                    _24247 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24247] = 26
                                                    mem[_24247 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24595 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24595] = 30
                                                        mem[_24595 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24689 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24689 + 68] = mem[idx + _24595 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24689 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24689 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25313 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25313] = 26
                                                        mem[_25313 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26036 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26036] = 26
                                                        mem[_26036 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24815 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24815] = 30
                                                        mem[_24815 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24921 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24921 + 68] = mem[idx + _24815 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24921 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24921 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25473 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25473] = 26
                                                        mem[_25473 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26397 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26397] = 26
                                                        mem[_26397 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23515] = 30
                                    mem[_23515 + 32] = 'SafeMath: subtraction overflow'
                                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                        _23537 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23537 + 68] = mem[idx + _23515 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23537 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23537 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                    _23583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23583] = 26
                                    mem[_23583 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        if stor2[stor14] > -1:
                                            revert with 0, 17
                                        if stor2[stor14] < stor2[stor14]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_c41d28c5Address
                                        mem[32] = 2
                                        emit Transfer(0, msg.sender, sub_c41d28c5Address);
                                        _23699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23699] = 26
                                        mem[_23699 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            if stor2[stor15] > -1:
                                                revert with 0, 17
                                            if stor2[stor15] < stor2[stor15]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 2
                                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                            _23915 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23915] = 26
                                            mem[_23915 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                _24072 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24072] = 26
                                                mem[_24072 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24189 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24189] = 30
                                                    mem[_24189 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24199 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24199 + 68] = mem[idx + _24189 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24199 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24199 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24861 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24861] = 26
                                                    mem[_24861 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25312 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25312] = 26
                                                        mem[_25312 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25472 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25472] = 26
                                                        mem[_25472 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24264 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24264] = 30
                                                    mem[_24264 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24294 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24294 + 68] = mem[idx + _24264 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24294 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24294 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25052 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25052] = 26
                                                    mem[_25052 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25471 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25471] = 26
                                                        mem[_25471 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25714 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25714] = 26
                                                        mem[_25714 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _24129 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24129] = 26
                                                mem[_24129 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24263 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24263] = 30
                                                    mem[_24263 + 32] = 'SafeMath: subtraction overflow'
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                        _24293 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24293 + 68] = mem[idx + _24263 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24293 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24293 + -mem[64] + 100
                                                    if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                        revert with 0, 17
                                                    stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25051 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25051] = 26
                                                    mem[_25051 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25470 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25470] = 26
                                                        mem[_25470 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25713 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25713] = 26
                                                        mem[_25713 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24398 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24398] = 30
                                                    mem[_24398 + 32] = 'SafeMath: subtraction overflow'
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                        _24460 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24460 + 68] = mem[idx + _24398 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24460 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24460 + -mem[64] + 100
                                                    if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                        revert with 0, 17
                                                    stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25192 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25192] = 26
                                                    mem[_25192 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25712 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25712] = 26
                                                        mem[_25712 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _26035 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26035] = 26
                                                        mem[_26035 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not cd[36] / 100 * _liquidityFee:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _23994 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23994] = 26
                                                mem[_23994 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24128 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24128] = 26
                                                    mem[_24128 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24262 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24262] = 30
                                                        mem[_24262 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24292 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24292 + 68] = mem[idx + _24262 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24292 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24292 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25050 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25050] = 26
                                                        mem[_25050 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25469 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25469] = 26
                                                            mem[_25469 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _25711 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25711] = 26
                                                            mem[_25711 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24397 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24397] = 30
                                                        mem[_24397 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24458 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24458 + 68] = mem[idx + _24397 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24458 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24458 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25191 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25191] = 26
                                                        mem[_25191 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25710 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25710] = 26
                                                            mem[_25710 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26034 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26034] = 26
                                                            mem[_26034 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24176 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24176] = 26
                                                    mem[_24176 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24396 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24396] = 30
                                                        mem[_24396 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24457 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24457 + 68] = mem[idx + _24396 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24457 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24457 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25190 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25190] = 26
                                                        mem[_25190 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25709 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25709] = 26
                                                            mem[_25709 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26033 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26033] = 26
                                                            mem[_26033 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24591 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24591] = 30
                                                        mem[_24591 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24685 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24685 + 68] = mem[idx + _24591 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24685 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24685 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25311 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25311] = 26
                                                        mem[_25311 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26032 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26032] = 26
                                                            mem[_26032 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26396 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26396] = 26
                                                            mem[_26396 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 17
                                                if not cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                    revert with 0, 17
                                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _24071 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24071] = 26
                                                mem[_24071 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24175 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24175] = 26
                                                    mem[_24175 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24395 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24395] = 30
                                                        mem[_24395 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24456 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24456 + 68] = mem[idx + _24395 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24456 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24456 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25189 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25189] = 26
                                                        mem[_25189 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25708 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25708] = 26
                                                            mem[_25708 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26031 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26031] = 26
                                                            mem[_26031 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24590 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24590] = 30
                                                        mem[_24590 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24683 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24683 + 68] = mem[idx + _24590 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24683 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24683 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25310 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25310] = 26
                                                        mem[_25310 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26030 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26030] = 26
                                                            mem[_26030 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26395 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26395] = 26
                                                            mem[_26395 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24245 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24245] = 26
                                                    mem[_24245 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24589 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24589] = 30
                                                        mem[_24589 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24682 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24682 + 68] = mem[idx + _24589 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24682 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24682 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25309 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25309] = 26
                                                        mem[_25309 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26029 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26029] = 26
                                                            mem[_26029 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26394 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26394] = 26
                                                            mem[_26394 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24810 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24810] = 30
                                                        mem[_24810 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24917 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24917 + 68] = mem[idx + _24810 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24917 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24917 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25468 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25468] = 26
                                                        mem[_25468 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26393 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26393] = 26
                                                            mem[_26393 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26746 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26746] = 26
                                                            mem[_26746 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not cd[36] / 100 * _destroyFee:
                                            if stor2[stor14] > -1:
                                                revert with 0, 17
                                            if stor2[stor14] < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23753 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23753] = 26
                                            mem[_23753 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _23993 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23993] = 26
                                                mem[_23993 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24127 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24127] = 26
                                                    mem[_24127 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24261 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24261] = 30
                                                        mem[_24261 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24291 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24291 + 68] = mem[idx + _24261 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24291 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24291 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25045 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25045] = 26
                                                        mem[_25045 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25467 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25467] = 26
                                                            mem[_25467 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _25707 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25707] = 26
                                                            mem[_25707 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24394 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24394] = 30
                                                        mem[_24394 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24454 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24454 + 68] = mem[idx + _24394 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24454 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24454 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25187 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25187] = 26
                                                        mem[_25187 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25706 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25706] = 26
                                                            mem[_25706 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26028 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26028] = 26
                                                            mem[_26028 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24174 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24174] = 26
                                                    mem[_24174 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24393 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24393] = 30
                                                        mem[_24393 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24453 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24453 + 68] = mem[idx + _24393 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24453 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24453 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25186 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25186] = 26
                                                        mem[_25186 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25705 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25705] = 26
                                                            mem[_25705 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26027 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26027] = 26
                                                            mem[_26027 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24587 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24587] = 30
                                                        mem[_24587 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24679 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24679 + 68] = mem[idx + _24587 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24679 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24679 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25308 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25308] = 26
                                                        mem[_25308 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26026 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26026] = 26
                                                            mem[_26026 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26392 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26392] = 26
                                                            mem[_26392 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24070 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24070] = 26
                                                    mem[_24070 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24173 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24173] = 26
                                                        mem[_24173 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24392 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24392] = 30
                                                            mem[_24392 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24452 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24452 + 68] = mem[idx + _24392 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24452 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24452 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25185 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25185] = 26
                                                            mem[_25185 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _25704 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_25704] = 26
                                                                mem[_25704 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26025 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26025] = 26
                                                                mem[_26025 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24586 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24586] = 30
                                                            mem[_24586 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24677 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24677 + 68] = mem[idx + _24586 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24677 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24677 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25307 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25307] = 26
                                                            mem[_25307 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26024 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26024] = 26
                                                                mem[_26024 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26391 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26391] = 26
                                                                mem[_26391 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24244 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24244] = 26
                                                        mem[_24244 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24585 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24585] = 30
                                                            mem[_24585 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24676 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24676 + 68] = mem[idx + _24585 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24676 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24676 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25306 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25306] = 26
                                                            mem[_25306 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26023 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26023] = 26
                                                                mem[_26023 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26390 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26390] = 26
                                                                mem[_26390 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24806 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24806] = 30
                                                            mem[_24806 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24913 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24913 + 68] = mem[idx + _24806 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24913 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24913 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25466 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25466] = 26
                                                            mem[_25466 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26389 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26389] = 26
                                                                mem[_26389 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26745 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26745] = 26
                                                                mem[_26745 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24126 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24126] = 26
                                                    mem[_24126 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24243 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24243] = 26
                                                        mem[_24243 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24584 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24584] = 30
                                                            mem[_24584 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24675 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24675 + 68] = mem[idx + _24584 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24675 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24675 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25305 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25305] = 26
                                                            mem[_25305 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26022 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26022] = 26
                                                                mem[_26022 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26388 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26388] = 26
                                                                mem[_26388 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24805 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24805] = 30
                                                            mem[_24805 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24911 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24911 + 68] = mem[idx + _24805 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24911 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24911 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25465 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25465] = 26
                                                            mem[_25465 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26387 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26387] = 26
                                                                mem[_26387 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26744 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26744] = 26
                                                                mem[_26744 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24369 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24369] = 26
                                                        mem[_24369 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24804 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24804] = 30
                                                            mem[_24804 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24910 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24910 + 68] = mem[idx + _24804 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24910 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24910 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25464 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25464] = 26
                                                            mem[_25464 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26386 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26386] = 26
                                                                mem[_26386 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26743 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26743] = 26
                                                                mem[_26743 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25001 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25001] = 30
                                                            mem[_25001 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25100 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25100 + 68] = mem[idx + _25001 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25100 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25100 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25703 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25703] = 26
                                                            mem[_25703 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26742 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26742] = 26
                                                                mem[_26742 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27430 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27430] = 26
                                                                mem[_27430 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                                revert with 0, 17
                                            if not cd[36] / 100 * _destroyFee:
                                                revert with 0, 18
                                            if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                                revert with 0, 17
                                            if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23797 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23797] = 26
                                            mem[_23797 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _24069 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24069] = 26
                                                mem[_24069 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24172 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24172] = 26
                                                    mem[_24172 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24391 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24391] = 30
                                                        mem[_24391 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24451 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24451 + 68] = mem[idx + _24391 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24451 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24451 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25180 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25180] = 26
                                                        mem[_25180 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25702 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25702] = 26
                                                            mem[_25702 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26021 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26021] = 26
                                                            mem[_26021 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24583 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24583] = 30
                                                        mem[_24583 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24673 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24673 + 68] = mem[idx + _24583 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24673 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24673 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25303 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25303] = 26
                                                        mem[_25303 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26020 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26020] = 26
                                                            mem[_26020 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26385 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26385] = 26
                                                            mem[_26385 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24242 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24242] = 26
                                                    mem[_24242 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24582 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24582] = 30
                                                        mem[_24582 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24672 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24672 + 68] = mem[idx + _24582 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24672 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24672 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25302 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25302] = 26
                                                        mem[_25302 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26019 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26019] = 26
                                                            mem[_26019 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26384 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26384] = 26
                                                            mem[_26384 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24802 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24802] = 30
                                                        mem[_24802 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24907 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24907 + 68] = mem[idx + _24802 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24907 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24907 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25463 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25463] = 26
                                                        mem[_25463 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26383 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26383] = 26
                                                            mem[_26383 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26741 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26741] = 26
                                                            mem[_26741 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24125 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24125] = 26
                                                    mem[_24125 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24241 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24241] = 26
                                                        mem[_24241 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24581 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24581] = 30
                                                            mem[_24581 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24671 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24671 + 68] = mem[idx + _24581 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24671 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24671 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25301 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25301] = 26
                                                            mem[_25301 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26018 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26018] = 26
                                                                mem[_26018 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26382 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26382] = 26
                                                                mem[_26382 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24801 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24801] = 30
                                                            mem[_24801 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24905 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24905 + 68] = mem[idx + _24801 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24905 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24905 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25462 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25462] = 26
                                                            mem[_25462 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26381 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26381] = 26
                                                                mem[_26381 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26740 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26740] = 26
                                                                mem[_26740 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24368 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24368] = 26
                                                        mem[_24368 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24800 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24800] = 30
                                                            mem[_24800 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24904 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24904 + 68] = mem[idx + _24800 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24904 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24904 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25461 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25461] = 26
                                                            mem[_25461 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26380 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26380] = 26
                                                                mem[_26380 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26739 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26739] = 26
                                                                mem[_26739 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24997 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24997] = 30
                                                            mem[_24997 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25096 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25096 + 68] = mem[idx + _24997 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25096 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25096 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25701 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25701] = 26
                                                            mem[_25701 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26738 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26738] = 26
                                                                mem[_26738 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27429 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27429] = 26
                                                                mem[_27429 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24171 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24171] = 26
                                                    mem[_24171 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24367 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24367] = 26
                                                        mem[_24367 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24799 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24799] = 30
                                                            mem[_24799 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24903 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24903 + 68] = mem[idx + _24799 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24903 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24903 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25460 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25460] = 26
                                                            mem[_25460 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26379 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26379] = 26
                                                                mem[_26379 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26737 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26737] = 26
                                                                mem[_26737 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24996 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24996] = 30
                                                            mem[_24996 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _25094 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25094 + 68] = mem[idx + _24996 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25094 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25094 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25700 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25700] = 26
                                                            mem[_25700 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26736 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26736] = 26
                                                                mem[_26736 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27428 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27428] = 26
                                                                mem[_27428 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24553 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24553] = 26
                                                        mem[_24553 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24995 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24995] = 30
                                                            mem[_24995 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25093 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25093 + 68] = mem[idx + _24995 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25093 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25093 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25699 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25699] = 26
                                                            mem[_25699 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26735 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26735] = 26
                                                                mem[_26735 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27427 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27427] = 26
                                                                mem[_27427 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25141 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25141] = 30
                                                            mem[_25141 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25227 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25227 + 68] = mem[idx + _25141 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25227 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25227 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _26017 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26017] = 26
                                                            mem[_26017 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _27426 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27426] = 26
                                                                mem[_27426 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27642 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27642] = 26
                                                                mem[_27642 + 32] = 'SafeMath: division by zero'
                            else:
                                _23438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23438] = 26
                                mem[_23438 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _23444 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _23444 + 68] = mem[idx + _23438 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23444 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23444 + -mem[64] + 100
                                if not cd[36]:
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23478 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23478] = 30
                                    mem[_23478 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor2[address(msg.sender)]:
                                        _23486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23486 + 68] = mem[idx + _23478 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23486 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23550] = 26
                                    mem[_23550 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        if stor2[stor14] > -1:
                                            revert with 0, 17
                                        if stor2[stor14] < stor2[stor14]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_c41d28c5Address
                                        mem[32] = 2
                                        emit Transfer(0, msg.sender, sub_c41d28c5Address);
                                        _23644 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23644] = 26
                                        mem[_23644 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            if stor2[stor15] > -1:
                                                revert with 0, 17
                                            if stor2[stor15] < stor2[stor15]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 2
                                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                            _23854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23854] = 26
                                            mem[_23854 + 32] = 'SafeMath: division by zero'
                                            _24004 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24004] = 26
                                            mem[_24004 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                _24144 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24144] = 30
                                                mem[_24144 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _24154 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _24154 + 68] = mem[idx + _24144 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_24154 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _24154 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _24670 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24670] = 26
                                                mem[_24670 + 32] = 'SafeMath: division by zero'
                                                if stor2[address(_22676)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_22676)
                                                mem[32] = 2
                                                _25226 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25226] = 26
                                                mem[_25226 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _24196 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24196] = 30
                                                mem[_24196 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _24207 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _24207 + 68] = mem[idx + _24196 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_24207 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _24207 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(cd[36] / 100 * _taxFee):
                                                    revert with 0, 17
                                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += cd[36] / 100 * _taxFee
                                                if _taxFee > !_liquidityFee:
                                                    revert with 0, 17
                                                if _taxFee + _liquidityFee > !_destroyFee:
                                                    revert with 0, 17
                                                if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                    revert with 0, 17
                                                _24902 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24902] = 26
                                                mem[_24902 + 32] = 'SafeMath: division by zero'
                                                if stor2[address(_22676)] > -1:
                                                    revert with 0, 17
                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = address(_22676)
                                                mem[32] = 2
                                                _25340 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25340] = 26
                                                mem[_25340 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not cd[36] / 100 * _liquidityFee:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _23920 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23920] = 26
                                                mem[_23920 + 32] = 'SafeMath: division by zero'
                                                _24084 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24084] = 26
                                                mem[_24084 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24195 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24195] = 30
                                                    mem[_24195 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24206 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24206 + 68] = mem[idx + _24195 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24206 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24206 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24901 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24901] = 26
                                                    mem[_24901 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25339 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25339] = 26
                                                    mem[_25339 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24279 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24279] = 30
                                                    mem[_24279 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24314 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24314 + 68] = mem[idx + _24279 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24314 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24314 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25092 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25092] = 26
                                                    mem[_25092 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25498 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25498] = 26
                                                    mem[_25498 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 17
                                                if not cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                    revert with 0, 17
                                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _24003 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24003] = 26
                                                mem[_24003 + 32] = 'SafeMath: division by zero'
                                                _24142 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24142] = 26
                                                mem[_24142 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24278 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24278] = 30
                                                    mem[_24278 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24313 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24313 + 68] = mem[idx + _24278 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24313 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24313 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25091 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25091] = 26
                                                    mem[_25091 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25497 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25497] = 26
                                                    mem[_25497 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24422 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24422] = 30
                                                    mem[_24422 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24492 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24492 + 68] = mem[idx + _24422 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24492 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24492 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25225 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25225] = 26
                                                    mem[_25225 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25740 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25740] = 26
                                                    mem[_25740 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not cd[36] / 100 * _destroyFee:
                                            if stor2[stor14] > -1:
                                                revert with 0, 17
                                            if stor2[stor14] < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23702 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23702] = 26
                                            mem[_23702 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _23919 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23919] = 26
                                                mem[_23919 + 32] = 'SafeMath: division by zero'
                                                _24083 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24083] = 26
                                                mem[_24083 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24194 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24194] = 30
                                                    mem[_24194 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24205 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24205 + 68] = mem[idx + _24194 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24205 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24205 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24899 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24899] = 26
                                                    mem[_24899 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25338 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25338] = 26
                                                    mem[_25338 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24277 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24277] = 30
                                                    mem[_24277 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24311 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24311 + 68] = mem[idx + _24277 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24311 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24311 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25090 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25090] = 26
                                                    mem[_25090 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25496 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25496] = 26
                                                    mem[_25496 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24002 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24002] = 26
                                                    mem[_24002 + 32] = 'SafeMath: division by zero'
                                                    _24141 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24141] = 26
                                                    mem[_24141 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24276 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24276] = 30
                                                        mem[_24276 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24310 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24310 + 68] = mem[idx + _24276 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24310 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24310 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25089 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25089] = 26
                                                        mem[_25089 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25495 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25495] = 26
                                                        mem[_25495 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24420 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24420] = 30
                                                        mem[_24420 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24489 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24489 + 68] = mem[idx + _24420 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24489 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24489 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25224 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25224] = 26
                                                        mem[_25224 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25739 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25739] = 26
                                                        mem[_25739 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24082 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24082] = 26
                                                    mem[_24082 + 32] = 'SafeMath: division by zero'
                                                    _24187 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24187] = 26
                                                    mem[_24187 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24419 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24419] = 30
                                                        mem[_24419 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24488 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24488 + 68] = mem[idx + _24419 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24488 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24488 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25223 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25223] = 26
                                                        mem[_25223 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25738 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25738] = 26
                                                        mem[_25738 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24620 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24620] = 30
                                                        mem[_24620 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24719 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24719 + 68] = mem[idx + _24620 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24719 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24719 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25337 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25337] = 26
                                                        mem[_25337 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26060 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26060] = 26
                                                        mem[_26060 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                                revert with 0, 17
                                            if not cd[36] / 100 * _destroyFee:
                                                revert with 0, 18
                                            if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                                revert with 0, 17
                                            if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23756] = 26
                                            mem[_23756 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _24001 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24001] = 26
                                                mem[_24001 + 32] = 'SafeMath: division by zero'
                                                _24140 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24140] = 26
                                                mem[_24140 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24275 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24275] = 30
                                                    mem[_24275 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24309 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24309 + 68] = mem[idx + _24275 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24309 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24309 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25087 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25087] = 26
                                                    mem[_25087 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25494 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25494] = 26
                                                    mem[_25494 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24418 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24418] = 30
                                                    mem[_24418 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24486 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24486 + 68] = mem[idx + _24418 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24486 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24486 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25222 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25222] = 26
                                                    mem[_25222 + 32] = 'SafeMath: division by zero'
                                                    if stor2[address(_22676)] > -1:
                                                        revert with 0, 17
                                                    if stor2[address(_22676)] < stor2[address(_22676)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(_22676)
                                                    mem[32] = 2
                                                    _25737 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25737] = 26
                                                    mem[_25737 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24081 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24081] = 26
                                                    mem[_24081 + 32] = 'SafeMath: division by zero'
                                                    _24186 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24186] = 26
                                                    mem[_24186 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24417 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24417] = 30
                                                        mem[_24417 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24485 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24485 + 68] = mem[idx + _24417 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24485 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24485 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25221 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25221] = 26
                                                        mem[_25221 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25736 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25736] = 26
                                                        mem[_25736 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24618 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24618] = 30
                                                        mem[_24618 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24716 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24716 + 68] = mem[idx + _24618 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24716 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24716 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25336 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25336] = 26
                                                        mem[_25336 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26059 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26059] = 26
                                                        mem[_26059 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24139 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24139] = 26
                                                    mem[_24139 + 32] = 'SafeMath: division by zero'
                                                    _24257 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24257] = 26
                                                    mem[_24257 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24617 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24617] = 30
                                                        mem[_24617 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24715 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24715 + 68] = mem[idx + _24617 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24715 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24715 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25335 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25335] = 26
                                                        mem[_25335 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26058 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26058] = 26
                                                        mem[_26058 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24837 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24837] = 30
                                                        mem[_24837 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24943 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24943 + 68] = mem[idx + _24837 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24943 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24943 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25493 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25493] = 26
                                                        mem[_25493 + 32] = 'SafeMath: division by zero'
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _26416 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26416] = 26
                                                        mem[_26416 + 32] = 'SafeMath: division by zero'
                                else:
                                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _23516 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23516] = 30
                                    mem[_23516 + 32] = 'SafeMath: subtraction overflow'
                                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                                        _23539 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23539 + 68] = mem[idx + _23516 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23539 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23539 + -mem[64] + 100
                                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                                    _23584 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23584] = 26
                                    mem[_23584 + 32] = 'SafeMath: division by zero'
                                    if not cd[36] / 100:
                                        if stor2[stor14] > -1:
                                            revert with 0, 17
                                        if stor2[stor14] < stor2[stor14]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_c41d28c5Address
                                        mem[32] = 2
                                        emit Transfer(0, msg.sender, sub_c41d28c5Address);
                                        _23701 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23701] = 26
                                        mem[_23701 + 32] = 'SafeMath: division by zero'
                                        if not cd[36] / 100:
                                            if stor2[stor15] > -1:
                                                revert with 0, 17
                                            if stor2[stor15] < stor2[stor15]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 2
                                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                            _23918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23918] = 26
                                            mem[_23918 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] * stor6 / totalSupply / 100:
                                                _24080 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24080] = 26
                                                mem[_24080 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24193 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24193] = 30
                                                    mem[_24193 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24204 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24204 + 68] = mem[idx + _24193 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24204 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24204 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _24891 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24891] = 26
                                                    mem[_24891 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25334 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25334] = 26
                                                        mem[_25334 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25492 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25492] = 26
                                                        mem[_25492 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24274 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24274] = 30
                                                    mem[_24274 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor6:
                                                        _24307 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24307 + 68] = mem[idx + _24274 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24307 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24307 + -mem[64] + 100
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25083 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25083] = 26
                                                    mem[_25083 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25491 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25491] = 26
                                                        mem[_25491 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25735 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25735] = 26
                                                        mem[_25735 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 17
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    revert with 0, 18
                                                if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _24138 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24138] = 26
                                                mem[_24138 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] / 100:
                                                    _24273 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24273] = 30
                                                    mem[_24273 + 32] = 'SafeMath: subtraction overflow'
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                        _24306 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24306 + 68] = mem[idx + _24273 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24306 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24306 + -mem[64] + 100
                                                    if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                        revert with 0, 17
                                                    stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                    if totalFees > -1:
                                                        revert with 0, 17
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25082 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25082] = 26
                                                    mem[_25082 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25490 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25490] = 26
                                                        mem[_25490 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _25734 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25734] = 26
                                                        mem[_25734 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                        revert with 0, 17
                                                    if not cd[36] / 100:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24415 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24415] = 30
                                                    mem[_24415 + 32] = 'SafeMath: subtraction overflow'
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                        _24482 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _24482 + 68] = mem[idx + _24415 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_24482 + 98] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _24482 + -mem[64] + 100
                                                    if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                        revert with 0, 17
                                                    stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                    if totalFees > !(cd[36] / 100 * _taxFee):
                                                        revert with 0, 17
                                                    if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += cd[36] / 100 * _taxFee
                                                    if _taxFee > !_liquidityFee:
                                                        revert with 0, 17
                                                    if _taxFee + _liquidityFee > !_destroyFee:
                                                        revert with 0, 17
                                                    if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                        revert with 0, 17
                                                    _25219 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25219] = 26
                                                    mem[_25219 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        if stor2[address(_22676)] > -1:
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        _25733 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25733] = 26
                                                        mem[_25733 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                            revert with 0, 17
                                                        if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(_22676)
                                                        mem[32] = 2
                                                        stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                        _26057 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26057] = 26
                                                        mem[_26057 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                revert with 0, 17
                                            if not cd[36] / 100:
                                                revert with 0, 18
                                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not cd[36] / 100 * _liquidityFee:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _24000 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24000] = 26
                                                mem[_24000 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24137 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24137] = 26
                                                    mem[_24137 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24272 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24272] = 30
                                                        mem[_24272 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24305 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24305 + 68] = mem[idx + _24272 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24305 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24305 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25081 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25081] = 26
                                                        mem[_25081 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25489 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25489] = 26
                                                            mem[_25489 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _25732 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25732] = 26
                                                            mem[_25732 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24414 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24414] = 30
                                                        mem[_24414 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24480 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24480 + 68] = mem[idx + _24414 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24480 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24480 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25218 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25218] = 26
                                                        mem[_25218 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25731 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25731] = 26
                                                            mem[_25731 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26056 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26056] = 26
                                                            mem[_26056 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24185 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24185] = 26
                                                    mem[_24185 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24413 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24413] = 30
                                                        mem[_24413 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24479 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24479 + 68] = mem[idx + _24413 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24479 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24479 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25217 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25217] = 26
                                                        mem[_25217 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25730 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25730] = 26
                                                            mem[_25730 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26055 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26055] = 26
                                                            mem[_26055 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24613 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24613] = 30
                                                        mem[_24613 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24711 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24711 + 68] = mem[idx + _24613 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24711 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24711 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25333 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25333] = 26
                                                        mem[_25333 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26054 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26054] = 26
                                                            mem[_26054 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26415 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26415] = 26
                                                            mem[_26415 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 17
                                                if not cd[36] / 100 * _liquidityFee:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                    revert with 0, 17
                                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                _24079 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24079] = 26
                                                mem[_24079 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24184 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24184] = 26
                                                    mem[_24184 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24412 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24412] = 30
                                                        mem[_24412 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24478 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24478 + 68] = mem[idx + _24412 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24478 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24478 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25216 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25216] = 26
                                                        mem[_25216 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25729 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25729] = 26
                                                            mem[_25729 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26053 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26053] = 26
                                                            mem[_26053 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24612 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24612] = 30
                                                        mem[_24612 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24709 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24709 + 68] = mem[idx + _24612 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24709 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24709 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25332 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25332] = 26
                                                        mem[_25332 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26052 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26052] = 26
                                                            mem[_26052 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26414 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26414] = 26
                                                            mem[_26414 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24255 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24255] = 26
                                                    mem[_24255 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24611 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24611] = 30
                                                        mem[_24611 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24708 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24708 + 68] = mem[idx + _24611 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24708 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24708 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25331 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25331] = 26
                                                        mem[_25331 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26051 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26051] = 26
                                                            mem[_26051 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26413 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26413] = 26
                                                            mem[_26413 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24832 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24832] = 30
                                                        mem[_24832 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24939 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24939 + 68] = mem[idx + _24832 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24939 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24939 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25488 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25488] = 26
                                                        mem[_25488 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26412 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26412] = 26
                                                            mem[_26412 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26758 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26758] = 26
                                                            mem[_26758 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                            revert with 0, 17
                                        if not cd[36] / 100:
                                            revert with 0, 18
                                        if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not cd[36] / 100 * _destroyFee:
                                            if stor2[stor14] > -1:
                                                revert with 0, 17
                                            if stor2[stor14] < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23755] = 26
                                            mem[_23755 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _23999 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23999] = 26
                                                mem[_23999 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24136 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24136] = 26
                                                    mem[_24136 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24271 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24271] = 30
                                                        mem[_24271 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24304 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24304 + 68] = mem[idx + _24271 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24304 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24304 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25076 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25076] = 26
                                                        mem[_25076 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25487 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25487] = 26
                                                            mem[_25487 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _25728 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25728] = 26
                                                            mem[_25728 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24411 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24411] = 30
                                                        mem[_24411 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24476 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24476 + 68] = mem[idx + _24411 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24476 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24476 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25214 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25214] = 26
                                                        mem[_25214 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25727 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25727] = 26
                                                            mem[_25727 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26050 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26050] = 26
                                                            mem[_26050 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24183 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24183] = 26
                                                    mem[_24183 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24410 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24410] = 30
                                                        mem[_24410 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24475 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24475 + 68] = mem[idx + _24410 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24475 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24475 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25213 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25213] = 26
                                                        mem[_25213 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25726 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25726] = 26
                                                            mem[_25726 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26049 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26049] = 26
                                                            mem[_26049 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24609 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24609] = 30
                                                        mem[_24609 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24705 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24705 + 68] = mem[idx + _24609 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24705 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24705 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25330 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25330] = 26
                                                        mem[_25330 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26048 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26048] = 26
                                                            mem[_26048 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26411 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26411] = 26
                                                            mem[_26411 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24078 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24078] = 26
                                                    mem[_24078 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24182 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24182] = 26
                                                        mem[_24182 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24409 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24409] = 30
                                                            mem[_24409 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24474 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24474 + 68] = mem[idx + _24409 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24474 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24474 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25212 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25212] = 26
                                                            mem[_25212 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _25725 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_25725] = 26
                                                                mem[_25725 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26047 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26047] = 26
                                                                mem[_26047 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24608 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24608] = 30
                                                            mem[_24608 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24703 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24703 + 68] = mem[idx + _24608 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24703 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24703 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25329 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25329] = 26
                                                            mem[_25329 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26046 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26046] = 26
                                                                mem[_26046 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26410 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26410] = 26
                                                                mem[_26410 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24254 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24254] = 26
                                                        mem[_24254 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24607 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24607] = 30
                                                            mem[_24607 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24702 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24702 + 68] = mem[idx + _24607 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24702 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24702 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25328 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25328] = 26
                                                            mem[_25328 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26045 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26045] = 26
                                                                mem[_26045 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26409 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26409] = 26
                                                                mem[_26409 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24828 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24828] = 30
                                                            mem[_24828 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24935 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24935 + 68] = mem[idx + _24828 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24935 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24935 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25486 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25486] = 26
                                                            mem[_25486 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26408 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26408] = 26
                                                                mem[_26408 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26757 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26757] = 26
                                                                mem[_26757 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24135 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24135] = 26
                                                    mem[_24135 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24253 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24253] = 26
                                                        mem[_24253 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24606 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24606] = 30
                                                            mem[_24606 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24701 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24701 + 68] = mem[idx + _24606 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24701 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24701 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25327 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25327] = 26
                                                            mem[_25327 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26044 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26044] = 26
                                                                mem[_26044 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26407 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26407] = 26
                                                                mem[_26407 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24827 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24827] = 30
                                                            mem[_24827 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24933 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24933 + 68] = mem[idx + _24827 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24933 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24933 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25485 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25485] = 26
                                                            mem[_25485 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26406 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26406] = 26
                                                                mem[_26406 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26756 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26756] = 26
                                                                mem[_26756 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24381 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24381] = 26
                                                        mem[_24381 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24826 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24826] = 30
                                                            mem[_24826 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24932 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24932 + 68] = mem[idx + _24826 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24932 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24932 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25484 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25484] = 26
                                                            mem[_25484 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26405 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26405] = 26
                                                                mem[_26405 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26755 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26755] = 26
                                                                mem[_26755 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25019 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25019] = 30
                                                            mem[_25019 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25113 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25113 + 68] = mem[idx + _25019 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25113 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25113 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25724 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25724] = 26
                                                            mem[_25724 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26754 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26754] = 26
                                                                mem[_26754 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27435 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27435] = 26
                                                                mem[_27435 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                                revert with 0, 17
                                            if not cd[36] / 100 * _destroyFee:
                                                revert with 0, 18
                                            if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                                revert with 0, 17
                                            if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_c41d28c5Address
                                            mem[32] = 2
                                            stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                                            _23798 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23798] = 26
                                            mem[_23798 + 32] = 'SafeMath: division by zero'
                                            if not cd[36] / 100:
                                                if stor2[stor15] > -1:
                                                    revert with 0, 17
                                                if stor2[stor15] < stor2[stor15]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 2
                                                emit Transfer(0, msg.sender, uniswapV2PairAddress);
                                                _24077 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24077] = 26
                                                mem[_24077 + 32] = 'SafeMath: division by zero'
                                                if not cd[36] * stor6 / totalSupply / 100:
                                                    _24181 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24181] = 26
                                                    mem[_24181 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24408 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24408] = 30
                                                        mem[_24408 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24473 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24473 + 68] = mem[idx + _24408 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24473 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24473 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25207 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25207] = 26
                                                        mem[_25207 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _25723 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25723] = 26
                                                            mem[_25723 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26043 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26043] = 26
                                                            mem[_26043 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24605 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24605] = 30
                                                        mem[_24605 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor6:
                                                            _24699 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24699 + 68] = mem[idx + _24605 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24699 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24699 + -mem[64] + 100
                                                        if stor6 < 0:
                                                            revert with 0, 17
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25325 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25325] = 26
                                                        mem[_25325 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26042 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26042] = 26
                                                            mem[_26042 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26404 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26404] = 26
                                                            mem[_26404 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 17
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        revert with 0, 18
                                                    if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _24252 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24252] = 26
                                                    mem[_24252 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] / 100:
                                                        _24604 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24604] = 30
                                                        mem[_24604 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24698 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24698 + 68] = mem[idx + _24604 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24698 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24698 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > -1:
                                                            revert with 0, 17
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25324 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25324] = 26
                                                        mem[_25324 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26041 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26041] = 26
                                                            mem[_26041 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26403 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26403] = 26
                                                            mem[_26403 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                            revert with 0, 17
                                                        if not cd[36] / 100:
                                                            revert with 0, 18
                                                        if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24824 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24824] = 30
                                                        mem[_24824 + 32] = 'SafeMath: subtraction overflow'
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                            _24929 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _24929 + 68] = mem[idx + _24824 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_24929 + 98] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _24929 + -mem[64] + 100
                                                        if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                            revert with 0, 17
                                                        stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                        if totalFees > !(cd[36] / 100 * _taxFee):
                                                            revert with 0, 17
                                                        if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += cd[36] / 100 * _taxFee
                                                        if _taxFee > !_liquidityFee:
                                                            revert with 0, 17
                                                        if _taxFee + _liquidityFee > !_destroyFee:
                                                            revert with 0, 17
                                                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                            revert with 0, 17
                                                        _25483 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25483] = 26
                                                        mem[_25483 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            if stor2[address(_22676)] > -1:
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            _26402 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26402] = 26
                                                            mem[_26402 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 17
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                revert with 0, 18
                                                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                revert with 0, 17
                                                            if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(_22676)
                                                            mem[32] = 2
                                                            stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                            _26753 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26753] = 26
                                                            mem[_26753 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                                    revert with 0, 17
                                                if not cd[36] / 100:
                                                    revert with 0, 18
                                                if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not cd[36] / 100 * _liquidityFee:
                                                    if stor2[stor15] > -1:
                                                        revert with 0, 17
                                                    if stor2[stor15] < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24134 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24134] = 26
                                                    mem[_24134 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24251 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24251] = 26
                                                        mem[_24251 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24603 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24603] = 30
                                                            mem[_24603 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24697 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24697 + 68] = mem[idx + _24603 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24697 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24697 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25323 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25323] = 26
                                                            mem[_25323 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26040 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26040] = 26
                                                                mem[_26040 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26401 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26401] = 26
                                                                mem[_26401 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _24823 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24823] = 30
                                                            mem[_24823 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24927 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24927 + 68] = mem[idx + _24823 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24927 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24927 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25482 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25482] = 26
                                                            mem[_25482 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26400 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26400] = 26
                                                                mem[_26400 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26752 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26752] = 26
                                                                mem[_26752 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24380 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24380] = 26
                                                        mem[_24380 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24822 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24822] = 30
                                                            mem[_24822 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _24926 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24926 + 68] = mem[idx + _24822 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24926 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24926 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25481 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25481] = 26
                                                            mem[_25481 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26399 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26399] = 26
                                                                mem[_26399 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26751 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26751] = 26
                                                                mem[_26751 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25015 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25015] = 30
                                                            mem[_25015 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25109 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25109 + 68] = mem[idx + _25015 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25109 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25109 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25722 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25722] = 26
                                                            mem[_25722 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26750 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26750] = 26
                                                                mem[_26750 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27434 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27434] = 26
                                                                mem[_27434 + 32] = 'SafeMath: division by zero'
                                                else:
                                                    if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 17
                                                    if not cd[36] / 100 * _liquidityFee:
                                                        revert with 0, 18
                                                    if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                                        revert with 0, 17
                                                    if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 2
                                                    stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                                                    emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                                                    _24180 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24180] = 26
                                                    mem[_24180 + 32] = 'SafeMath: division by zero'
                                                    if not cd[36] * stor6 / totalSupply / 100:
                                                        _24379 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24379] = 26
                                                        mem[_24379 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _24821 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24821] = 30
                                                            mem[_24821 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _24925 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _24925 + 68] = mem[idx + _24821 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_24925 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _24925 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25480 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25480] = 26
                                                            mem[_25480 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26398 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26398] = 26
                                                                mem[_26398 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _26749 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26749] = 26
                                                                mem[_26749 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25014 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25014] = 30
                                                            mem[_25014 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > stor6:
                                                                _25107 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25107 + 68] = mem[idx + _25014 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25107 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25107 + -mem[64] + 100
                                                            if stor6 < 0:
                                                                revert with 0, 17
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25721 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25721] = 26
                                                            mem[_25721 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26748 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26748] = 26
                                                                mem[_26748 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27433 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27433] = 26
                                                                mem[_27433 + 32] = 'SafeMath: division by zero'
                                                    else:
                                                        if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 17
                                                        if not cd[36] * stor6 / totalSupply / 100:
                                                            revert with 0, 18
                                                        if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _24567 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24567] = 26
                                                        mem[_24567 + 32] = 'SafeMath: division by zero'
                                                        if not cd[36] / 100:
                                                            _25013 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25013] = 30
                                                            mem[_25013 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25106 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25106 + 68] = mem[idx + _25013 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25106 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25106 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > -1:
                                                                revert with 0, 17
                                                            if totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _25720 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25720] = 26
                                                            mem[_25720 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _26747 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_26747] = 26
                                                                mem[_26747 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27432 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27432] = 26
                                                                mem[_27432 + 32] = 'SafeMath: division by zero'
                                                        else:
                                                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                                                revert with 0, 17
                                                            if not cd[36] / 100:
                                                                revert with 0, 18
                                                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _25157 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25157] = 30
                                                            mem[_25157 + 32] = 'SafeMath: subtraction overflow'
                                                            if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                                                _25232 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _25232 + 68] = mem[idx + _25157 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_25232 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _25232 + -mem[64] + 100
                                                            if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                                                revert with 0, 17
                                                            stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                                            if totalFees > !(cd[36] / 100 * _taxFee):
                                                                revert with 0, 17
                                                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += cd[36] / 100 * _taxFee
                                                            if _taxFee > !_liquidityFee:
                                                                revert with 0, 17
                                                            if _taxFee + _liquidityFee > !_destroyFee:
                                                                revert with 0, 17
                                                            if 100 < _taxFee + _liquidityFee + _destroyFee:
                                                                revert with 0, 17
                                                            _26039 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26039] = 26
                                                            mem[_26039 + 32] = 'SafeMath: division by zero'
                                                            if not cd[36] * stor6 / totalSupply / 100:
                                                                if stor2[address(_22676)] > -1:
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                _27431 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27431] = 26
                                                                mem[_27431 + 32] = 'SafeMath: division by zero'
                                                            else:
                                                                if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 17
                                                                if not cd[36] * stor6 / totalSupply / 100:
                                                                    revert with 0, 18
                                                                if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if stor2[address(_22676)] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                                                    revert with 0, 17
                                                                if stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(_22676)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(_22676)
                                                                mem[32] = 2
                                                                stor2[address(_22676)] = stor2[address(_22676)] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                                                                _27643 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_27643] = 26
                                                                mem[_27643 + 32] = 'SafeMath: division by zero'
                            if not cd[36] / 100:
                                mem[mem[64]] = 0
                                emit Transfer(0, msg.sender, address(_22676));
                            else:
                                if cd[36] / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if (100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100) / cd[36] / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = (100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100)
                                emit Transfer(((100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100)), msg.sender, address(_22676));
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
        if unknown_0xa457c2d7(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if cd[36] > allowance[msg.sender][address(cd[4])]:
                revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[197 len 27] >> 40, 0
            if allowance[msg.sender][address(cd[4])] < cd[36]:
                revert with 0, 17
            if not msg.sender:
                revert with 0, 'ERC20: approve from the zero address'
            if not address(cd[4]):
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(msg.sender)][address(cd[4])] = allowance[msg.sender][address(cd[4])] - cd[36]
            emit Approval((allowance[msg.sender][address(cd[4])] - cd[36]), msg.sender, address(cd[4]));
        else:
            if unknown_0xa6f9dae1(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                _owner = address(cd[4])
            if uint32(call.func_hash) >> 224 != unknown_0xa9059cbb(?????):
                require unknown_0xb2bdfa7b(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                return _owner
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if not address(cd[4]):
                revert with 0, 'ERC20: transfer to the zero address'
            if cd[36] <= 0:
                revert with 0, 'Transfer amount must be greater than zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if stor4[address(msg.sender)]:
                if not cd[36]:
                    if 0 > stor2[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor2[address(msg.sender)] < 0:
                        revert with 0, 17
                    if stor2[address(cd[4])] > -1:
                        revert with 0, 17
                    if stor2[address(cd[4])] < stor2[address(cd[4])]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                        revert with 0, 17
                    if not cd[36]:
                        revert with 0, 18
                    if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                        revert with 0, 17
                    stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                    if not cd[36] * stor6 / totalSupply / 100:
                        if stor2[address(cd[4])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[4])] < stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 17
                        if not cd[36] * stor6 / totalSupply / 100:
                            revert with 0, 18
                        if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[address(cd[4])] > !(100 * cd[36] * stor6 / totalSupply / 100):
                            revert with 0, 17
                        if stor2[address(cd[4])] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(cd[4])] += 100 * cd[36] * stor6 / totalSupply / 100
                if not cd[36] / 100:
                    emit Transfer(0, msg.sender, address(cd[4]));
                else:
                    if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                        revert with 0, 17
                    if not cd[36] / 100:
                        revert with 0, 18
                    if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    emit Transfer((100 * cd[36] / 100), msg.sender, address(cd[4]));
            else:
                if stor4[address(cd[4])]:
                    if not cd[36]:
                        if 0 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor2[address(cd[4])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[4])] < stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        if not cd[36] * stor6 / totalSupply / 100:
                            if stor2[address(cd[4])] > -1:
                                revert with 0, 17
                            if stor2[address(cd[4])] < stor2[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[36] * stor6 / totalSupply / 100 and 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if 100 * cd[36] * stor6 / totalSupply / 100 / cd[36] * stor6 / totalSupply / 100 != 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(cd[4])] > !(100 * cd[36] * stor6 / totalSupply / 100):
                                revert with 0, 17
                            if stor2[address(cd[4])] + (100 * cd[36] * stor6 / totalSupply / 100) < stor2[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(cd[4])] += 100 * cd[36] * stor6 / totalSupply / 100
                    if not cd[36] / 100:
                        emit Transfer(0, msg.sender, address(cd[4]));
                    else:
                        if cd[36] / 100 and 100 > -1 / cd[36] / 100:
                            revert with 0, 17
                        if not cd[36] / 100:
                            revert with 0, 18
                        if 100 * cd[36] / 100 / cd[36] / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        emit Transfer((100 * cd[36] / 100), msg.sender, address(cd[4]));
                else:
                    if not cd[36]:
                        if 0 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < 0:
                            revert with 0, 17
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                        if not cd[36] / 100:
                            if stor2[stor15] > -1:
                                revert with 0, 17
                            if stor2[stor15] < stor2[stor15]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                        else:
                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _liquidityFee:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _liquidityFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                            emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                        if not cd[36] / 100:
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(cd[36] / 100 * _taxFee):
                                revert with 0, 17
                            if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += cd[36] / 100 * _taxFee
                        if _taxFee > !_liquidityFee:
                            revert with 0, 17
                        if _taxFee + _liquidityFee > !_destroyFee:
                            revert with 0, 17
                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                            revert with 0, 17
                        if stor2[address(cd[4])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[4])] < stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if cd[36] * stor6 / totalSupply > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < cd[36] * stor6 / totalSupply:
                            revert with 0, 17
                        stor2[address(msg.sender)] += -1 * cd[36] * stor6 / totalSupply
                        if not cd[36] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, msg.sender, sub_c41d28c5Address);
                        else:
                            if cd[36] / 100 and _destroyFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _destroyFee / cd[36] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[36] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _destroyFee * stor6 / totalSupply / cd[36] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[36] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[36] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor14] += cd[36] / 100 * _destroyFee * stor6 / totalSupply
                            emit Transfer((cd[36] / 100 * _destroyFee), msg.sender, sub_c41d28c5Address);
                        if not cd[36] / 100:
                            if stor2[stor15] > -1:
                                revert with 0, 17
                            if stor2[stor15] < stor2[stor15]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, msg.sender, uniswapV2PairAddress);
                        else:
                            if cd[36] / 100 and _liquidityFee > -1 / cd[36] / 100:
                                revert with 0, 17
                            if not cd[36] / 100:
                                revert with 0, 18
                            if cd[36] / 100 * _liquidityFee / cd[36] / 100 != _liquidityFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100 * _liquidityFee:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[36] / 100 * _liquidityFee:
                                    revert with 0, 17
                                if not cd[36] / 100 * _liquidityFee:
                                    revert with 0, 18
                                if cd[36] / 100 * _liquidityFee * stor6 / totalSupply / cd[36] / 100 * _liquidityFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor15] > !(cd[36] / 100 * _liquidityFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor15] + (cd[36] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor15] += cd[36] / 100 * _liquidityFee * stor6 / totalSupply
                            emit Transfer((cd[36] / 100 * _liquidityFee), msg.sender, uniswapV2PairAddress);
                        if not cd[36] * stor6 / totalSupply / 100:
                            if not cd[36] / 100:
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(cd[36] / 100 * _taxFee):
                                    revert with 0, 17
                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += cd[36] / 100 * _taxFee
                        else:
                            if cd[36] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if cd[36] * stor6 / totalSupply / 100 * _taxFee / cd[36] * stor6 / totalSupply / 100 != _taxFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[36] / 100:
                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                    revert with 0, 17
                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[36] / 100 and _taxFee > -1 / cd[36] / 100:
                                    revert with 0, 17
                                if not cd[36] / 100:
                                    revert with 0, 18
                                if cd[36] / 100 * _taxFee / cd[36] / 100 != _taxFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if cd[36] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < cd[36] * stor6 / totalSupply / 100 * _taxFee:
                                    revert with 0, 17
                                stor6 += -1 * cd[36] * stor6 / totalSupply / 100 * _taxFee
                                if totalFees > !(cd[36] / 100 * _taxFee):
                                    revert with 0, 17
                                if totalFees + (cd[36] / 100 * _taxFee) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += cd[36] / 100 * _taxFee
                        if _taxFee > !_liquidityFee:
                            revert with 0, 17
                        if _taxFee + _liquidityFee > !_destroyFee:
                            revert with 0, 17
                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                            revert with 0, 17
                        if not cd[36] * stor6 / totalSupply / 100:
                            if stor2[address(cd[4])] > -1:
                                revert with 0, 17
                            if stor2[address(cd[4])] < stor2[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[36] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[36] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) / cd[36] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(cd[4])] > !((100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)):
                                revert with 0, 17
                            if stor2[address(cd[4])] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100) < stor2[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(cd[4])] = stor2[address(cd[4])] + (100 * cd[36] * stor6 / totalSupply / 100) - (_taxFee * cd[36] * stor6 / totalSupply / 100) - (_liquidityFee * cd[36] * stor6 / totalSupply / 100) - (_destroyFee * cd[36] * stor6 / totalSupply / 100)
                    if not cd[36] / 100:
                        emit Transfer(0, msg.sender, address(cd[4]));
                    else:
                        if cd[36] / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[36] / 100:
                            revert with 0, 17
                        if not cd[36] / 100:
                            revert with 0, 18
                        if (100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100) / cd[36] / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        emit Transfer(((100 * cd[36] / 100) - (_taxFee * cd[36] / 100) - (_liquidityFee * cd[36] / 100) - (_destroyFee * cd[36] / 100)), msg.sender, address(cd[4]));
    else:
        if unknown_0x2d838119(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0x357bf15c(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x2d838119(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not stor6 / totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    return (cd[4] / stor6 / totalSupply)
                if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return decimals
                require unknown_0x340ac20f(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                uniswapV2PairAddress = address(cd[4])
            if unknown_0x357bf15c(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                _liquidityFee = cd[4]
            if uint32(call.func_hash) >> 224 != unknown_0x39509351(?????):
                if unknown_0x3b124fe7(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return _taxFee
                require unknown_0x437823ec(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                stor4[address(cd[4])] = 1
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if allowance[msg.sender][address(cd[4])] > !cd[36]:
                revert with 0, 17
            if allowance[msg.sender][address(cd[4])] + cd[36] < allowance[msg.sender][address(cd[4])]:
                revert with 0, 'SafeMath: addition overflow'
            if not msg.sender:
                revert with 0, 'ERC20: approve from the zero address'
            if not address(cd[4]):
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(msg.sender)][address(cd[4])] = allowance[msg.sender][address(cd[4])] + cd[36]
            emit Approval((allowance[msg.sender][address(cd[4])] + cd[36]), msg.sender, address(cd[4]));
        else:
            if unknown_0x13114a9d(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x0512e486(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if stor1 != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not cd[36]:
                        stor2[address(cd[4])] = 0
                    else:
                        if cd[36] and stor6 / totalSupply > -1 / cd[36]:
                            revert with 0, 17
                        if not cd[36]:
                            revert with 0, 18
                        if cd[36] * stor6 / totalSupply / cd[36] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        stor2[address(cd[4])] = cd[36] * stor6 / totalSupply
                if uint32(call.func_hash) >> 224 != name():
                    require approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if not msg.sender:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not address(cd[4]):
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(msg.sender)][address(cd[4])] = cd[36]
                    emit Approval(cd[36], msg.sender, address(cd[4]));
                    return 1
                require not msg.value
                if bool(stor8.length):
                    if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor8.length):
                        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor8.length):
                            if 31 < uint255(stor8.length) * 0.5:
                                mem[160] = uint256(stor8.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor8.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor8[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)])
                            mem[160] = 256 * stor8.length.field_8
                    else:
                        if bool(stor8.length) == stor8.length.field_1 < 32:
                            revert with 0, 34
                        if stor8.length.field_1:
                            if 31 < stor8.length.field_1:
                                mem[160] = uint256(stor8.field_0)
                                idx = 160
                                s = 0
                                while stor8.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor8[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)])
                            mem[160] = 256 * stor8.length.field_8
                    mem[ceil32(uint255(stor8.length) * 0.5) + 224 len ceil32(uint255(stor8.length) * 0.5)] = mem[160 len ceil32(uint255(stor8.length) * 0.5)]
                    if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
                        mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 224] = 0
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[160 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
                if bool(stor8.length) == stor8.length.field_1 < 32:
                    revert with 0, 34
                if bool(stor8.length):
                    if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor8.length):
                        if 31 < uint255(stor8.length) * 0.5:
                            mem[160] = uint256(stor8.field_0)
                            idx = 160
                            s = 0
                            while (uint255(stor8.length) * 0.5) + 128 > idx:
                                mem[idx + 32] = stor8[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)])
                        mem[160] = 256 * stor8.length.field_8
                else:
                    if bool(stor8.length) == stor8.length.field_1 < 32:
                        revert with 0, 34
                    if stor8.length.field_1:
                        if 31 < stor8.length.field_1:
                            mem[160] = uint256(stor8.field_0)
                            idx = 160
                            s = 0
                            while stor8.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor8[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)])
                        mem[160] = 256 * stor8.length.field_8
                mem[ceil32(stor8.length.field_1) + 224 len ceil32(stor8.length.field_1)] = mem[160 len ceil32(stor8.length.field_1)]
                if ceil32(stor8.length.field_1) > stor8.length.field_1:
                    mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 224] = 0
                return Array(len=stor8.length % 128, data=mem[160 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 224 len 2 * ceil32(stor8.length.field_1)]), 
            if unknown_0x13114a9d(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return totalFees
            if unknown_0x17906aa0(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 96
                require cd[4] == address(cd[4])
                if stor1 != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                sub_c41d28c5Address = address(cd[4])
                _taxFee = cd[36]
                _destroyFee = cd[68]
            if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return totalSupply
            require unknown_0x23b872dd(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] == address(cd[4])
            require cd[36] == address(cd[36])
            if not address(cd[4]):
                revert with 0, 'ERC20: transfer from the zero address'
            if not address(cd[36]):
                revert with 0, 'ERC20: transfer to the zero address'
            if cd[68] <= 0:
                revert with 0, 'Transfer amount must be greater than zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if stor4[address(cd[4])]:
                if not cd[68]:
                    if 0 > stor2[address(cd[4])]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor2[address(cd[4])] < 0:
                        revert with 0, 17
                    if stor2[address(cd[36])] > -1:
                        revert with 0, 17
                    if stor2[address(cd[36])] < stor2[address(cd[36])]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if cd[68] and stor6 / totalSupply > -1 / cd[68]:
                        revert with 0, 17
                    if not cd[68]:
                        revert with 0, 18
                    if cd[68] * stor6 / totalSupply / cd[68] != stor6 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if cd[68] * stor6 / totalSupply > stor2[address(cd[4])]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor2[address(cd[4])] < cd[68] * stor6 / totalSupply:
                        revert with 0, 17
                    stor2[address(cd[4])] += -1 * cd[68] * stor6 / totalSupply
                    if not cd[68] * stor6 / totalSupply / 100:
                        if stor2[address(cd[36])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[36])] < stor2[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[68] * stor6 / totalSupply / 100 and 100 > -1 / cd[68] * stor6 / totalSupply / 100:
                            revert with 0, 17
                        if not cd[68] * stor6 / totalSupply / 100:
                            revert with 0, 18
                        if 100 * cd[68] * stor6 / totalSupply / 100 / cd[68] * stor6 / totalSupply / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if stor2[address(cd[36])] > !(100 * cd[68] * stor6 / totalSupply / 100):
                            revert with 0, 17
                        if stor2[address(cd[36])] + (100 * cd[68] * stor6 / totalSupply / 100) < stor2[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(cd[36])] += 100 * cd[68] * stor6 / totalSupply / 100
                if not cd[68] / 100:
                    emit Transfer(0, address(cd[4]), address(cd[36]));
                else:
                    if cd[68] / 100 and 100 > -1 / cd[68] / 100:
                        revert with 0, 17
                    if not cd[68] / 100:
                        revert with 0, 18
                    if 100 * cd[68] / 100 / cd[68] / 100 != 100:
                        revert with 0, 'SafeMath: multiplication overflow'
                    emit Transfer((100 * cd[68] / 100), address(cd[4]), address(cd[36]));
                if cd[68] > allowance[address(cd[4])][msg.sender]:
                    revert with 0, 32, 40, 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
            else:
                if stor4[address(cd[36])]:
                    if not cd[68]:
                        if 0 > stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(cd[4])] < 0:
                            revert with 0, 17
                        if stor2[address(cd[36])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[36])] < stor2[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[68] and stor6 / totalSupply > -1 / cd[68]:
                            revert with 0, 17
                        if not cd[68]:
                            revert with 0, 18
                        if cd[68] * stor6 / totalSupply / cd[68] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if cd[68] * stor6 / totalSupply > stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(cd[4])] < cd[68] * stor6 / totalSupply:
                            revert with 0, 17
                        stor2[address(cd[4])] += -1 * cd[68] * stor6 / totalSupply
                        if not cd[68] * stor6 / totalSupply / 100:
                            if stor2[address(cd[36])] > -1:
                                revert with 0, 17
                            if stor2[address(cd[36])] < stor2[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[68] * stor6 / totalSupply / 100 and 100 > -1 / cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if 100 * cd[68] * stor6 / totalSupply / 100 / cd[68] * stor6 / totalSupply / 100 != 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(cd[36])] > !(100 * cd[68] * stor6 / totalSupply / 100):
                                revert with 0, 17
                            if stor2[address(cd[36])] + (100 * cd[68] * stor6 / totalSupply / 100) < stor2[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(cd[36])] += 100 * cd[68] * stor6 / totalSupply / 100
                    if not cd[68] / 100:
                        emit Transfer(0, address(cd[4]), address(cd[36]));
                    else:
                        if cd[68] / 100 and 100 > -1 / cd[68] / 100:
                            revert with 0, 17
                        if not cd[68] / 100:
                            revert with 0, 18
                        if 100 * cd[68] / 100 / cd[68] / 100 != 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        emit Transfer((100 * cd[68] / 100), address(cd[4]), address(cd[36]));
                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                        revert with 0, 32, 40, 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                else:
                    if not cd[68]:
                        if 0 > stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(cd[4])] < 0:
                            revert with 0, 17
                        if not cd[68] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, address(cd[4]), sub_c41d28c5Address);
                        else:
                            if cd[68] / 100 and _destroyFee > -1 / cd[68] / 100:
                                revert with 0, 17
                            if not cd[68] / 100:
                                revert with 0, 18
                            if cd[68] / 100 * _destroyFee / cd[68] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[68] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[68] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[68] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[68] / 100 * _destroyFee * stor6 / totalSupply / cd[68] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[68] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[68] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor14] += cd[68] / 100 * _destroyFee * stor6 / totalSupply
                            emit Transfer((cd[68] / 100 * _destroyFee), address(cd[4]), sub_c41d28c5Address);
                        if not cd[68] / 100:
                            if stor2[stor15] > -1:
                                revert with 0, 17
                            if stor2[stor15] < stor2[stor15]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, address(cd[4]), uniswapV2PairAddress);
                        else:
                            if cd[68] / 100 and _liquidityFee > -1 / cd[68] / 100:
                                revert with 0, 17
                            if not cd[68] / 100:
                                revert with 0, 18
                            if cd[68] / 100 * _liquidityFee / cd[68] / 100 != _liquidityFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[68] / 100 * _liquidityFee:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[68] / 100 * _liquidityFee:
                                    revert with 0, 17
                                if not cd[68] / 100 * _liquidityFee:
                                    revert with 0, 18
                                if cd[68] / 100 * _liquidityFee * stor6 / totalSupply / cd[68] / 100 * _liquidityFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor15] > !(cd[68] / 100 * _liquidityFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor15] + (cd[68] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor15] += cd[68] / 100 * _liquidityFee * stor6 / totalSupply
                            emit Transfer((cd[68] / 100 * _liquidityFee), address(cd[4]), uniswapV2PairAddress);
                        if not cd[68] / 100:
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[68] / 100 and _taxFee > -1 / cd[68] / 100:
                                revert with 0, 17
                            if not cd[68] / 100:
                                revert with 0, 18
                            if cd[68] / 100 * _taxFee / cd[68] / 100 != _taxFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(cd[68] / 100 * _taxFee):
                                revert with 0, 17
                            if totalFees + (cd[68] / 100 * _taxFee) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += cd[68] / 100 * _taxFee
                        if _taxFee > !_liquidityFee:
                            revert with 0, 17
                        if _taxFee + _liquidityFee > !_destroyFee:
                            revert with 0, 17
                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                            revert with 0, 17
                        if stor2[address(cd[36])] > -1:
                            revert with 0, 17
                        if stor2[address(cd[36])] < stor2[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if cd[68] and stor6 / totalSupply > -1 / cd[68]:
                            revert with 0, 17
                        if not cd[68]:
                            revert with 0, 18
                        if cd[68] * stor6 / totalSupply / cd[68] != stor6 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if cd[68] * stor6 / totalSupply > stor2[address(cd[4])]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(cd[4])] < cd[68] * stor6 / totalSupply:
                            revert with 0, 17
                        stor2[address(cd[4])] += -1 * cd[68] * stor6 / totalSupply
                        if not cd[68] / 100:
                            if stor2[stor14] > -1:
                                revert with 0, 17
                            if stor2[stor14] < stor2[stor14]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, address(cd[4]), sub_c41d28c5Address);
                        else:
                            if cd[68] / 100 and _destroyFee > -1 / cd[68] / 100:
                                revert with 0, 17
                            if not cd[68] / 100:
                                revert with 0, 18
                            if cd[68] / 100 * _destroyFee / cd[68] / 100 != _destroyFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[68] / 100 * _destroyFee:
                                if stor2[stor14] > -1:
                                    revert with 0, 17
                                if stor2[stor14] < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 * _destroyFee and stor6 / totalSupply > -1 / cd[68] / 100 * _destroyFee:
                                    revert with 0, 17
                                if not cd[68] / 100 * _destroyFee:
                                    revert with 0, 18
                                if cd[68] / 100 * _destroyFee * stor6 / totalSupply / cd[68] / 100 * _destroyFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor14] > !(cd[68] / 100 * _destroyFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor14] + (cd[68] / 100 * _destroyFee * stor6 / totalSupply) < stor2[stor14]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor14] += cd[68] / 100 * _destroyFee * stor6 / totalSupply
                            emit Transfer((cd[68] / 100 * _destroyFee), address(cd[4]), sub_c41d28c5Address);
                        if not cd[68] / 100:
                            if stor2[stor15] > -1:
                                revert with 0, 17
                            if stor2[stor15] < stor2[stor15]:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, address(cd[4]), uniswapV2PairAddress);
                        else:
                            if cd[68] / 100 and _liquidityFee > -1 / cd[68] / 100:
                                revert with 0, 17
                            if not cd[68] / 100:
                                revert with 0, 18
                            if cd[68] / 100 * _liquidityFee / cd[68] / 100 != _liquidityFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[68] / 100 * _liquidityFee:
                                if stor2[stor15] > -1:
                                    revert with 0, 17
                                if stor2[stor15] < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 * _liquidityFee and stor6 / totalSupply > -1 / cd[68] / 100 * _liquidityFee:
                                    revert with 0, 17
                                if not cd[68] / 100 * _liquidityFee:
                                    revert with 0, 18
                                if cd[68] / 100 * _liquidityFee * stor6 / totalSupply / cd[68] / 100 * _liquidityFee != stor6 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor2[stor15] > !(cd[68] / 100 * _liquidityFee * stor6 / totalSupply):
                                    revert with 0, 17
                                if stor2[stor15] + (cd[68] / 100 * _liquidityFee * stor6 / totalSupply) < stor2[stor15]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[stor15] += cd[68] / 100 * _liquidityFee * stor6 / totalSupply
                            emit Transfer((cd[68] / 100 * _liquidityFee), address(cd[4]), uniswapV2PairAddress);
                        if not cd[68] * stor6 / totalSupply / 100:
                            if not cd[68] / 100:
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 and _taxFee > -1 / cd[68] / 100:
                                    revert with 0, 17
                                if not cd[68] / 100:
                                    revert with 0, 18
                                if cd[68] / 100 * _taxFee / cd[68] / 100 != _taxFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(cd[68] / 100 * _taxFee):
                                    revert with 0, 17
                                if totalFees + (cd[68] / 100 * _taxFee) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += cd[68] / 100 * _taxFee
                        else:
                            if cd[68] * stor6 / totalSupply / 100 and _taxFee > -1 / cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if cd[68] * stor6 / totalSupply / 100 * _taxFee / cd[68] * stor6 / totalSupply / 100 != _taxFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not cd[68] / 100:
                                if cd[68] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < cd[68] * stor6 / totalSupply / 100 * _taxFee:
                                    revert with 0, 17
                                stor6 += -1 * cd[68] * stor6 / totalSupply / 100 * _taxFee
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if cd[68] / 100 and _taxFee > -1 / cd[68] / 100:
                                    revert with 0, 17
                                if not cd[68] / 100:
                                    revert with 0, 18
                                if cd[68] / 100 * _taxFee / cd[68] / 100 != _taxFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if cd[68] * stor6 / totalSupply / 100 * _taxFee > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < cd[68] * stor6 / totalSupply / 100 * _taxFee:
                                    revert with 0, 17
                                stor6 += -1 * cd[68] * stor6 / totalSupply / 100 * _taxFee
                                if totalFees > !(cd[68] / 100 * _taxFee):
                                    revert with 0, 17
                                if totalFees + (cd[68] / 100 * _taxFee) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += cd[68] / 100 * _taxFee
                        if _taxFee > !_liquidityFee:
                            revert with 0, 17
                        if _taxFee + _liquidityFee > !_destroyFee:
                            revert with 0, 17
                        if 100 < _taxFee + _liquidityFee + _destroyFee:
                            revert with 0, 17
                        if not cd[68] * stor6 / totalSupply / 100:
                            if stor2[address(cd[36])] > -1:
                                revert with 0, 17
                            if stor2[address(cd[36])] < stor2[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if cd[68] * stor6 / totalSupply / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 17
                            if not cd[68] * stor6 / totalSupply / 100:
                                revert with 0, 18
                            if (100 * cd[68] * stor6 / totalSupply / 100) - (_taxFee * cd[68] * stor6 / totalSupply / 100) - (_liquidityFee * cd[68] * stor6 / totalSupply / 100) - (_destroyFee * cd[68] * stor6 / totalSupply / 100) / cd[68] * stor6 / totalSupply / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if stor2[address(cd[36])] > !((100 * cd[68] * stor6 / totalSupply / 100) - (_taxFee * cd[68] * stor6 / totalSupply / 100) - (_liquidityFee * cd[68] * stor6 / totalSupply / 100) - (_destroyFee * cd[68] * stor6 / totalSupply / 100)):
                                revert with 0, 17
                            if stor2[address(cd[36])] + (100 * cd[68] * stor6 / totalSupply / 100) - (_taxFee * cd[68] * stor6 / totalSupply / 100) - (_liquidityFee * cd[68] * stor6 / totalSupply / 100) - (_destroyFee * cd[68] * stor6 / totalSupply / 100) < stor2[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(cd[36])] = stor2[address(cd[36])] + (100 * cd[68] * stor6 / totalSupply / 100) - (_taxFee * cd[68] * stor6 / totalSupply / 100) - (_liquidityFee * cd[68] * stor6 / totalSupply / 100) - (_destroyFee * cd[68] * stor6 / totalSupply / 100)
                    if not cd[68] / 100:
                        emit Transfer(0, address(cd[4]), address(cd[36]));
                    else:
                        if cd[68] / 100 and -_taxFee + -_liquidityFee + -_destroyFee + 100 > -1 / cd[68] / 100:
                            revert with 0, 17
                        if not cd[68] / 100:
                            revert with 0, 18
                        if (100 * cd[68] / 100) - (_taxFee * cd[68] / 100) - (_liquidityFee * cd[68] / 100) - (_destroyFee * cd[68] / 100) / cd[68] / 100 != -_taxFee + -_liquidityFee + -_destroyFee + 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        emit Transfer(((100 * cd[68] / 100) - (_taxFee * cd[68] / 100) - (_liquidityFee * cd[68] / 100) - (_destroyFee * cd[68] / 100)), address(cd[4]), address(cd[36]));
                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                        revert with 0, 32, 40, 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[840 len 24] >> 64, 0
            ('le', ('cd', 68), ('stor', ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('cd', 4)), ('name', 'allowance', 3)))))
            if allowance[address(cd[4])][msg.sender] < cd[68]:
                revert with 0, 17
            if not address(cd[4]):
                revert with 0, 'ERC20: approve from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(cd[4])][address(msg.sender)] = allowance[address(cd[4])][msg.sender] - cd[68]
            emit Approval((allowance[address(cd[4])][msg.sender] - cd[68]), address(cd[4]), msg.sender);
    return 1
}



}

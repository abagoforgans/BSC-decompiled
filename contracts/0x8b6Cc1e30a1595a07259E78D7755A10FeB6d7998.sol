contract main {




// =====================  Runtime code  =====================


#
#  - delegateBySig(address arg1, uint256 arg2, uint256 arg3, uint8 arg4, bytes32 arg5, bytes32 arg6)
#
const sub_5f31473d(?) = 0xfa9651a0ecc19906843c13c60443300b9d37355

const deadWallet = 57005

const maxSupply = 100000 * 10^18

const MAXIMUM_TRANSFER_TAX_RATE = 100

const DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866

const DELEGATION_TYPEHASH = 0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf


address owner;
mapping of struct balanceOf;
mapping of uint256 allowance;
uint256 totalSupply;
array of struct stor4;
array of struct stor5;
uint8 decimals;
uint256 stor7;
mapping of uint8 stor8;
address sub_7e2fd586Address;
address sub_dd10546aAddress;
uint256 liquidityFee;
uint256 buybackFee;
uint256 transferTaxRate;
mapping of uint8 stor14;
uint8 stor15;
uint256 minAmountToLiquify;
uint8 stor17;
mapping of address delegates;
mapping of struct checkpoints;
mapping of uint32 numCheckpoints;
mapping of uint256 nonces;

function totalSupply() {
    return totalSupply
}

function decimals() {
    return decimals
}

function buybackFee() {
    return buybackFee
}

function swapAndLiquifyEnabled() {
    return bool(stor15)
}

function isExcludedFromFees(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor14[address(arg1)])
}

function delegates(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return delegates[address(arg1)]
}

function numCheckpoints(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return numCheckpoints[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)].field_0
}

function sub_7e2fd586(?) {
    return sub_7e2fd586Address
}

function nonces(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return nonces[arg1]
}

function getOwner() {
    return owner
}

function owner() {
    return owner
}

function liquidityFee() {
    return liquidityFee
}

function isMinter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    return bool(stor8[address(arg1)])
}

function transferTaxRate() {
    return transferTaxRate
}

function minAmountToLiquify() {
    return minAmountToLiquify
}

function sub_dd10546a(?) {
    return sub_dd10546aAddress
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function checkpoints(address arg1, uint32 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return checkpoints[arg1][arg2].field_0, checkpoints[arg1][arg2].field_256
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateMinAmountToLiquify(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit MinAmountToLiquifyUpdated(minAmountToLiquify, arg1, msg.sender);
    minAmountToLiquify = arg1
}

function updateSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit SwapAndLiquifyEnabledUpdated(arg1, msg.sender);
    stor15 = uint8(arg1)
}

function getCurrentVotes(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not numCheckpoints[address(arg1)]:
        return 0
    if numCheckpoints[address(arg1)] < 1:
        revert with 0, 17
    return checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function renounceMinter() {
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if not stor8[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account does not have role'
    stor8[address(msg.sender)] = 0
    emit MinterRemoved(msg.sender);
}

function setExcludeFromFees(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 == bool(stor14[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH: Account is already the value of 'excluded''
    stor14[address(arg1)] = uint8(arg2)
    emit ExcludeFromFees(arg2, arg1);
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setFees(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    liquidityFee = arg1
    buybackFee = arg2
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 < arg1:
        revert with 0, 'SafeMath: addition overflow'
    transferTaxRate = arg1 + arg2
    if 100 < arg1 + arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH: Total fees can not be bigger than max value'
}

function addMinter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if not stor8[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MinterRole: caller does not have the Minter role'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if stor8[address(arg1)]:
        revert with 0, 'Roles: account already has role'
    stor8[address(arg1)] = 1
    emit MinterAdded(arg1);
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function removeMinter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if not stor8[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MinterRole: caller does not have the Minter role'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if not stor8[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account does not have role'
    stor8[address(arg1)] = 0
    emit MinterRemoved(arg1);
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function burn(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: burn from the zero address'
    if arg1 > balanceOf[address(msg.sender)].field_0:
        revert with 0, 32, 34, 0x6f42455032303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[162 len 30] >> 16, 0
    if balanceOf[address(msg.sender)].field_0 < arg1:
        revert with 0, 17
    balanceOf[address(msg.sender)].field_0 -= arg1
    if arg1 > stor7:
        revert with 0, 'SafeMath: subtraction overflow'
    if stor7 < arg1:
        revert with 0, 17
    stor7 -= arg1
    if arg1 > totalSupply:
        revert with 0, 'SafeMath: subtraction overflow'
    if totalSupply < arg1:
        revert with 0, 17
    totalSupply -= arg1
    emit Transfer(arg1, msg.sender, 0);
    return 1
}

function excludeMultipleAccountsFromFees(address[] arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 14
        stor14[address(cd[((32 * idx) + arg1 + 36)])] = uint8(arg2)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    idx = 0
    s = 192
    t = arg1 + 36
    while idx < arg1.length:
        require cd[t] == address(cd[t])
        mem[s] = address(cd[t])
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    emit ExcludeMultipleAccountsFromFees(Array(len=arg1.length, data=mem[192 len 32 * arg1.length]), arg2);
}

function mint(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not msg.sender:
        revert with 0, 'BEP20: mint to the zero address'
    if stor7 > !arg1:
        revert with 0, 17
    if stor7 + arg1 < stor7:
        revert with 0, 'SafeMath: addition overflow'
    if stor7 + arg1 > 100000 * 10^18:
        revert with 0, 'Max supply reached'
    if totalSupply > !arg1:
        revert with 0, 17
    if totalSupply + arg1 < totalSupply:
        revert with 0, 'SafeMath: addition overflow'
    totalSupply += arg1
    if stor7 > !arg1:
        revert with 0, 17
    if stor7 + arg1 < stor7:
        revert with 0, 'SafeMath: addition overflow'
    stor7 += arg1
    if balanceOf[address(msg.sender)].field_0 > !arg1:
        revert with 0, 17
    if balanceOf[address(msg.sender)].field_0 + arg1 < balanceOf[address(msg.sender)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(msg.sender)].field_0 += arg1
    emit Transfer(arg1, 0, msg.sender);
    return 1
}

function sub_13cf87ed(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_7e2fd586Address = address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(sub_7e2fd586Address)
    staticcall sub_7e2fd586Address.WETH() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    sub_dd10546aAddress = ext_call.return_data[12 len 20]
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'XSH::updateXHASHSwapRouter: Invalid pair address.'
    emit 0x719e7f6c: address(arg1), sub_7e2fd586Address, sub_dd10546aAddress
}

function withdrawBNB(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if eth.balance(this.address) > arg2:
        if eth.balance(this.address) < arg2:
            revert with 0, 'Address: insufficient balance'
        call arg1 with:
           value arg2 wei
             gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'Address: unable to send value, recipient may have reverted'
        else:
            if not ext_call.success:
                revert with 0, 'Address: unable to send value, recipient may have reverted'
        ('bool', 'ext_call.success')
        emit 0x7d1ee786: arg2, msg.sender, arg1
    else:
        if eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'Address: insufficient balance'
        call arg1 with:
           value eth.balance(this.address) wei
             gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'Address: unable to send value, recipient may have reverted'
        else:
            if not ext_call.success:
                revert with 0, 'Address: unable to send value, recipient may have reverted'
        ('bool', 'ext_call.success')
        emit 0x7d1ee786: eth.balance(this.address), msg.sender, arg1
}

function getPriorVotes(address arg1, uint256 arg2) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 >= block.number:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH::getPriorVotes: not yet determined'
    if not numCheckpoints[address(arg1)]:
        return 0
    if numCheckpoints[address(arg1)] < 1:
        revert with 0, 17
    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 <= arg2:
        if numCheckpoints[address(arg1)] < 1:
            revert with 0, 17
        return checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256
    if arg2 < checkpoints[address(arg1)][0].field_0:
        return 0
    if numCheckpoints[address(arg1)] < 1:
        revert with 0, 17
    idx = 0
    while uint32(numCheckpoints[address(arg1)] - 1) > uint32(idx):
        if uint32(numCheckpoints[address(arg1)] - 1) < uint32(idx):
            revert with 0, 17
        if uint32(numCheckpoints[address(arg1)] - 1) < uint32(uint32(numCheckpoints[address(arg1)] - 1) - uint32(idx)) / 2:
            revert with 0, 17
        mem[0] = uint32(uint32(numCheckpoints[address(arg1)] - 1) - (uint32(uint32(numCheckpoints[address(arg1)] - 1) - uint32(idx)) / 2))
        mem[32] = sha3(address(arg1), 19)
        _33 = mem[64]
        mem[64] = mem[64] + 64
        mem[_33] = checkpoints[address(arg1)][uint32(stor20[address(arg1)] - 1) - (uint32(uint32(stor20[address(arg1)] - 1) - uint32(idx)) / 2) << 224].field_0
        mem[_33 + 32] = checkpoints[address(arg1)][uint32(stor20[address(arg1)] - 1) - (uint32(uint32(stor20[address(arg1)] - 1) - uint32(idx)) / 2) << 224].field_256
        if arg2 == checkpoints[address(arg1)][uint32(stor20[address(arg1)] - 1) - (uint32(uint32(stor20[address(arg1)] - 1) - uint32(idx)) / 2) << 224].field_0:
            return checkpoints[address(arg1)][uint32(stor20[address(arg1)] - 1) - (uint32(uint32(stor20[address(arg1)] - 1) - uint32(idx)) / 2) << 224].field_256
        if arg2 > checkpoints[address(arg1)][uint32(stor20[address(arg1)] - 1) - (uint32(uint32(stor20[address(arg1)] - 1) - uint32(idx)) / 2) << 224].field_0:
            idx = uint32(numCheckpoints[address(arg1)] - 1) - (uint32(uint32(numCheckpoints[address(arg1)] - 1) - uint32(idx)) / 2)
            continue 
        if uint32(uint32(numCheckpoints[address(arg1)] - 1) - (uint32(uint32(numCheckpoints[address(arg1)] - 1) - uint32(idx)) / 2)) < 1:
            revert with 0, 17
        idx = idx
        continue 
    return checkpoints[address(arg1)][idx << 224].field_256
}

function name() {
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor4.length):
            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor4.length):
                if 31 < uint255(stor4.length) * 0.5:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor4.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        else:
            if bool(stor4.length) == stor4.length.field_1 < 32:
                revert with 0, 34
            if stor4.length.field_1:
                if 31 < stor4.length.field_1:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while stor4.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        mem[ceil32(uint255(stor4.length) * 0.5) + 192 len ceil32(uint255(stor4.length) * 0.5)] = mem[128 len ceil32(uint255(stor4.length) * 0.5)]
        if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
            mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
    if bool(stor4.length) == stor4.length.field_1 < 32:
        revert with 0, 34
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor4.length):
            if 31 < uint255(stor4.length) * 0.5:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while (uint255(stor4.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    else:
        if bool(stor4.length) == stor4.length.field_1 < 32:
            revert with 0, 34
        if stor4.length.field_1:
            if 31 < stor4.length.field_1:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while stor4.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]
    if ceil32(stor4.length.field_1) > stor4.length.field_1:
        mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0
    return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), 
}

function symbol() {
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor5.length):
            if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor5.length):
                if 31 < uint255(stor5.length) * 0.5:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor5.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor5[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * stor5.length.field_8
        else:
            if bool(stor5.length) == stor5.length.field_1 < 32:
                revert with 0, 34
            if stor5.length.field_1:
                if 31 < stor5.length.field_1:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while stor5.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor5[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * stor5.length.field_8
        mem[ceil32(uint255(stor5.length) * 0.5) + 192 len ceil32(uint255(stor5.length) * 0.5)] = mem[128 len ceil32(uint255(stor5.length) * 0.5)]
        if ceil32(uint255(stor5.length) * 0.5) > uint255(stor5.length) * 0.5:
            mem[ceil32(uint255(stor5.length) * 0.5) + (uint255(stor5.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)], mem[(2 * ceil32(uint255(stor5.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor5.length) * 0.5)]), 
    if bool(stor5.length) == stor5.length.field_1 < 32:
        revert with 0, 34
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor5.length):
            if 31 < uint255(stor5.length) * 0.5:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while (uint255(stor5.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor5[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])
            mem[128] = 256 * stor5.length.field_8
    else:
        if bool(stor5.length) == stor5.length.field_1 < 32:
            revert with 0, 34
        if stor5.length.field_1:
            if 31 < stor5.length.field_1:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while stor5.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor5[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])
            mem[128] = 256 * stor5.length.field_8
    mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]
    if ceil32(stor5.length.field_1) > stor5.length.field_1:
        mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0
    return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), 
}

function mint(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Roles: account is the zero address'
    if not stor8[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MinterRole: caller does not have the Minter role'
    if not arg1:
        revert with 0, 'BEP20: mint to the zero address'
    if stor7 > !arg2:
        revert with 0, 17
    if stor7 + arg2 < stor7:
        revert with 0, 'SafeMath: addition overflow'
    if stor7 + arg2 > 100000 * 10^18:
        revert with 0, 'Max supply reached'
    if totalSupply > !arg2:
        revert with 0, 17
    if totalSupply + arg2 < totalSupply:
        revert with 0, 'SafeMath: addition overflow'
    totalSupply += arg2
    if stor7 > !arg2:
        revert with 0, 17
    if stor7 + arg2 < stor7:
        revert with 0, 'SafeMath: addition overflow'
    stor7 += arg2
    if balanceOf[address(arg1)].field_0 > !arg2:
        revert with 0, 17
    if balanceOf[address(arg1)].field_0 + arg2 < balanceOf[address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg1)].field_0 += arg2
    emit Transfer(arg2, 0, arg1);
    if delegates[address(arg1)] != 0:
        if arg2 > 0:
            if delegates[address(arg1)]:
                if not numCheckpoints[stor18[address(arg1)]]:
                    if 0 > !arg2:
                        revert with 0, 17
                    if arg2 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if block.number >= 4294967296:
                        revert with 0, 
                                    32,
                                    51,
                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                    0
                    if numCheckpoints[stor18[address(arg1)]] <= 0:
                        checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_0 = uint32(block.number)
                        checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_256 = arg2
                        if 1 > -numCheckpoints[stor18[address(arg1)]] + test266151307():
                            revert with 0, 17
                        numCheckpoints[stor18[address(arg1)]] = uint32(numCheckpoints[stor18[address(arg1)]] + 1)
                    else:
                        if numCheckpoints[stor18[address(arg1)]] < 1:
                            revert with 0, 17
                        if checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_0 == uint32(block.number):
                            if numCheckpoints[stor18[address(arg1)]] < 1:
                                revert with 0, 17
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 = arg2
                        else:
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_0 = uint32(block.number)
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_256 = arg2
                            if 1 > -numCheckpoints[stor18[address(arg1)]] + test266151307():
                                revert with 0, 17
                            numCheckpoints[stor18[address(arg1)]] = uint32(numCheckpoints[stor18[address(arg1)]] + 1)
                    emit DelegateVotesChanged(0, arg2, delegates[address(arg1)]);
                else:
                    if numCheckpoints[stor18[address(arg1)]] < 1:
                        revert with 0, 17
                    if checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 > !arg2:
                        revert with 0, 17
                    if checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 + arg2 < checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    if block.number >= 4294967296:
                        revert with 0, 
                                    32,
                                    51,
                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                    0
                    if numCheckpoints[stor18[address(arg1)]] <= 0:
                        checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_0 = uint32(block.number)
                        checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_256 = checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 + arg2
                        if 1 > -numCheckpoints[stor18[address(arg1)]] + test266151307():
                            revert with 0, 17
                        numCheckpoints[stor18[address(arg1)]] = uint32(numCheckpoints[stor18[address(arg1)]] + 1)
                    else:
                        if numCheckpoints[stor18[address(arg1)]] < 1:
                            revert with 0, 17
                        if checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_0 == uint32(block.number):
                            if numCheckpoints[stor18[address(arg1)]] < 1:
                                revert with 0, 17
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 += arg2
                        else:
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_0 = uint32(block.number)
                            checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]]].field_256 = checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 + arg2
                            if 1 > -numCheckpoints[stor18[address(arg1)]] + test266151307():
                                revert with 0, 17
                            numCheckpoints[stor18[address(arg1)]] = uint32(numCheckpoints[stor18[address(arg1)]] + 1)
                    emit DelegateVotesChanged(checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256, checkpoints[stor18[address(arg1)]][stor20[stor18[address(arg1)]] - 1 << 224].field_256 + arg2, delegates[address(arg1)]);
}

function delegate(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    delegates[address(msg.sender)] = arg1
    emit DelegateChanged(msg.sender, delegates[address(msg.sender)], arg1);
    if delegates[address(msg.sender)] != arg1:
        if balanceOf[address(msg.sender)].field_0 > 0:
            if not delegates[address(msg.sender)]:
                if arg1:
                    if not numCheckpoints[address(arg1)]:
                        if 0 > !balanceOf[address(msg.sender)].field_0:
                            revert with 0, 17
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if block.number >= 4294967296:
                            revert with 0, 
                                        32,
                                        51,
                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                        0
                        if numCheckpoints[address(arg1)] <= 0:
                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                revert with 0, 17
                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                        else:
                            if numCheckpoints[address(arg1)] < 1:
                                revert with 0, 17
                            if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                if numCheckpoints[address(arg1)] < 1:
                                    revert with 0, 17
                                checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                            else:
                                checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                    revert with 0, 17
                                numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                        emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                    else:
                        if numCheckpoints[address(arg1)] < 1:
                            revert with 0, 17
                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                            revert with 0, 17
                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if block.number >= 4294967296:
                            revert with 0, 
                                        32,
                                        51,
                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                        0
                        if numCheckpoints[address(arg1)] <= 0:
                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                revert with 0, 17
                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                        else:
                            if numCheckpoints[address(arg1)] < 1:
                                revert with 0, 17
                            if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                if numCheckpoints[address(arg1)] < 1:
                                    revert with 0, 17
                                checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                            else:
                                checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                    revert with 0, 17
                                numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                        emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
            else:
                if not numCheckpoints[stor18[address(msg.sender)]]:
                    if balanceOf[address(msg.sender)].field_0 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 < balanceOf[address(msg.sender)].field_0:
                        revert with 0, 17
                    if block.number >= 4294967296:
                        revert with 0, 
                                    32,
                                    51,
                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                    0
                    if numCheckpoints[stor18[address(msg.sender)]] <= 0:
                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = -balanceOf[address(msg.sender)].field_0
                        if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                            revert with 0, 17
                        numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                        emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                        if arg1:
                            if not numCheckpoints[address(arg1)]:
                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if balanceOf[address(msg.sender)].field_0 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                0
                                if numCheckpoints[address(arg1)] <= 0:
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                    else:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                            else:
                                if numCheckpoints[address(arg1)] < 1:
                                    revert with 0, 17
                                if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                0
                                if numCheckpoints[address(arg1)] <= 0:
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                    else:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
                    else:
                        if numCheckpoints[stor18[address(msg.sender)]] < 1:
                            revert with 0, 17
                        if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_0 == uint32(block.number):
                            if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                revert with 0, 17
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 = -balanceOf[address(msg.sender)].field_0
                            emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                            if arg1:
                                if not numCheckpoints[address(arg1)]:
                                    if 0 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[275 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[275 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
                        else:
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = -balanceOf[address(msg.sender)].field_0
                            if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                revert with 0, 17
                            numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                            emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                            if arg1:
                                if not numCheckpoints[address(arg1)]:
                                    if 0 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
                else:
                    if numCheckpoints[stor18[address(msg.sender)]] < 1:
                        revert with 0, 17
                    if balanceOf[address(msg.sender)].field_0 > checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 < balanceOf[address(msg.sender)].field_0:
                        revert with 0, 17
                    if block.number >= 4294967296:
                        revert with 0, 
                                    32,
                                    51,
                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[179 len 13] >> 152,
                                    0
                    if numCheckpoints[stor18[address(msg.sender)]] <= 0:
                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0
                        if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                            revert with 0, 17
                        numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                        emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                        if arg1:
                            if not numCheckpoints[address(arg1)]:
                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if balanceOf[address(msg.sender)].field_0 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                0
                                if numCheckpoints[address(arg1)] <= 0:
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                    else:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                            else:
                                if numCheckpoints[address(arg1)] < 1:
                                    revert with 0, 17
                                if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                0
                                if numCheckpoints[address(arg1)] <= 0:
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                    checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                    else:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
                    else:
                        if numCheckpoints[stor18[address(msg.sender)]] < 1:
                            revert with 0, 17
                        if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_0 == uint32(block.number):
                            if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                revert with 0, 17
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 -= balanceOf[address(msg.sender)].field_0
                            emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                            if arg1:
                                if not numCheckpoints[address(arg1)]:
                                    if 0 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[275 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[275 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
                        else:
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                            checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0
                            if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                revert with 0, 17
                            numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                            emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                            if arg1:
                                if not numCheckpoints[address(arg1)]:
                                    if 0 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, arg1);
                                else:
                                    if numCheckpoints[address(arg1)] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[339 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(arg1)] <= 0:
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                        checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    else:
                                        if numCheckpoints[address(arg1)] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(arg1)] < 1:
                                                revert with 0, 17
                                            checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_0 = uint32(block.number)
                                            checkpoints[address(arg1)][stor20[address(arg1)]].field_256 = checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(arg1)] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(arg1)] = uint32(numCheckpoints[address(arg1)] + 1)
                                    emit DelegateVotesChanged(checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256, checkpoints[address(arg1)][stor20[address(arg1)] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, arg1);
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if bool(stor15) != 1:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if stor17:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if not sub_7e2fd586Address:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if not sub_dd10546aAddress:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if sub_dd10546aAddress == msg.sender:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if owner == msg.sender:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if owner == arg1:
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    stor17 = 1
    transferTaxRate = 0
    if liquidityFee > !buybackFee:
        revert with 0, 17
    if liquidityFee + buybackFee < liquidityFee:
        revert with 0, 'SafeMath: addition overflow'
    if balanceOf[address(this.address)].field_0 < minAmountToLiquify:
        stor17 = 0
        if not transferTaxRate:
            if not msg.sender:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg2 > balanceOf[address(msg.sender)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(msg.sender)].field_0 < arg2:
                revert with 0, 17
            balanceOf[address(msg.sender)].field_0 -= arg2
            if balanceOf[arg1].field_0 > !arg2:
                revert with 0, 17
            if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
        else:
            if stor14[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)].field_0 < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)].field_0 -= arg2
                if balanceOf[arg1].field_0 > !arg2:
                    revert with 0, 17
                if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)].field_0 < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= arg2
                    if balanceOf[arg1].field_0 > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if not arg2:
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < 0:
                            revert with 0, 17
                        if 0 > !arg2:
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2
                        if balanceOf[arg1].field_0 > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 and transferTaxRate > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * transferTaxRate / arg2 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg2 * transferTaxRate / 1000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg2 != arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg1:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
                        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) < balanceOf[arg1].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
                        emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
        return 1
    if not minAmountToLiquify:
        if liquidityFee + buybackFee <= 0:
            revert with 0, 'SafeMath: division by zero'
        if not liquidityFee + buybackFee:
            revert with 0, 18
        mem[96] = 3
        mem[128] = this.address
        require ext_code.size(sub_7e2fd586Address)
        staticcall sub_7e2fd586Address.WETH() with:
                gas gas_remaining wei
        mem[224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[160] = ext_call.return_data[12 len 20]
        mem[192] = 0xfa9651a0ecc19906843c13c60443300b9d37355
        if not this.address:
            revert with 0, 'BEP20: approve from the zero address'
        if not sub_7e2fd586Address:
            revert with 0, 'BEP20: approve to the zero address'
        allowance[address(this.address)][stor9] = 0 / liquidityFee + buybackFee
        emit Approval((0 / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
        if block.timestamp > -301:
            revert with 0, 17
        if block.timestamp + 300 < block.timestamp:
            revert with 0, 'SafeMath: addition overflow'
        mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 228] = 0 / liquidityFee + buybackFee
        mem[ceil32(return_data.size) + 388] = 3
        idx = 0
        s = ceil32(return_data.size) + 420
        t = 128
        while idx < 3:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(return_data.size) + 324] = 57005
        mem[ceil32(return_data.size) + 356] = block.timestamp + 300
        require ext_code.size(sub_7e2fd586Address)
        call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args 0 / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 420 len 96]
    else:
        if minAmountToLiquify and buybackFee > -1 / minAmountToLiquify:
            revert with 0, 17
        if not minAmountToLiquify:
            revert with 0, 18
        if minAmountToLiquify * buybackFee / minAmountToLiquify != buybackFee:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if liquidityFee + buybackFee <= 0:
            revert with 0, 'SafeMath: division by zero'
        if not liquidityFee + buybackFee:
            revert with 0, 18
        mem[96] = 3
        mem[128] = this.address
        require ext_code.size(sub_7e2fd586Address)
        staticcall sub_7e2fd586Address.WETH() with:
                gas gas_remaining wei
        mem[224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[160] = ext_call.return_data[12 len 20]
        mem[192] = 0xfa9651a0ecc19906843c13c60443300b9d37355
        if not this.address:
            revert with 0, 'BEP20: approve from the zero address'
        if not sub_7e2fd586Address:
            revert with 0, 'BEP20: approve to the zero address'
        allowance[address(this.address)][stor9] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
        emit Approval((minAmountToLiquify * buybackFee / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
        if block.timestamp > -301:
            revert with 0, 17
        if block.timestamp + 300 < block.timestamp:
            revert with 0, 'SafeMath: addition overflow'
        mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 228] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
        mem[ceil32(return_data.size) + 388] = 3
        idx = 0
        s = ceil32(return_data.size) + 420
        t = 128
        while idx < 3:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(return_data.size) + 324] = 57005
        mem[ceil32(return_data.size) + 356] = block.timestamp + 300
        require ext_code.size(sub_7e2fd586Address)
        call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args minAmountToLiquify * buybackFee / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 420 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
        revert with 0, 'SafeMath: subtraction overflow'
    if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
        revert with 0, 17
    mem[ceil32(return_data.size) + 224] = 2
    mem[ceil32(return_data.size) + 256] = this.address
    require ext_code.size(sub_7e2fd586Address)
    staticcall sub_7e2fd586Address.WETH() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 320
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[12 len 20]
    if not this.address:
        revert with 0, 'BEP20: approve from the zero address'
    if not sub_7e2fd586Address:
        revert with 0, 'BEP20: approve to the zero address'
    mem[0] = sub_7e2fd586Address
    mem[32] = sha3(address(this.address), 2)
    allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
    emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
    mem[(2 * ceil32(return_data.size)) + 320] = 0x791ac94700000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 324] = balanceOf[this.address].field_1
    mem[(2 * ceil32(return_data.size)) + 356] = 0
    mem[(2 * ceil32(return_data.size)) + 388] = 160
    mem[(2 * ceil32(return_data.size)) + 484] = 2
    idx = 0
    s = (2 * ceil32(return_data.size)) + 516
    t = ceil32(return_data.size) + 256
    while idx < mem[ceil32(return_data.size) + 224]:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 420] = this.address
    mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
    require ext_code.size(sub_7e2fd586Address)
    call sub_7e2fd586Address.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args 2 * Mask(256, -1, balanceOf[this.address].field_1), 0, 160, address(this.address), block.timestamp, mem[(2 * ceil32(return_data.size)) + 484 len (32 * mem[ceil32(return_data.size) + 224]) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if eth.balance(this.address) > eth.balance(this.address):
        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 324] = 32
        mem[(2 * ceil32(return_data.size)) + 356] = 30
        mem[(2 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
        revert with memory
          from (2 * ceil32(return_data.size)) + 320
           len ceil32(return_data.size) + 100
    if eth.balance(this.address) < eth.balance(this.address):
        revert with 0, 17
    if not this.address:
        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 324] = 32
        mem[(2 * ceil32(return_data.size)) + 356] = 36
        mem[(2 * ceil32(return_data.size)) + 388] = 'BEP20: approve from the zero add'
        mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
        revert with memory
          from (2 * ceil32(return_data.size)) + 320
           len ceil32(return_data.size) + 132
    if not sub_7e2fd586Address:
        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 324] = 32
        mem[(2 * ceil32(return_data.size)) + 356] = 34
        mem[(2 * ceil32(return_data.size)) + 388] = 'BEP20: approve to the zero addre'
        mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
        revert with memory
          from (2 * ceil32(return_data.size)) + 320
           len ceil32(return_data.size) + 132
    allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
    emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
    mem[(2 * ceil32(return_data.size)) + 324] = this.address
    mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
    mem[(2 * ceil32(return_data.size)) + 388] = 0
    mem[(2 * ceil32(return_data.size)) + 420] = 0
    mem[(2 * ceil32(return_data.size)) + 452] = this.address
    mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
    require ext_code.size(sub_7e2fd586Address)
    call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
         gas gas_remaining wei
        args mem[(2 * ceil32(return_data.size)) + 324 len ceil32(return_data.size) + 192]
    mem[(2 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[64] > 0
    mem[(4 * ceil32(return_data.size)) + 320] = balanceOf[this.address].field_1
    mem[(4 * ceil32(return_data.size)) + 352] = 0
    mem[(4 * ceil32(return_data.size)) + 384] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                        mem[(4 * ceil32(return_data.size)) + 320 len (5 * ceil32(return_data.size)) + 96],
    stor17 = 0
    if not transferTaxRate:
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 37
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not arg1:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 35
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if arg2 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 38
            mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
            mem[(4 * ceil32(return_data.size)) + 522] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2:
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 -= arg2
        if balanceOf[arg1].field_0 > !arg2:
            revert with 0, 17
        if balanceOf[arg1].field_0 + arg2 >= balanceOf[arg1].field_0:
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
            return 1
        mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(4 * ceil32(return_data.size)) + 420] = 32
        mem[(4 * ceil32(return_data.size)) + 452] = 27
        mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
        revert with memory
          from (4 * ceil32(return_data.size)) + 416
           len (5 * ceil32(return_data.size)) + 100
    if stor14[address(msg.sender)]:
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 37
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not arg1:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 35
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if arg2 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 38
            mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
            mem[(4 * ceil32(return_data.size)) + 522] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2:
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 -= arg2
        if balanceOf[arg1].field_0 > !arg2:
            revert with 0, 17
        if balanceOf[arg1].field_0 + arg2 >= balanceOf[arg1].field_0:
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
            return 1
        mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(4 * ceil32(return_data.size)) + 420] = 32
        mem[(4 * ceil32(return_data.size)) + 452] = 27
        mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
        revert with memory
          from (4 * ceil32(return_data.size)) + 416
           len (5 * ceil32(return_data.size)) + 100
    if stor14[address(arg1)]:
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 37
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not arg1:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 35
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if arg2 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 38
            mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
            mem[(4 * ceil32(return_data.size)) + 522] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2:
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 -= arg2
        if balanceOf[arg1].field_0 > !arg2:
            revert with 0, 17
        if balanceOf[arg1].field_0 + arg2 >= balanceOf[arg1].field_0:
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
            return 1
        mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(4 * ceil32(return_data.size)) + 420] = 32
        mem[(4 * ceil32(return_data.size)) + 452] = 27
        mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
        revert with memory
          from (4 * ceil32(return_data.size)) + 416
           len (5 * ceil32(return_data.size)) + 100
    if not arg2:
        if 0 > arg2:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 30
            mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 100
        if arg2 < 0:
            revert with 0, 17
        if 0 > !arg2:
            revert with 0, 17
        if arg2 != arg2:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 33
            mem[(4 * ceil32(return_data.size)) + 388] = 'XSH:: transfer: Tax value invali'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6400000000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 37
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not this.address:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 35
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if 0 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 38
            mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
            mem[(4 * ceil32(return_data.size)) + 522] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < 0:
            revert with 0, 17
        if balanceOf[this.address].field_0 > -1:
            revert with 0, 17
        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 27
            mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 100
        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
        emit Transfer(0, msg.sender, this.address);
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 37
            mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if not arg1:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 35
            mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if arg2 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 516] = 32
            mem[(4 * ceil32(return_data.size)) + 548] = 38
            mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 486 len 26]
            mem[(4 * ceil32(return_data.size)) + 618] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 512
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2:
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 -= arg2
        if balanceOf[arg1].field_0 > !arg2:
            revert with 0, 17
        if balanceOf[arg1].field_0 + arg2 >= balanceOf[arg1].field_0:
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2
            emit Transfer(arg2, msg.sender, arg1);
            return 1
    else:
        if arg2 and transferTaxRate > -1 / arg2:
            revert with 0, 17
        if not arg2:
            revert with 0, 18
        if arg2 * transferTaxRate / arg2 != transferTaxRate:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 33
            mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: multiplication overflo'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x7700000000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if arg2 * transferTaxRate / 1000 > arg2:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 30
            mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 100
        if arg2 < arg2 * transferTaxRate / 1000:
            revert with 0, 17
        if arg2 * transferTaxRate / 1000 > !(arg2 - (arg2 * transferTaxRate / 1000)):
            revert with 0, 17
        if arg2 != arg2:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 33
            mem[(4 * ceil32(return_data.size)) + 388] = 'XSH:: transfer: Tax value invali'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6400000000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 37
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if not this.address:
            mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 324] = 32
            mem[(4 * ceil32(return_data.size)) + 356] = 35
            mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 320
               len (5 * ceil32(return_data.size)) + 132
        if arg2 * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 38
            mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
            mem[(4 * ceil32(return_data.size)) + 522] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2 * transferTaxRate / 1000:
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 -= arg2 * transferTaxRate / 1000
        if balanceOf[this.address].field_0 > !(arg2 * transferTaxRate / 1000):
            revert with 0, 17
        if balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 27
            mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 100
        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg2 * transferTaxRate / 1000)
        emit Transfer((arg2 * transferTaxRate / 1000), msg.sender, this.address);
        if not msg.sender:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 37
            mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer from the zero ad'
            mem[(4 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if not arg1:
            mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 420] = 32
            mem[(4 * ceil32(return_data.size)) + 452] = 35
            mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer to the zero addr'
            mem[(4 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
            revert with memory
              from (4 * ceil32(return_data.size)) + 416
               len (5 * ceil32(return_data.size)) + 132
        if arg2 - (arg2 * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
            mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 516] = 32
            mem[(4 * ceil32(return_data.size)) + 548] = 38
            mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 486 len 26]
            mem[(4 * ceil32(return_data.size)) + 618] = 0
            revert with memory
              from (4 * ceil32(return_data.size)) + 512
               len (5 * ceil32(return_data.size)) + 132
        if balanceOf[address(msg.sender)].field_0 < arg2 - (arg2 * transferTaxRate / 1000):
            revert with 0, 17
        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - arg2 + (arg2 * transferTaxRate / 1000)
        if balanceOf[arg1].field_0 > !(arg2 - (arg2 * transferTaxRate / 1000)):
            revert with 0, 17
        if balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000) >= balanceOf[arg1].field_0:
            balanceOf[address(arg1)].field_0 = balanceOf[arg1].field_0 + arg2 - (arg2 * transferTaxRate / 1000)
            emit Transfer((arg2 - (arg2 * transferTaxRate / 1000)), msg.sender, arg1);
            return 1
    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[(4 * ceil32(return_data.size)) + 516] = 32
    mem[(4 * ceil32(return_data.size)) + 548] = 27
    mem[(4 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
    revert with memory
      from (4 * ceil32(return_data.size)) + 512
       len (5 * ceil32(return_data.size)) + 100
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if bool(stor15) != 1:
        if not transferTaxRate:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
            if arg3 > balanceOf[address(arg1)].field_0:
                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
            if balanceOf[address(arg1)].field_0 < arg3:
                revert with 0, 17
            balanceOf[address(arg1)].field_0 -= arg3
            if balanceOf[arg2].field_0 > !arg3:
                revert with 0, 17
            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
            emit Transfer(arg3, arg1, arg2);
            if arg3 > allowance[address(arg1)][msg.sender]:
                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
        else:
            if stor14[address(arg1)]:
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg2:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg3 > balanceOf[address(arg1)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(arg1)].field_0 < arg3:
                    revert with 0, 17
                balanceOf[address(arg1)].field_0 -= arg3
                if balanceOf[arg2].field_0 > !arg3:
                    revert with 0, 17
                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                emit Transfer(arg3, arg1, arg2);
                if arg3 > allowance[address(arg1)][msg.sender]:
                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
            else:
                if stor14[address(arg2)]:
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg2:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg3 > balanceOf[address(arg1)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(arg1)].field_0 < arg3:
                        revert with 0, 17
                    balanceOf[address(arg1)].field_0 -= arg3
                    if balanceOf[arg2].field_0 > !arg3:
                        revert with 0, 17
                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                    emit Transfer(arg3, arg1, arg2);
                    if arg3 > allowance[address(arg1)][msg.sender]:
                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                else:
                    if not arg3:
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg3 < 0:
                            revert with 0, 17
                        if 0 > !arg3:
                            revert with 0, 17
                        if arg3 != arg3:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if 0 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < 0:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 > -1:
                            revert with 0, 17
                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                        emit Transfer(0, arg1, this.address);
                        if not arg1:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg2:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg3 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3:
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 -= arg3
                        if balanceOf[arg2].field_0 > !arg3:
                            revert with 0, 17
                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                        emit Transfer(arg3, arg1, arg2);
                    else:
                        if arg3 and transferTaxRate > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * transferTaxRate / arg3 != transferTaxRate:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                        if arg3 * transferTaxRate / 1000 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg3 < arg3 * transferTaxRate / 1000:
                            revert with 0, 17
                        if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if arg3 != arg3:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not this.address:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                        if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                            revert with 0, 17
                        if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                        emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                        if not arg1:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not arg2:
                            revert with 0, 'BEP20: transfer to the zero address'
                        if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                        if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                            revert with 0, 17
                        if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                        emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                    if arg3 > allowance[address(arg1)][msg.sender]:
                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
    else:
        if stor17:
            if not transferTaxRate:
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                if not arg2:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                if arg3 > balanceOf[address(arg1)].field_0:
                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(arg1)].field_0 < arg3:
                    revert with 0, 17
                balanceOf[address(arg1)].field_0 -= arg3
                if balanceOf[arg2].field_0 > !arg3:
                    revert with 0, 17
                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                emit Transfer(arg3, arg1, arg2);
                if arg3 > allowance[address(arg1)][msg.sender]:
                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
            else:
                if stor14[address(arg1)]:
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg2:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg3 > balanceOf[address(arg1)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(arg1)].field_0 < arg3:
                        revert with 0, 17
                    balanceOf[address(arg1)].field_0 -= arg3
                    if balanceOf[arg2].field_0 > !arg3:
                        revert with 0, 17
                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                    emit Transfer(arg3, arg1, arg2);
                    if arg3 > allowance[address(arg1)][msg.sender]:
                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                else:
                    if stor14[address(arg2)]:
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg3 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3:
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 -= arg3
                        if balanceOf[arg2].field_0 > !arg3:
                            revert with 0, 17
                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                        emit Transfer(arg3, arg1, arg2);
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                    else:
                        if not arg3:
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg3 < 0:
                                revert with 0, 17
                            if 0 > !arg3:
                                revert with 0, 17
                            if arg3 != arg3:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                            if not this.address:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                            if 0 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < 0:
                                revert with 0, 17
                            if balanceOf[this.address].field_0 > -1:
                                revert with 0, 17
                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                            emit Transfer(0, arg1, this.address);
                            if not arg1:
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not arg2:
                                revert with 0, 'BEP20: transfer to the zero address'
                            if arg3 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3:
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 -= arg3
                            if balanceOf[arg2].field_0 > !arg3:
                                revert with 0, 17
                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                            emit Transfer(arg3, arg1, arg2);
                        else:
                            if arg3 and transferTaxRate > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if arg3 * transferTaxRate / 1000 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg3 < arg3 * transferTaxRate / 1000:
                                revert with 0, 17
                            if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                revert with 0, 17
                            if arg3 != arg3:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                            if not this.address:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                            if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                            if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                revert with 0, 17
                            if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                            emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                            if not arg1:
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not arg2:
                                revert with 0, 'BEP20: transfer to the zero address'
                            if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                            if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                revert with 0, 17
                            if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                            emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
        else:
            if not sub_7e2fd586Address:
                if not transferTaxRate:
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                    if not arg2:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                    if arg3 > balanceOf[address(arg1)].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(arg1)].field_0 < arg3:
                        revert with 0, 17
                    balanceOf[address(arg1)].field_0 -= arg3
                    if balanceOf[arg2].field_0 > !arg3:
                        revert with 0, 17
                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                    emit Transfer(arg3, arg1, arg2);
                    if arg3 > allowance[address(arg1)][msg.sender]:
                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                else:
                    if stor14[address(arg1)]:
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg3 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3:
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 -= arg3
                        if balanceOf[arg2].field_0 > !arg3:
                            revert with 0, 17
                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                        emit Transfer(arg3, arg1, arg2);
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                    else:
                        if stor14[address(arg2)]:
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                            if not arg2:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                            if arg3 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3:
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 -= arg3
                            if balanceOf[arg2].field_0 > !arg3:
                                revert with 0, 17
                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                            emit Transfer(arg3, arg1, arg2);
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                        else:
                            if not arg3:
                                if 0 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg3 < 0:
                                    revert with 0, 17
                                if 0 > !arg3:
                                    revert with 0, 17
                                if arg3 != arg3:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                if not this.address:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                if 0 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < 0:
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 > -1:
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                emit Transfer(0, arg1, this.address);
                                if not arg1:
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not arg2:
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if arg3 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3:
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 -= arg3
                                if balanceOf[arg2].field_0 > !arg3:
                                    revert with 0, 17
                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                emit Transfer(arg3, arg1, arg2);
                            else:
                                if arg3 and transferTaxRate > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if arg3 * transferTaxRate / 1000 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg3 < arg3 * transferTaxRate / 1000:
                                    revert with 0, 17
                                if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                    revert with 0, 17
                                if arg3 != arg3:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                if not this.address:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                if not arg1:
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not arg2:
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                    revert with 0, 17
                                if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
            else:
                if not sub_dd10546aAddress:
                    if not transferTaxRate:
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                        if not arg2:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                        if arg3 > balanceOf[address(arg1)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(arg1)].field_0 < arg3:
                            revert with 0, 17
                        balanceOf[address(arg1)].field_0 -= arg3
                        if balanceOf[arg2].field_0 > !arg3:
                            revert with 0, 17
                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                        emit Transfer(arg3, arg1, arg2);
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                    else:
                        if stor14[address(arg1)]:
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                            if not arg2:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                            if arg3 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3:
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 -= arg3
                            if balanceOf[arg2].field_0 > !arg3:
                                revert with 0, 17
                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                            emit Transfer(arg3, arg1, arg2);
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                        else:
                            if stor14[address(arg2)]:
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                if not arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                if arg3 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3:
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 -= arg3
                                if balanceOf[arg2].field_0 > !arg3:
                                    revert with 0, 17
                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                emit Transfer(arg3, arg1, arg2);
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                            else:
                                if not arg3:
                                    if 0 > arg3:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg3 < 0:
                                        revert with 0, 17
                                    if 0 > !arg3:
                                        revert with 0, 17
                                    if arg3 != arg3:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                    if 0 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                    emit Transfer(0, arg1, this.address);
                                    if not arg1:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not arg2:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if arg3 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3:
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 -= arg3
                                    if balanceOf[arg2].field_0 > !arg3:
                                        revert with 0, 17
                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                    emit Transfer(arg3, arg1, arg2);
                                else:
                                    if arg3 and transferTaxRate > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if arg3 * transferTaxRate / 1000 > arg3:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg3 < arg3 * transferTaxRate / 1000:
                                        revert with 0, 17
                                    if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if arg3 != arg3:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                    if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                    if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                    emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                    if not arg1:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not arg2:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                    if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                    emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
                else:
                    if sub_dd10546aAddress == arg1:
                        if not transferTaxRate:
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                            if not arg2:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                            if arg3 > balanceOf[address(arg1)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(arg1)].field_0 < arg3:
                                revert with 0, 17
                            balanceOf[address(arg1)].field_0 -= arg3
                            if balanceOf[arg2].field_0 > !arg3:
                                revert with 0, 17
                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                            emit Transfer(arg3, arg1, arg2);
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                        else:
                            if stor14[address(arg1)]:
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                if not arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                if arg3 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3:
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 -= arg3
                                if balanceOf[arg2].field_0 > !arg3:
                                    revert with 0, 17
                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                emit Transfer(arg3, arg1, arg2);
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                            else:
                                if stor14[address(arg2)]:
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                    if not arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                    if arg3 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3:
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 -= arg3
                                    if balanceOf[arg2].field_0 > !arg3:
                                        revert with 0, 17
                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                    emit Transfer(arg3, arg1, arg2);
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                else:
                                    if not arg3:
                                        if 0 > arg3:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg3 < 0:
                                            revert with 0, 17
                                        if 0 > !arg3:
                                            revert with 0, 17
                                        if arg3 != arg3:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                        if 0 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                        emit Transfer(0, arg1, this.address);
                                        if not arg1:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if arg3 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3
                                        if balanceOf[arg2].field_0 > !arg3:
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                        emit Transfer(arg3, arg1, arg2);
                                    else:
                                        if arg3 and transferTaxRate > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        if arg3 * transferTaxRate / 1000 > arg3:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg3 < arg3 * transferTaxRate / 1000:
                                            revert with 0, 17
                                        if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if arg3 != arg3:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                        if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                        if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                        emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                        if not arg1:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                        if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                        emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
                    else:
                        if owner == arg1:
                            if not transferTaxRate:
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                if not arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                if arg3 > balanceOf[address(arg1)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(arg1)].field_0 < arg3:
                                    revert with 0, 17
                                balanceOf[address(arg1)].field_0 -= arg3
                                if balanceOf[arg2].field_0 > !arg3:
                                    revert with 0, 17
                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                emit Transfer(arg3, arg1, arg2);
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                            else:
                                if stor14[address(arg1)]:
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                    if not arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                    if arg3 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3:
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 -= arg3
                                    if balanceOf[arg2].field_0 > !arg3:
                                        revert with 0, 17
                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                    emit Transfer(arg3, arg1, arg2);
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                else:
                                    if stor14[address(arg2)]:
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                        if arg3 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3
                                        if balanceOf[arg2].field_0 > !arg3:
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                        emit Transfer(arg3, arg1, arg2);
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                    else:
                                        if not arg3:
                                            if 0 > arg3:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg3 < 0:
                                                revert with 0, 17
                                            if 0 > !arg3:
                                                revert with 0, 17
                                            if arg3 != arg3:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                            if not arg1:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                            if 0 > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                            emit Transfer(0, arg1, this.address);
                                            if not arg1:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not arg2:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                        else:
                                            if arg3 and transferTaxRate > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                            if arg3 * transferTaxRate / 1000 > arg3:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg3 < arg3 * transferTaxRate / 1000:
                                                revert with 0, 17
                                            if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if arg3 != arg3:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                            if not arg1:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                            if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                            if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                            emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                            if not arg1:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not arg2:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                            if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                            emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
                        else:
                            if owner == arg2:
                                if not transferTaxRate:
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                    if not arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                    if arg3 > balanceOf[address(arg1)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(arg1)].field_0 < arg3:
                                        revert with 0, 17
                                    balanceOf[address(arg1)].field_0 -= arg3
                                    if balanceOf[arg2].field_0 > !arg3:
                                        revert with 0, 17
                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                    emit Transfer(arg3, arg1, arg2);
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                else:
                                    if stor14[address(arg1)]:
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                        if arg3 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3
                                        if balanceOf[arg2].field_0 > !arg3:
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                        emit Transfer(arg3, arg1, arg2);
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                    else:
                                        if stor14[address(arg2)]:
                                            if not arg1:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                            if not arg2:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                        else:
                                            if not arg3:
                                                if 0 > arg3:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg3 < 0:
                                                    revert with 0, 17
                                                if 0 > !arg3:
                                                    revert with 0, 17
                                                if arg3 != arg3:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                                if not arg1:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                                if 0 > balanceOf[address(arg1)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                                if balanceOf[address(arg1)].field_0 < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                emit Transfer(0, arg1, this.address);
                                                if not arg1:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not arg2:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if arg3 > balanceOf[address(arg1)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                                if balanceOf[address(arg1)].field_0 < arg3:
                                                    revert with 0, 17
                                                balanceOf[address(arg1)].field_0 -= arg3
                                                if balanceOf[arg2].field_0 > !arg3:
                                                    revert with 0, 17
                                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                                emit Transfer(arg3, arg1, arg2);
                                            else:
                                                if arg3 and transferTaxRate > -1 / arg3:
                                                    revert with 0, 17
                                                if not arg3:
                                                    revert with 0, 18
                                                if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                                if arg3 * transferTaxRate / 1000 > arg3:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg3 < arg3 * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if arg3 != arg3:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                                if not arg1:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                                if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                                if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                                if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                                emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                                if not arg1:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not arg2:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                                if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                                if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                                emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
                            else:
                                stor17 = 1
                                transferTaxRate = 0
                                if liquidityFee > !buybackFee:
                                    revert with 0, 17
                                if liquidityFee + buybackFee < liquidityFee:
                                    revert with 0, 'SafeMath: addition overflow'
                                if balanceOf[address(this.address)].field_0 < minAmountToLiquify:
                                    stor17 = 0
                                    if not transferTaxRate:
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                        if arg3 > balanceOf[address(arg1)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(arg1)].field_0 < arg3:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3
                                        if balanceOf[arg2].field_0 > !arg3:
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                        emit Transfer(arg3, arg1, arg2);
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                    else:
                                        if stor14[address(arg1)]:
                                            if not arg1:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                            if not arg2:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                        else:
                                            if stor14[address(arg2)]:
                                                if not arg1:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                                if not arg2:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                                if arg3 > balanceOf[address(arg1)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                                if balanceOf[address(arg1)].field_0 < arg3:
                                                    revert with 0, 17
                                                balanceOf[address(arg1)].field_0 -= arg3
                                                if balanceOf[arg2].field_0 > !arg3:
                                                    revert with 0, 17
                                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                                emit Transfer(arg3, arg1, arg2);
                                                if arg3 > allowance[address(arg1)][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
                                            else:
                                                if not arg3:
                                                    if 0 > arg3:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg3 < 0:
                                                        revert with 0, 17
                                                    if 0 > !arg3:
                                                        revert with 0, 17
                                                    if arg3 != arg3:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                                    if not arg1:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                                    if 0 > balanceOf[address(arg1)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                                    if balanceOf[address(arg1)].field_0 < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                    emit Transfer(0, arg1, this.address);
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not arg2:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if arg3 > balanceOf[address(arg1)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                                    if balanceOf[address(arg1)].field_0 < arg3:
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 -= arg3
                                                    if balanceOf[arg2].field_0 > !arg3:
                                                        revert with 0, 17
                                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                                    emit Transfer(arg3, arg1, arg2);
                                                else:
                                                    if arg3 and transferTaxRate > -1 / arg3:
                                                        revert with 0, 17
                                                    if not arg3:
                                                        revert with 0, 18
                                                    if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                                    if arg3 * transferTaxRate / 1000 > arg3:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg3 < arg3 * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if arg3 != arg3:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'XSH:: transfer: Tax value invalid'
                                                    if not arg1:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: transfer to the zero address'
                                                    if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                                    if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                                    if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                                    emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not arg2:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[262 len 26] >> 48, 0
                                                    if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                                    if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                                    emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                                if arg3 > allowance[address(arg1)][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[360 len 24] >> 64, 0
                                else:
                                    if not minAmountToLiquify:
                                        if liquidityFee + buybackFee <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not liquidityFee + buybackFee:
                                            revert with 0, 18
                                        mem[96] = 3
                                        mem[128] = this.address
                                        require ext_code.size(sub_7e2fd586Address)
                                        staticcall sub_7e2fd586Address.WETH() with:
                                                gas gas_remaining wei
                                        mem[224] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[160] = ext_call.return_data[12 len 20]
                                        mem[192] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                        if not this.address:
                                            revert with 0, 'BEP20: approve from the zero address'
                                        if not sub_7e2fd586Address:
                                            revert with 0, 'BEP20: approve to the zero address'
                                        allowance[address(this.address)][stor9] = 0 / liquidityFee + buybackFee
                                        emit Approval((0 / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                        if block.timestamp > -301:
                                            revert with 0, 17
                                        if block.timestamp + 300 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(return_data.size) + 228] = 0 / liquidityFee + buybackFee
                                        mem[ceil32(return_data.size) + 388] = 3
                                        idx = 0
                                        s = ceil32(return_data.size) + 420
                                        t = 128
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(return_data.size) + 324] = 57005
                                        mem[ceil32(return_data.size) + 356] = block.timestamp + 300
                                        require ext_code.size(sub_7e2fd586Address)
                                        call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0 / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 420 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                            revert with 0, 17
                                        mem[ceil32(return_data.size) + 224] = 2
                                        mem[ceil32(return_data.size) + 256] = this.address
                                        require ext_code.size(sub_7e2fd586Address)
                                        staticcall sub_7e2fd586Address.WETH() with:
                                                gas gas_remaining wei
                                        mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = (2 * ceil32(return_data.size)) + 320
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[ceil32(return_data.size) + 288] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'BEP20: approve from the zero address'
                                        if not sub_7e2fd586Address:
                                            revert with 0, 'BEP20: approve to the zero address'
                                        mem[0] = sub_7e2fd586Address
                                        mem[32] = sha3(address(this.address), 2)
                                        allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                        emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = balanceOf[this.address].field_1
                                        mem[(2 * ceil32(return_data.size)) + 356] = 0
                                        mem[(2 * ceil32(return_data.size)) + 388] = 160
                                        mem[(2 * ceil32(return_data.size)) + 484] = 2
                                        idx = 0
                                        s = (2 * ceil32(return_data.size)) + 516
                                        t = ceil32(return_data.size) + 256
                                        while idx < mem[ceil32(return_data.size) + 224]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                        mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                        require ext_code.size(sub_7e2fd586Address)
                                        call sub_7e2fd586Address.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 2 * Mask(256, -1, balanceOf[this.address].field_1), 0, 160, address(this.address), block.timestamp, mem[(2 * ceil32(return_data.size)) + 484 len (32 * mem[ceil32(return_data.size) + 224]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 30
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 36
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'BEP20: approve from the zero add'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        if not sub_7e2fd586Address:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 34
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'BEP20: approve to the zero addre'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                        emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                        mem[(2 * ceil32(return_data.size)) + 324] = this.address
                                        mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                        mem[(2 * ceil32(return_data.size)) + 388] = 0
                                        mem[(2 * ceil32(return_data.size)) + 420] = 0
                                        mem[(2 * ceil32(return_data.size)) + 452] = this.address
                                        mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
                                        require ext_code.size(sub_7e2fd586Address)
                                        call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[(2 * ceil32(return_data.size)) + 324 len ceil32(return_data.size) + 192]
                                        mem[(2 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        require ext_call.return_data[64] > 0
                                        mem[(4 * ceil32(return_data.size)) + 320] = balanceOf[this.address].field_1
                                        mem[(4 * ceil32(return_data.size)) + 352] = 0
                                        mem[(4 * ceil32(return_data.size)) + 384] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[(4 * ceil32(return_data.size)) + 320 len (5 * ceil32(return_data.size)) + 96],
                                        stor17 = 0
                                        if not transferTaxRate:
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 37
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg2:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 35
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 38
                                                mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                mem[(4 * ceil32(return_data.size)) + 522] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 27
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 40
                                                mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[(4 * ceil32(return_data.size)) + 488 len 24]
                                                mem[(4 * ceil32(return_data.size)) + 620] = 0
                                            else:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 36
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve from the zero add'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                else:
                                                    if msg.sender:
                                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                        return 1
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 34
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve to the zero addre'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (4 * ceil32(return_data.size)) + 512
                                               len (5 * ceil32(return_data.size)) + 132
                                        if stor14[address(arg1)]:
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 37
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg2:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 35
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 38
                                                mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                mem[(4 * ceil32(return_data.size)) + 522] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 27
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 40
                                                mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[(4 * ceil32(return_data.size)) + 488 len 24]
                                                mem[(4 * ceil32(return_data.size)) + 620] = 0
                                            else:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 36
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve from the zero add'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                else:
                                                    if msg.sender:
                                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                        return 1
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 34
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve to the zero addre'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (4 * ceil32(return_data.size)) + 512
                                               len (5 * ceil32(return_data.size)) + 132
                                        if stor14[address(arg2)]:
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 37
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg2:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 35
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 38
                                                mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                mem[(4 * ceil32(return_data.size)) + 522] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 27
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 40
                                                mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[(4 * ceil32(return_data.size)) + 488 len 24]
                                                mem[(4 * ceil32(return_data.size)) + 620] = 0
                                            else:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 36
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve from the zero add'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                else:
                                                    if msg.sender:
                                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                        return 1
                                                    mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 34
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 'BEP20: approve to the zero addre'
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (4 * ceil32(return_data.size)) + 512
                                               len (5 * ceil32(return_data.size)) + 132
                                        if not arg3:
                                            if 0 > arg3:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 30
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 100
                                            if arg3 < 0:
                                                revert with 0, 17
                                            if 0 > !arg3:
                                                revert with 0, 17
                                            if arg3 != arg3:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 33
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'XSH:: transfer: Tax value invali'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6400000000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 37
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not this.address:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 35
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if 0 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 38
                                                mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                mem[(4 * ceil32(return_data.size)) + 522] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 27
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                            emit Transfer(0, arg1, this.address);
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 37
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg2:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 35
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 38
                                                mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 486 len 26]
                                                mem[(4 * ceil32(return_data.size)) + 618] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 512
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 27
                                                mem[(4 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 512
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                        else:
                                            if arg3 and transferTaxRate > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 33
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: multiplication overflo'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 * transferTaxRate / 1000 > arg3:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 30
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 100
                                            if arg3 < arg3 * transferTaxRate / 1000:
                                                revert with 0, 17
                                            if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if arg3 != arg3:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 33
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'XSH:: transfer: Tax value invali'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6400000000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 37
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not this.address:
                                                mem[(4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 324] = 32
                                                mem[(4 * ceil32(return_data.size)) + 356] = 35
                                                mem[(4 * ceil32(return_data.size)) + 388] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 320
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 38
                                                mem[(4 * ceil32(return_data.size)) + 484 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                mem[(4 * ceil32(return_data.size)) + 522] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                            if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 27
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                            emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 37
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer from the zero ad'
                                                mem[(4 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if not arg2:
                                                mem[(4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 420] = 32
                                                mem[(4 * ceil32(return_data.size)) + 452] = 35
                                                mem[(4 * ceil32(return_data.size)) + 484] = 'BEP20: transfer to the zero addr'
                                                mem[(4 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 38
                                                mem[(4 * ceil32(return_data.size)) + 580 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 486 len 26]
                                                mem[(4 * ceil32(return_data.size)) + 618] = 0
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 512
                                                   len (5 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                            if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                                mem[(4 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 516] = 32
                                                mem[(4 * ceil32(return_data.size)) + 548] = 27
                                                mem[(4 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from (4 * ceil32(return_data.size)) + 512
                                                   len (5 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                            emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[(4 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 612] = 32
                                            mem[(4 * ceil32(return_data.size)) + 644] = 40
                                            mem[(4 * ceil32(return_data.size)) + 676 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[(4 * ceil32(return_data.size)) + 584 len 24]
                                            mem[(4 * ceil32(return_data.size)) + 716] = 0
                                        else:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                mem[(4 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 612] = 32
                                                mem[(4 * ceil32(return_data.size)) + 644] = 36
                                                mem[(4 * ceil32(return_data.size)) + 676] = 'BEP20: approve from the zero add'
                                                mem[(4 * ceil32(return_data.size)) + 708] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            else:
                                                if msg.sender:
                                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                    return 1
                                                mem[(4 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 612] = 32
                                                mem[(4 * ceil32(return_data.size)) + 644] = 34
                                                mem[(4 * ceil32(return_data.size)) + 676] = 'BEP20: approve to the zero addre'
                                                mem[(4 * ceil32(return_data.size)) + 708] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from (4 * ceil32(return_data.size)) + 608
                                           len (5 * ceil32(return_data.size)) + 132
                                    if minAmountToLiquify and buybackFee > -1 / minAmountToLiquify:
                                        revert with 0, 17
                                    if not minAmountToLiquify:
                                        revert with 0, 18
                                    if minAmountToLiquify * buybackFee / minAmountToLiquify != buybackFee:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if liquidityFee + buybackFee <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not liquidityFee + buybackFee:
                                        revert with 0, 18
                                    mem[96] = 3
                                    mem[128] = this.address
                                    require ext_code.size(sub_7e2fd586Address)
                                    staticcall sub_7e2fd586Address.WETH() with:
                                            gas gas_remaining wei
                                    mem[224] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[160] = ext_call.return_data[12 len 20]
                                    mem[192] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                    if not this.address:
                                        revert with 0, 'BEP20: approve from the zero address'
                                    if not sub_7e2fd586Address:
                                        revert with 0, 'BEP20: approve to the zero address'
                                    allowance[address(this.address)][stor9] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                    emit Approval((minAmountToLiquify * buybackFee / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                    if block.timestamp > -301:
                                        revert with 0, 17
                                    if block.timestamp + 300 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + 228] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                    mem[ceil32(return_data.size) + 388] = 3
                                    idx = 0
                                    s = ceil32(return_data.size) + 420
                                    t = 128
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(return_data.size) + 324] = 57005
                                    mem[ceil32(return_data.size) + 356] = block.timestamp + 300
                                    require ext_code.size(sub_7e2fd586Address)
                                    call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args minAmountToLiquify * buybackFee / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 420 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                        revert with 0, 17
                                    mem[ceil32(return_data.size) + 224] = 2
                                    mem[ceil32(return_data.size) + 256] = this.address
                                    require ext_code.size(sub_7e2fd586Address)
                                    staticcall sub_7e2fd586Address.WETH() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 320
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'BEP20: approve from the zero address'
                                    if not sub_7e2fd586Address:
                                        revert with 0, 'BEP20: approve to the zero address'
                                    mem[0] = sub_7e2fd586Address
                                    mem[32] = sha3(address(this.address), 2)
                                    allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                    emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                    mem[(2 * ceil32(return_data.size)) + 320] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 324] = balanceOf[this.address].field_1
                                    mem[(2 * ceil32(return_data.size)) + 356] = 0
                                    mem[(2 * ceil32(return_data.size)) + 388] = 160
                                    mem[(2 * ceil32(return_data.size)) + 484] = 2
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 516
                                    t = ceil32(return_data.size) + 256
                                    while idx < mem[ceil32(return_data.size) + 224]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                    require ext_code.size(sub_7e2fd586Address)
                                    call sub_7e2fd586Address.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + 224]) + -mem[64] + 512]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'BEP20: approve from the zero address'
                                    if not sub_7e2fd586Address:
                                        revert with 0, 'BEP20: approve to the zero address'
                                    mem[0] = sub_7e2fd586Address
                                    mem[32] = sha3(address(this.address), 2)
                                    allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                    emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                    mem[mem[64] + 68] = 0
                                    mem[mem[64] + 100] = 0
                                    mem[mem[64] + 132] = this.address
                                    mem[mem[64] + 164] = block.timestamp
                                    require ext_code.size(sub_7e2fd586Address)
                                    call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, balanceOf[this.address].field_0 - balanceOf[this.address].field_1, 0, 0, this.address, block.timestamp
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3206 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_3206 + 64] > 0
                                    mem[mem[64] + 32] = 0
                                    mem[mem[64] + 64] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                    emit SwapAndLiquify(2 * Mask(256, -1, balanceOf[this.address].field_1), 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1);
                                    stor17 = 0
                                    if not transferTaxRate:
                                        if not arg1:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not arg2:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        _3224 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_3224] = 38
                                        mem[_3224 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg3 > balanceOf[address(arg1)].field_0:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3224 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(arg1)].field_0 < arg3:
                                            revert with 0, 17
                                        balanceOf[address(arg1)].field_0 -= arg3
                                        if balanceOf[arg2].field_0 > !arg3:
                                            revert with 0, 17
                                        if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                        emit Transfer(arg3, arg1, arg2);
                                        _3336 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_3336] = 40
                                        mem[_3336 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_3336 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not arg1:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not arg2:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            _3235 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_3235] = 38
                                            mem[_3235 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg3 > balanceOf[address(arg1)].field_0:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3235 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(arg1)].field_0 < arg3:
                                                revert with 0, 17
                                            balanceOf[address(arg1)].field_0 -= arg3
                                            if balanceOf[arg2].field_0 > !arg3:
                                                revert with 0, 17
                                            if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                            emit Transfer(arg3, arg1, arg2);
                                            _3344 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_3344] = 40
                                            mem[_3344 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_3344 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            mem[0] = arg2
                                            mem[32] = 14
                                            if stor14[address(arg2)]:
                                                if not arg1:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not arg2:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                _3248 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_3248] = 38
                                                mem[_3248 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg3 > balanceOf[address(arg1)].field_0:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3248 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(arg1)].field_0 < arg3:
                                                    revert with 0, 17
                                                balanceOf[address(arg1)].field_0 -= arg3
                                                if balanceOf[arg2].field_0 > !arg3:
                                                    revert with 0, 17
                                                if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 1
                                                balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                                emit Transfer(arg3, arg1, arg2);
                                                _3352 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_3352] = 40
                                                mem[_3352 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                if arg3 > allowance[address(arg1)][msg.sender]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 40
                                                    mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_3352 + 72 len 24]
                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                if not arg3:
                                                    if 0 > arg3:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg3 < 0:
                                                        revert with 0, 17
                                                    if 0 > !arg3:
                                                        revert with 0, 17
                                                    if arg3 != arg3:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _3383 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3383] = 38
                                                    mem[_3383 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(arg1)].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3383 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(arg1)].field_0 < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                    emit Transfer(0, arg1, this.address);
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not arg2:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _3523 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3523] = 38
                                                    mem[_3523 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg3 > balanceOf[address(arg1)].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3523 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(arg1)].field_0 < arg3:
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 -= arg3
                                                    if balanceOf[arg2].field_0 > !arg3:
                                                        revert with 0, 17
                                                    if balanceOf[arg2].field_0 + arg3 < balanceOf[arg2].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg2
                                                    mem[32] = 1
                                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3
                                                    emit Transfer(arg3, arg1, arg2);
                                                    _3592 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3592] = 40
                                                    mem[_3592 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 40
                                                        mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_3592 + 72 len 24]
                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if arg3 and transferTaxRate > -1 / arg3:
                                                        revert with 0, 17
                                                    if not arg3:
                                                        revert with 0, 18
                                                    if arg3 * transferTaxRate / arg3 != transferTaxRate:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if arg3 * transferTaxRate / 1000 > arg3:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg3 < arg3 * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    if arg3 * transferTaxRate / 1000 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if arg3 != arg3:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _3470 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3470] = 38
                                                    mem[_3470 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg3 * transferTaxRate / 1000 > balanceOf[address(arg1)].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3470 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(arg1)].field_0 < arg3 * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 -= arg3 * transferTaxRate / 1000
                                                    if balanceOf[this.address].field_0 > !(arg3 * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (arg3 * transferTaxRate / 1000)
                                                    emit Transfer((arg3 * transferTaxRate / 1000), arg1, this.address);
                                                    if not arg1:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not arg2:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _3550 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3550] = 38
                                                    mem[_3550 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg3 - (arg3 * transferTaxRate / 1000) > balanceOf[address(arg1)].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_3550 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(arg1)].field_0 < arg3 - (arg3 * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    balanceOf[address(arg1)].field_0 = balanceOf[address(arg1)].field_0 - arg3 + (arg3 * transferTaxRate / 1000)
                                                    if balanceOf[arg2].field_0 > !(arg3 - (arg3 * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000) < balanceOf[arg2].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg2
                                                    mem[32] = 1
                                                    balanceOf[address(arg2)].field_0 = balanceOf[arg2].field_0 + arg3 - (arg3 * transferTaxRate / 1000)
                                                    emit Transfer((arg3 - (arg3 * transferTaxRate / 1000)), arg1, arg2);
                                                    _3614 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_3614] = 40
                                                    mem[_3614 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 40
                                                        mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_3614 + 72 len 24]
                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    ('le', ('param', 'arg3'), ('stor', ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'allowance', 2)))))
    if allowance[address(arg1)][msg.sender] < arg3:
        revert with 0, 17
    if not arg1:
        revert with 0, 'BEP20: approve from the zero address'
    if not msg.sender:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
    return 1
}

function _fallback() payable {
    mem[64] = 128
    if calldata.size < 4:
        require not calldata.size
    if unknown_0x85141a77(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0xaa271e1a(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xd63cad22(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xdd62ed3e(?????) > uint32(call.func_hash) >> 224:
                    if uint32(call.func_hash) >> 224 != unknown_0xd63cad22(?????):
                        if unknown_0xd8248358(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return minAmountToLiquify
                        require unknown_0xdd10546a(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return sub_dd10546aAddress
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == bool(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if bool(cd[36]) == bool(stor14[address(cd[4])]):
                        revert with 0, 'XSH: Account is already the value of 'excluded''
                    stor14[address(cd[4])] = uint8(bool(cd[36]))
                    emit ExcludeFromFees(bool(cd[36]), address(cd[4]));
                else:
                    if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == address(cd[36])
                        return allowance[address(cd[4])][address(cd[36])]
                    if unknown_0xe7a324dc(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return 0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf
                    if unknown_0xf1127ed8(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == uint32(cd[36])
                        return checkpoints[cd[4]][cd[36]].field_0, checkpoints[cd[4]][cd[36]].field_256
                    require unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not address(cd[4]):
                        revert with 0, 'Ownable: new owner is the zero address'
                    emit OwnershipTransferred(owner, address(cd[4]));
                    owner = address(cd[4])
            else:
                if unknown_0xaa271e1a(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if not address(cd[4]):
                        revert with 0, 'Roles: account is the zero address'
                    return bool(stor8[address(cd[4])])
                if unknown_0xb4b5ea57(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if not numCheckpoints[address(cd[4])]:
                        return 0
                    if numCheckpoints[address(cd[4])] < 1:
                        revert with 0, 17
                    return checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256
                if unknown_0xb65d08b0(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return transferTaxRate
                if uint32(call.func_hash) >> 224 != unknown_0xc3cda520(?????):
                    if uint32(call.func_hash) >> 224 != unknown_0xc492f046(?????):
                        require unknown_0xd5abeb01(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return 100000 * 10^18
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] <= test266151307()
                    require cd[4] + 35 < calldata.size
                    require ('cd', 4).length <= test266151307()
                    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                    require cd[36] == bool(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    idx = 0
                    while idx < ('cd', 4).length:
                        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                        mem[32] = 14
                        stor14[address(cd[((32 * idx) + cd[4] + 36)])] = uint8(bool(cd[36]))
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    s = 224
                    t = cd[4] + 36
                    while idx < ('cd', 4).length:
                        require cd[t] == address(cd[t])
                        mem[s] = address(cd[t])
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    emit ExcludeMultipleAccountsFromFees(Array(len=('cd', 4).length, data=mem[224 len 32 * ('cd', 4).length]), bool(cd[36]));
                else:
                    require not msg.value
                    require calldata.size - 4 >= 192
                    require cd[4] == address(cd[4])
                    require cd[100] == uint8(cd[100])
                    if bool(stor4.length):
                        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor4.length):
                                if 31 >= uint255(stor4.length) * 0.5:
                                    mem[160] = 256 * stor4.length.field_8
                                else:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor4.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor4.length) == stor4.length.field_1 < 32:
                                revert with 0, 34
                            if stor4.length.field_1:
                                if 31 >= stor4.length.field_1:
                                    mem[160] = 256 * stor4.length.field_8
                                else:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while stor4.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        signer = erecover(sha3(0, sha3(0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866, sha3(mem[160 len uint255(stor4.length) * 0.5]), chainid, this.address), sha3(0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf, address(cd[4]), cd[36], cd[68])), cd[100] << 248, cd[132], cd[164]) 
                        if not erecover.result:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not address(signer):
                            revert with 0, 'XSH::delegateBySig: invalid signature'
                        if nonces[address(signer)] == -1:
                            revert with 0, 17
                        nonces[address(signer)]++
                        if cd[36] != nonces[address(signer)]:
                            revert with 0, 'XSH::delegateBySig: invalid nonce'
                        if block.timestamp > cd[68]:
                            revert with 0, 'XSH::delegateBySig: signature expired'
                        delegates[address(signer)] = address(cd[4])
                        emit DelegateChanged(address(signer), delegates[address(signer)], address(cd[4]));
                        if delegates[address(signer)] != address(cd[4]):
                            if balanceOf[address(signer)].field_0 > 0:
                                if not delegates[address(signer)]:
                                    if address(cd[4]):
                                        if not numCheckpoints[address(cd[4])]:
                                            if 0 > !balanceOf[address(signer)].field_0:
                                                revert with 0, 17
                                            if balanceOf[address(signer)].field_0 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                else:
                                    if not numCheckpoints[stor18[address(signer)]]:
                                        if balanceOf[address(signer)].field_0 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 < balanceOf[address(signer)].field_0:
                                            revert with 0, 17
                                        if block.number >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        51,
                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                        0
                                        if numCheckpoints[stor18[address(signer)]] <= 0:
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = -balanceOf[address(signer)].field_0
                                            if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                            emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                            if address(cd[4]):
                                                if not numCheckpoints[address(cd[4])]:
                                                    if 0 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if balanceOf[address(signer)].field_0 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[stor18[address(signer)]] < 1:
                                                revert with 0, 17
                                            if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_0 == uint32(block.number):
                                                if numCheckpoints[stor18[address(signer)]] < 1:
                                                    revert with 0, 17
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 = -balanceOf[address(signer)].field_0
                                                emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                            else:
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = -balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                                emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                    else:
                                        if numCheckpoints[stor18[address(signer)]] < 1:
                                            revert with 0, 17
                                        if balanceOf[address(signer)].field_0 > checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 < balanceOf[address(signer)].field_0:
                                            revert with 0, 17
                                        if block.number >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        51,
                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                        0
                                        if numCheckpoints[stor18[address(signer)]] <= 0:
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0
                                            if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                            emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                            if address(cd[4]):
                                                if not numCheckpoints[address(cd[4])]:
                                                    if 0 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if balanceOf[address(signer)].field_0 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[stor18[address(signer)]] < 1:
                                                revert with 0, 17
                                            if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_0 == uint32(block.number):
                                                if numCheckpoints[stor18[address(signer)]] < 1:
                                                    revert with 0, 17
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 -= balanceOf[address(signer)].field_0
                                                emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                            else:
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                                emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(uint255(stor4.length) * 0.5) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                    else:
                        if bool(stor4.length) == stor4.length.field_1 < 32:
                            revert with 0, 34
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor4.length):
                                if 31 >= uint255(stor4.length) * 0.5:
                                    mem[160] = 256 * stor4.length.field_8
                                else:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor4.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor4.length) == stor4.length.field_1 < 32:
                                revert with 0, 34
                            if stor4.length.field_1:
                                if 31 >= stor4.length.field_1:
                                    mem[160] = 256 * stor4.length.field_8
                                else:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while stor4.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        signer = erecover(sha3(0, sha3(0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866, sha3(mem[160 len stor4.length.field_1]), chainid, this.address), sha3(0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf, address(cd[4]), cd[36], cd[68])), cd[100] << 248, cd[132], cd[164]) 
                        if not erecover.result:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not address(signer):
                            revert with 0, 'XSH::delegateBySig: invalid signature'
                        if nonces[address(signer)] == -1:
                            revert with 0, 17
                        nonces[address(signer)]++
                        if cd[36] != nonces[address(signer)]:
                            revert with 0, 'XSH::delegateBySig: invalid nonce'
                        if block.timestamp > cd[68]:
                            revert with 0, 'XSH::delegateBySig: signature expired'
                        delegates[address(signer)] = address(cd[4])
                        emit DelegateChanged(address(signer), delegates[address(signer)], address(cd[4]));
                        if delegates[address(signer)] != address(cd[4]):
                            if balanceOf[address(signer)].field_0 > 0:
                                if not delegates[address(signer)]:
                                    if address(cd[4]):
                                        if not numCheckpoints[address(cd[4])]:
                                            if 0 > !balanceOf[address(signer)].field_0:
                                                revert with 0, 17
                                            if balanceOf[address(signer)].field_0 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                else:
                                    if not numCheckpoints[stor18[address(signer)]]:
                                        if balanceOf[address(signer)].field_0 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 < balanceOf[address(signer)].field_0:
                                            revert with 0, 17
                                        if block.number >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        51,
                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                        0
                                        if numCheckpoints[stor18[address(signer)]] <= 0:
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = -balanceOf[address(signer)].field_0
                                            if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                            emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                            if address(cd[4]):
                                                if not numCheckpoints[address(cd[4])]:
                                                    if 0 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if balanceOf[address(signer)].field_0 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[stor18[address(signer)]] < 1:
                                                revert with 0, 17
                                            if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_0 == uint32(block.number):
                                                if numCheckpoints[stor18[address(signer)]] < 1:
                                                    revert with 0, 17
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 = -balanceOf[address(signer)].field_0
                                                emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                            else:
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = -balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                                emit DelegateVotesChanged(0, -balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                    else:
                                        if numCheckpoints[stor18[address(signer)]] < 1:
                                            revert with 0, 17
                                        if balanceOf[address(signer)].field_0 > checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 < balanceOf[address(signer)].field_0:
                                            revert with 0, 17
                                        if block.number >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        51,
                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, Mask(104, 0, cd[132]) >> 152,
                                                        0
                                        if numCheckpoints[stor18[address(signer)]] <= 0:
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                            checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0
                                            if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                            emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                            if address(cd[4]):
                                                if not numCheckpoints[address(cd[4])]:
                                                    if 0 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if balanceOf[address(signer)].field_0 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if block.number >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    51,
                                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                    0
                                                    if numCheckpoints[address(cd[4])] <= 0:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                        else:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                    emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[stor18[address(signer)]] < 1:
                                                revert with 0, 17
                                            if checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_0 == uint32(block.number):
                                                if numCheckpoints[stor18[address(signer)]] < 1:
                                                    revert with 0, 17
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 -= balanceOf[address(signer)].field_0
                                                emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 789 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
                                            else:
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_0 = uint32(block.number)
                                                checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]]].field_256 = checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0
                                                if 1 > -numCheckpoints[stor18[address(signer)]] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[stor18[address(signer)]] = uint32(numCheckpoints[stor18[address(signer)]] + 1)
                                                emit DelegateVotesChanged(checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256, checkpoints[stor18[address(signer)]][stor20[stor18[address(signer)]] - 1 << 224].field_256 - balanceOf[address(signer)].field_0, delegates[address(signer)]);
                                                if address(cd[4]):
                                                    if not numCheckpoints[address(cd[4])]:
                                                        if 0 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if balanceOf[address(signer)].field_0 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(0, balanceOf[address(signer)].field_0, address(cd[4]));
                                                    else:
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(signer)].field_0:
                                                            revert with 0, 17
                                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if block.number >= 4294967296:
                                                            revert with 0, 
                                                                        32,
                                                                        51,
                                                                        0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[ceil32(stor4.length.field_1) + 853 len 13] >> 152,
                                                                        0
                                                        if numCheckpoints[address(cd[4])] <= 0:
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                revert with 0, 17
                                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        else:
                                                            if numCheckpoints[address(cd[4])] < 1:
                                                                revert with 0, 17
                                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                                if numCheckpoints[address(cd[4])] < 1:
                                                                    revert with 0, 17
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(signer)].field_0
                                                            else:
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0
                                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                                    revert with 0, 17
                                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                        emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(signer)].field_0, address(cd[4]));
        if unknown_0x98650275(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x85141a77(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return 57005
            if unknown_0x893d20e8(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return owner
            if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return owner
            if unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                if bool(stor5.length):
                    if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor5.length):
                        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor5.length):
                            if 31 < uint255(stor5.length) * 0.5:
                                mem[160] = uint256(stor5.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor5.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor5[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor5.length), data=mem[160 len ceil32(uint255(stor5.length) * 0.5)])
                            mem[160] = 256 * stor5.length.field_8
                    else:
                        if bool(stor5.length) == stor5.length.field_1 < 32:
                            revert with 0, 34
                        if stor5.length.field_1:
                            if 31 < stor5.length.field_1:
                                mem[160] = uint256(stor5.field_0)
                                idx = 160
                                s = 0
                                while stor5.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor5[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor5.length), data=mem[160 len ceil32(uint255(stor5.length) * 0.5)])
                            mem[160] = 256 * stor5.length.field_8
                    mem[ceil32(uint255(stor5.length) * 0.5) + 224 len ceil32(uint255(stor5.length) * 0.5)] = mem[160 len ceil32(uint255(stor5.length) * 0.5)]
                    if ceil32(uint255(stor5.length) * 0.5) > uint255(stor5.length) * 0.5:
                        mem[ceil32(uint255(stor5.length) * 0.5) + (uint255(stor5.length) * 0.5) + 224] = 0
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[160 len ceil32(uint255(stor5.length) * 0.5)], mem[(2 * ceil32(uint255(stor5.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor5.length) * 0.5)]), 
                if bool(stor5.length) == stor5.length.field_1 < 32:
                    revert with 0, 34
                if bool(stor5.length):
                    if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor5.length):
                        if 31 < uint255(stor5.length) * 0.5:
                            mem[160] = uint256(stor5.field_0)
                            idx = 160
                            s = 0
                            while (uint255(stor5.length) * 0.5) + 128 > idx:
                                mem[idx + 32] = stor5[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor5.length % 128, data=mem[160 len ceil32(stor5.length.field_1)])
                        mem[160] = 256 * stor5.length.field_8
                else:
                    if bool(stor5.length) == stor5.length.field_1 < 32:
                        revert with 0, 34
                    if stor5.length.field_1:
                        if 31 < stor5.length.field_1:
                            mem[160] = uint256(stor5.field_0)
                            idx = 160
                            s = 0
                            while stor5.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor5[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor5.length % 128, data=mem[160 len ceil32(stor5.length.field_1)])
                        mem[160] = 256 * stor5.length.field_8
                mem[ceil32(stor5.length.field_1) + 224 len ceil32(stor5.length.field_1)] = mem[160 len ceil32(stor5.length.field_1)]
                if ceil32(stor5.length.field_1) > stor5.length.field_1:
                    mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 224] = 0
                return Array(len=stor5.length % 128, data=mem[160 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 224 len 2 * ceil32(stor5.length.field_1)]), 
            if unknown_0x98118cb4(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return liquidityFee
            require unknown_0x983b2d56(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 32
            require cd[4] == address(cd[4])
            if not msg.sender:
                revert with 0, 'Roles: account is the zero address'
            if not stor8[address(msg.sender)]:
                revert with 0, 'MinterRole: caller does not have the Minter role'
            if not address(cd[4]):
                revert with 0, 'Roles: account is the zero address'
            if stor8[address(cd[4])]:
                revert with 0, 'Roles: account already has role'
            stor8[address(cd[4])] = 1
            emit MinterAdded(address(cd[4]));
        if unknown_0xa392e674(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x98650275(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                if not msg.sender:
                    revert with 0, 'Roles: account is the zero address'
                if not stor8[address(msg.sender)]:
                    revert with 0, 'Roles: account does not have role'
                stor8[address(msg.sender)] = 0
                emit MinterRemoved(msg.sender);
            if unknown_0x9f9a4e7f(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == bool(cd[4])
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                emit SwapAndLiquifyEnabledUpdated(bool(cd[4]), msg.sender);
                stor15 = uint8(bool(cd[4]))
            require unknown_0xa0712d68(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 32
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if not msg.sender:
                revert with 0, 'BEP20: mint to the zero address'
            if stor7 > !cd[4]:
                revert with 0, 17
            if stor7 + cd[4] < stor7:
                revert with 0, 'SafeMath: addition overflow'
            if stor7 + cd[4] > 100000 * 10^18:
                revert with 0, 'Max supply reached'
            if totalSupply > !cd[4]:
                revert with 0, 17
            if totalSupply + cd[4] < totalSupply:
                revert with 0, 'SafeMath: addition overflow'
            totalSupply += cd[4]
            if stor7 > !cd[4]:
                revert with 0, 17
            if stor7 + cd[4] < stor7:
                revert with 0, 'SafeMath: addition overflow'
            stor7 += cd[4]
            if balanceOf[address(msg.sender)].field_0 > !cd[4]:
                revert with 0, 17
            if balanceOf[address(msg.sender)].field_0 + cd[4] < balanceOf[address(msg.sender)].field_0:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(msg.sender)].field_0 += cd[4]
            emit Transfer(cd[4], 0, msg.sender);
        else:
            if unknown_0xa392e674(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                emit MinAmountToLiquifyUpdated(minAmountToLiquify, cd[4], msg.sender);
                minAmountToLiquify = cd[4]
            if unknown_0xa457c2d7(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if cd[36] > allowance[msg.sender][address(cd[4])]:
                    revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[197 len 27] >> 40, 0
                if allowance[msg.sender][address(cd[4])] < cd[36]:
                    revert with 0, 17
                if not msg.sender:
                    revert with 0, 'BEP20: approve from the zero address'
                if not address(cd[4]):
                    revert with 0, 'BEP20: approve to the zero address'
                allowance[address(msg.sender)][address(cd[4])] = allowance[msg.sender][address(cd[4])] - cd[36]
                emit Approval((allowance[msg.sender][address(cd[4])] - cd[36]), msg.sender, address(cd[4]));
            else:
                if uint32(call.func_hash) >> 224 != unknown_0xa9059cbb(?????):
                    require unknown_0xa97af1f2(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if eth.balance(this.address) > cd[36]:
                        if eth.balance(this.address) < cd[36]:
                            revert with 0, 'Address: insufficient balance'
                        call address(cd[4]) with:
                           value cd[36] wei
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with 0, 'Address: unable to send value, recipient may have reverted'
                        emit 0x7d1ee786: cd[36], msg.sender, address(cd[4])
                    else:
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 'Address: insufficient balance'
                        call address(cd[4]) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with 0, 'Address: unable to send value, recipient may have reverted'
                        emit 0x7d1ee786: eth.balance(this.address), msg.sender, address(cd[4])
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if bool(stor15) != 1:
                    if not transferTaxRate:
                        if not msg.sender:
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not address(cd[4]):
                            revert with 0, 'BEP20: transfer to the zero address'
                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                            revert with 0, 17
                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[4])].field_0 += cd[36]
                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                    else:
                        if stor14[address(msg.sender)]:
                            if not msg.sender:
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not address(cd[4]):
                                revert with 0, 'BEP20: transfer to the zero address'
                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                revert with 0, 17
                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[4])].field_0 += cd[36]
                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                        else:
                            if stor14[address(cd[4])]:
                                if not msg.sender:
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])].field_0 += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if not cd[36]:
                                    if 0 > cd[36]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if cd[36] < 0:
                                        revert with 0, 17
                                    if 0 > !cd[36]:
                                        revert with 0, 17
                                    if cd[36] != cd[36]:
                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                    emit Transfer(0, msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if cd[36] and transferTaxRate > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if cd[36] * transferTaxRate / 1000 > cd[36]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if cd[36] < cd[36] * transferTaxRate / 1000:
                                        revert with 0, 17
                                    if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if cd[36] != cd[36]:
                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                    if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                    emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                    if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                    emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                else:
                    if stor17:
                        if not transferTaxRate:
                            if not msg.sender:
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not address(cd[4]):
                                revert with 0, 'BEP20: transfer to the zero address'
                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                revert with 0, 17
                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[4])].field_0 += cd[36]
                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                        else:
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])].field_0 += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if stor14[address(cd[4])]:
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if not cd[36]:
                                        if 0 > cd[36]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if cd[36] < 0:
                                            revert with 0, 17
                                        if 0 > !cd[36]:
                                            revert with 0, 17
                                        if cd[36] != cd[36]:
                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                        emit Transfer(0, msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if cd[36] and transferTaxRate > -1 / cd[36]:
                                            revert with 0, 17
                                        if not cd[36]:
                                            revert with 0, 18
                                        if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if cd[36] * transferTaxRate / 1000 > cd[36]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if cd[36] < cd[36] * transferTaxRate / 1000:
                                            revert with 0, 17
                                        if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if cd[36] != cd[36]:
                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                        if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                        emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                        if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                        emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                    else:
                        if not sub_7e2fd586Address:
                            if not transferTaxRate:
                                if not msg.sender:
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])].field_0 += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if stor14[address(cd[4])]:
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if not cd[36]:
                                            if 0 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if cd[36] < 0:
                                                revert with 0, 17
                                            if 0 > !cd[36]:
                                                revert with 0, 17
                                            if cd[36] != cd[36]:
                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                            emit Transfer(0, msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if cd[36] and transferTaxRate > -1 / cd[36]:
                                                revert with 0, 17
                                            if not cd[36]:
                                                revert with 0, 18
                                            if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if cd[36] < cd[36] * transferTaxRate / 1000:
                                                revert with 0, 17
                                            if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if cd[36] != cd[36]:
                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                            if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                            emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                            if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                            emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                        else:
                            if not sub_dd10546aAddress:
                                if not transferTaxRate:
                                    if not msg.sender:
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if stor14[address(cd[4])]:
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if not cd[36]:
                                                if 0 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if cd[36] < 0:
                                                    revert with 0, 17
                                                if 0 > !cd[36]:
                                                    revert with 0, 17
                                                if cd[36] != cd[36]:
                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                emit Transfer(0, msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if cd[36] and transferTaxRate > -1 / cd[36]:
                                                    revert with 0, 17
                                                if not cd[36]:
                                                    revert with 0, 18
                                                if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if cd[36] < cd[36] * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if cd[36] != cd[36]:
                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                            else:
                                if sub_dd10546aAddress == msg.sender:
                                    if not transferTaxRate:
                                        if not msg.sender:
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if stor14[address(cd[4])]:
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if not cd[36]:
                                                    if 0 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if cd[36] < 0:
                                                        revert with 0, 17
                                                    if 0 > !cd[36]:
                                                        revert with 0, 17
                                                    if cd[36] != cd[36]:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                    emit Transfer(0, msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if cd[36] and transferTaxRate > -1 / cd[36]:
                                                        revert with 0, 17
                                                    if not cd[36]:
                                                        revert with 0, 18
                                                    if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if cd[36] < cd[36] * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if cd[36] != cd[36]:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                    if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                    emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                    if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                    emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                                else:
                                    if owner == msg.sender:
                                        if not transferTaxRate:
                                            if not msg.sender:
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if stor14[address(cd[4])]:
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if not cd[36]:
                                                        if 0 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if cd[36] < 0:
                                                            revert with 0, 17
                                                        if 0 > !cd[36]:
                                                            revert with 0, 17
                                                        if cd[36] != cd[36]:
                                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if cd[36] and transferTaxRate > -1 / cd[36]:
                                                            revert with 0, 17
                                                        if not cd[36]:
                                                            revert with 0, 18
                                                        if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if cd[36] < cd[36] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if cd[36] != cd[36]:
                                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                        if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                        emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                        if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                        emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                                    else:
                                        if owner == address(cd[4]):
                                            if not transferTaxRate:
                                                if not msg.sender:
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if stor14[address(cd[4])]:
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if not cd[36]:
                                                            if 0 > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if cd[36] < 0:
                                                                revert with 0, 17
                                                            if 0 > !cd[36]:
                                                                revert with 0, 17
                                                            if cd[36] != cd[36]:
                                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if 0 > balanceOf[address(msg.sender)].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)].field_0 < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        else:
                                                            if cd[36] and transferTaxRate > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if cd[36] < cd[36] * transferTaxRate / 1000:
                                                                revert with 0, 17
                                                            if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                revert with 0, 17
                                                            if cd[36] != cd[36]:
                                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                            if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                            emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                            if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                            emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                                        else:
                                            stor17 = 1
                                            transferTaxRate = 0
                                            if liquidityFee > !buybackFee:
                                                revert with 0, 17
                                            if liquidityFee + buybackFee < liquidityFee:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if balanceOf[address(this.address)].field_0 < minAmountToLiquify:
                                                stor17 = 0
                                                if not transferTaxRate:
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if stor14[address(msg.sender)]:
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if stor14[address(cd[4])]:
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        else:
                                                            if not cd[36]:
                                                                if 0 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if 0 > !cd[36]:
                                                                    revert with 0, 17
                                                                if cd[36] != cd[36]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                if 0 > balanceOf[address(msg.sender)].field_0:
                                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            else:
                                                                if cd[36] and transferTaxRate > -1 / cd[36]:
                                                                    revert with 0, 17
                                                                if not cd[36]:
                                                                    revert with 0, 18
                                                                if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[36] < cd[36] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if cd[36] != cd[36]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                                if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                                emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                                if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                                emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                                            else:
                                                if not minAmountToLiquify:
                                                    if liquidityFee + buybackFee <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if not liquidityFee + buybackFee:
                                                        revert with 0, 18
                                                    mem[128] = 3
                                                    mem[160] = this.address
                                                    require ext_code.size(sub_7e2fd586Address)
                                                    staticcall sub_7e2fd586Address.WETH() with:
                                                            gas gas_remaining wei
                                                    mem[256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[192] = ext_call.return_data[12 len 20]
                                                    mem[224] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                                    if not this.address:
                                                        revert with 0, 'BEP20: approve from the zero address'
                                                    if not sub_7e2fd586Address:
                                                        revert with 0, 'BEP20: approve to the zero address'
                                                    allowance[address(this.address)][stor9] = 0 / liquidityFee + buybackFee
                                                    emit Approval((0 / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                                    if block.timestamp > -301:
                                                        revert with 0, 17
                                                    if block.timestamp + 300 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[ceil32(return_data.size) + 256] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(return_data.size) + 260] = 0 / liquidityFee + buybackFee
                                                    mem[ceil32(return_data.size) + 420] = 3
                                                    idx = 0
                                                    s = ceil32(return_data.size) + 452
                                                    t = 160
                                                    while idx < 3:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[ceil32(return_data.size) + 356] = 57005
                                                    mem[ceil32(return_data.size) + 388] = block.timestamp + 300
                                                    require ext_code.size(sub_7e2fd586Address)
                                                    call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0 / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 452 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                                        revert with 0, 17
                                                    mem[ceil32(return_data.size) + 256] = 2
                                                    mem[ceil32(return_data.size) + 288] = this.address
                                                    require ext_code.size(sub_7e2fd586Address)
                                                    staticcall sub_7e2fd586Address.WETH() with:
                                                            gas gas_remaining wei
                                                    mem[ceil32(return_data.size) + 352] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (2 * ceil32(return_data.size)) + 352
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[ceil32(return_data.size) + 320] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'BEP20: approve from the zero address'
                                                    if not sub_7e2fd586Address:
                                                        revert with 0, 'BEP20: approve to the zero address'
                                                    mem[0] = sub_7e2fd586Address
                                                    mem[32] = sha3(address(this.address), 2)
                                                    allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                                    emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                                    mem[(2 * ceil32(return_data.size)) + 352] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                                    mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_1
                                                    mem[(2 * ceil32(return_data.size)) + 388] = 0
                                                    mem[(2 * ceil32(return_data.size)) + 420] = 160
                                                    mem[(2 * ceil32(return_data.size)) + 516] = 2
                                                    idx = 0
                                                    s = (2 * ceil32(return_data.size)) + 548
                                                    t = ceil32(return_data.size) + 288
                                                    while idx < mem[ceil32(return_data.size) + 256]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(2 * ceil32(return_data.size)) + 452] = this.address
                                                    mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
                                                    require ext_code.size(sub_7e2fd586Address)
                                                    call sub_7e2fd586Address.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 2 * Mask(256, -1, balanceOf[this.address].field_1), 0, 160, address(this.address), block.timestamp, mem[(2 * ceil32(return_data.size)) + 516 len (32 * mem[ceil32(return_data.size) + 256]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        mem[(2 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(2 * ceil32(return_data.size)) + 356] = 32
                                                        mem[(2 * ceil32(return_data.size)) + 388] = 30
                                                        mem[(2 * ceil32(return_data.size)) + 420] = 'SafeMath: subtraction overflow'
                                                        revert with memory
                                                          from (2 * ceil32(return_data.size)) + 352
                                                           len ceil32(return_data.size) + 100
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        mem[(2 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(2 * ceil32(return_data.size)) + 356] = 32
                                                        mem[(2 * ceil32(return_data.size)) + 388] = 36
                                                        mem[(2 * ceil32(return_data.size)) + 420] = 'BEP20: approve from the zero add'
                                                        mem[(2 * ceil32(return_data.size)) + 452] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from (2 * ceil32(return_data.size)) + 352
                                                           len ceil32(return_data.size) + 132
                                                    if not sub_7e2fd586Address:
                                                        mem[(2 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(2 * ceil32(return_data.size)) + 356] = 32
                                                        mem[(2 * ceil32(return_data.size)) + 388] = 34
                                                        mem[(2 * ceil32(return_data.size)) + 420] = 'BEP20: approve to the zero addre'
                                                        mem[(2 * ceil32(return_data.size)) + 452] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from (2 * ceil32(return_data.size)) + 352
                                                           len ceil32(return_data.size) + 132
                                                    allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                    emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                                    mem[(2 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[(2 * ceil32(return_data.size)) + 388] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                    mem[(2 * ceil32(return_data.size)) + 420] = 0
                                                    mem[(2 * ceil32(return_data.size)) + 452] = 0
                                                    mem[(2 * ceil32(return_data.size)) + 484] = this.address
                                                    mem[(2 * ceil32(return_data.size)) + 516] = block.timestamp
                                                    require ext_code.size(sub_7e2fd586Address)
                                                    call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args mem[(2 * ceil32(return_data.size)) + 356 len ceil32(return_data.size) + 192]
                                                    mem[(2 * ceil32(return_data.size)) + 352 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    require ext_call.return_data[64] > 0
                                                    mem[(4 * ceil32(return_data.size)) + 352] = balanceOf[this.address].field_1
                                                    mem[(4 * ceil32(return_data.size)) + 384] = 0
                                                    mem[(4 * ceil32(return_data.size)) + 416] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                        mem[(4 * ceil32(return_data.size)) + 352 len (5 * ceil32(return_data.size)) + 96],
                                                    stor17 = 0
                                                    if not transferTaxRate:
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 516 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                            mem[(4 * ceil32(return_data.size)) + 554] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] >= balanceOf[address(cd[4])].field_0:
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            return 1
                                                        mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                        mem[(4 * ceil32(return_data.size)) + 484] = 27
                                                        mem[(4 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (4 * ceil32(return_data.size)) + 448
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if stor14[address(msg.sender)]:
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 516 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                            mem[(4 * ceil32(return_data.size)) + 554] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] >= balanceOf[address(cd[4])].field_0:
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            return 1
                                                        mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                        mem[(4 * ceil32(return_data.size)) + 484] = 27
                                                        mem[(4 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (4 * ceil32(return_data.size)) + 448
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if stor14[address(cd[4])]:
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 516 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                            mem[(4 * ceil32(return_data.size)) + 554] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] >= balanceOf[address(cd[4])].field_0:
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            return 1
                                                        mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                        mem[(4 * ceil32(return_data.size)) + 484] = 27
                                                        mem[(4 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (4 * ceil32(return_data.size)) + 448
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if not cd[36]:
                                                        if 0 > cd[36]:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 30
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'SafeMath: subtraction overflow'
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        if cd[36] < 0:
                                                            revert with 0, 17
                                                        if 0 > !cd[36]:
                                                            revert with 0, 17
                                                        if cd[36] != cd[36]:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 33
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'XSH:: transfer: Tax value invali'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6400000000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if 0 > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 516 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                            mem[(4 * ceil32(return_data.size)) + 554] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 27
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 544] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 580] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 612 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 518 len 26]
                                                            mem[(4 * ceil32(return_data.size)) + 650] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 544
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] >= balanceOf[address(cd[4])].field_0:
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            return 1
                                                    else:
                                                        if cd[36] and transferTaxRate > -1 / cd[36]:
                                                            revert with 0, 17
                                                        if not cd[36]:
                                                            revert with 0, 18
                                                        if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 33
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 30
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'SafeMath: subtraction overflow'
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        if cd[36] < cd[36] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if cd[36] != cd[36]:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 33
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'XSH:: transfer: Tax value invali'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6400000000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[(4 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 356] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 388] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 420] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 352
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 516 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1)
                                                            mem[(4 * ceil32(return_data.size)) + 554] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                        if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 27
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                        emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 37
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'BEP20: transfer from the zero ad'
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[(4 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 452] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 484] = 35
                                                            mem[(4 * ceil32(return_data.size)) + 516] = 'BEP20: transfer to the zero addr'
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 448
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                            mem[(4 * ceil32(return_data.size)) + 544] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[(4 * ceil32(return_data.size)) + 548] = 32
                                                            mem[(4 * ceil32(return_data.size)) + 580] = 38
                                                            mem[(4 * ceil32(return_data.size)) + 612 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 518 len 26]
                                                            mem[(4 * ceil32(return_data.size)) + 650] = 0
                                                            revert with memory
                                                              from (4 * ceil32(return_data.size)) + 544
                                                               len (5 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                        if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) >= balanceOf[address(cd[4])].field_0:
                                                            balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                            emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
                                                            return 1
                                                    mem[(4 * ceil32(return_data.size)) + 544] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(4 * ceil32(return_data.size)) + 548] = 32
                                                    mem[(4 * ceil32(return_data.size)) + 580] = 27
                                                    mem[(4 * ceil32(return_data.size)) + 612] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (4 * ceil32(return_data.size)) + 544
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if minAmountToLiquify and buybackFee > -1 / minAmountToLiquify:
                                                    revert with 0, 17
                                                if not minAmountToLiquify:
                                                    revert with 0, 18
                                                if minAmountToLiquify * buybackFee / minAmountToLiquify != buybackFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if liquidityFee + buybackFee <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not liquidityFee + buybackFee:
                                                    revert with 0, 18
                                                mem[128] = 3
                                                mem[160] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[192] = ext_call.return_data[12 len 20]
                                                mem[224] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                allowance[address(this.address)][stor9] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                                emit Approval((minAmountToLiquify * buybackFee / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                                if block.timestamp > -301:
                                                    revert with 0, 17
                                                if block.timestamp + 300 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[ceil32(return_data.size) + 256] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(return_data.size) + 260] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                                mem[ceil32(return_data.size) + 420] = 3
                                                idx = 0
                                                s = ceil32(return_data.size) + 452
                                                t = 160
                                                while idx < 3:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(return_data.size) + 356] = 57005
                                                mem[ceil32(return_data.size) + 388] = block.timestamp + 300
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args minAmountToLiquify * buybackFee / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 452 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                                    revert with 0, 17
                                                mem[ceil32(return_data.size) + 256] = 2
                                                mem[ceil32(return_data.size) + 288] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(return_data.size) + 352] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (2 * ceil32(return_data.size)) + 352
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(return_data.size) + 320] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                                emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                                mem[(2 * ceil32(return_data.size)) + 352] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_1
                                                mem[(2 * ceil32(return_data.size)) + 388] = 0
                                                mem[(2 * ceil32(return_data.size)) + 420] = 160
                                                mem[(2 * ceil32(return_data.size)) + 516] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 548
                                                t = ceil32(return_data.size) + 288
                                                while idx < mem[ceil32(return_data.size) + 256]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(2 * ceil32(return_data.size)) + 452] = this.address
                                                mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + 256]) + -mem[64] + 544]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = this.address
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, balanceOf[this.address].field_0 - balanceOf[this.address].field_1, 0, 0, this.address, block.timestamp
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _15591 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_15591 + 64] > 0
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit SwapAndLiquify(2 * Mask(256, -1, balanceOf[this.address].field_1), 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1);
                                                stor17 = 0
                                                if not transferTaxRate:
                                                    if not msg.sender:
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _15635 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_15635] = 38
                                                    mem[_15635 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15635 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                    if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])].field_0 += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    mem[0] = msg.sender
                                                    mem[32] = 14
                                                    if stor14[address(msg.sender)]:
                                                        if not msg.sender:
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        _15658 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_15658] = 38
                                                        mem[_15658 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15658 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                        if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])].field_0 += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        mem[0] = address(cd[4])
                                                        mem[32] = 14
                                                        if stor14[address(cd[4])]:
                                                            if not msg.sender:
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            _15683 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_15683] = 38
                                                            mem[_15683 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15683 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                            if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])].field_0 += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        else:
                                                            if not cd[36]:
                                                                if 0 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if 0 > !cd[36]:
                                                                    revert with 0, 17
                                                                if cd[36] != cd[36]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _15931 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_15931] = 38
                                                                mem[_15931 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15931 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16136 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16136] = 38
                                                                mem[_16136 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[36] > balanceOf[address(msg.sender)].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16136 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 -= cd[36]
                                                                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])].field_0 += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            else:
                                                                if cd[36] and transferTaxRate > -1 / cd[36]:
                                                                    revert with 0, 17
                                                                if not cd[36]:
                                                                    revert with 0, 18
                                                                if cd[36] * transferTaxRate / cd[36] != transferTaxRate:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[36] * transferTaxRate / 1000 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[36] < cd[36] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                if cd[36] * transferTaxRate / 1000 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if cd[36] != cd[36]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16043 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16043] = 38
                                                                mem[_16043 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[36] * transferTaxRate / 1000 > balanceOf[address(msg.sender)].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16043 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 -= cd[36] * transferTaxRate / 1000
                                                                if balanceOf[this.address].field_0 > !(cd[36] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[36] * transferTaxRate / 1000)
                                                                emit Transfer((cd[36] * transferTaxRate / 1000), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16193 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16193] = 38
                                                                mem[_16193 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[36] - (cd[36] * transferTaxRate / 1000) > balanceOf[address(msg.sender)].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16193 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)].field_0 < cd[36] - (cd[36] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)].field_0 = balanceOf[address(msg.sender)].field_0 - cd[36] + (cd[36] * transferTaxRate / 1000)
                                                                if balanceOf[address(cd[4])].field_0 > !(cd[36] - (cd[36] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000) < balanceOf[address(cd[4])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 + cd[36] - (cd[36] * transferTaxRate / 1000)
                                                                emit Transfer((cd[36] - (cd[36] * transferTaxRate / 1000)), msg.sender, address(cd[4]));
    else:
        if unknown_0x40c10f19(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0x5f31473d(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x715018a6(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x5f31473d(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return 0xfa9651a0ecc19906843c13c60443300b9d37355
                    if unknown_0x6fcfff45(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return numCheckpoints[cd[4]]
                    require unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return balanceOf[address(cd[4])].field_0
                if unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    emit OwnershipTransferred(owner, 0);
                    owner = 0
                if uint32(call.func_hash) >> 224 != unknown_0x782d6fe1(?????):
                    if unknown_0x7e2fd586(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_7e2fd586Address
                    require unknown_0x7ecebe00(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return nonces[cd[4]]
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if cd[36] >= block.number:
                    revert with 0, 'XSH::getPriorVotes: not yet determined'
                if not numCheckpoints[address(cd[4])]:
                    return 0
                if numCheckpoints[address(cd[4])] < 1:
                    revert with 0, 17
                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 <= cd[36]:
                    if numCheckpoints[address(cd[4])] < 1:
                        revert with 0, 17
                    return checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256
                if cd[36] < checkpoints[address(cd[4])][0].field_0:
                    return 0
                if numCheckpoints[address(cd[4])] < 1:
                    revert with 0, 17
                idx = 0
                while uint32(numCheckpoints[address(cd[4])] - 1) > uint32(idx):
                    if uint32(numCheckpoints[address(cd[4])] - 1) < uint32(idx):
                        revert with 0, 17
                    if uint32(numCheckpoints[address(cd[4])] - 1) < uint32(uint32(numCheckpoints[address(cd[4])] - 1) - uint32(idx)) / 2:
                        revert with 0, 17
                    mem[0] = uint32(uint32(numCheckpoints[address(cd[4])] - 1) - (uint32(uint32(numCheckpoints[address(cd[4])] - 1) - uint32(idx)) / 2))
                    mem[32] = sha3(address(cd[4]), 19)
                    _12359 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12359] = checkpoints[address(cd[4])][uint32(stor20[address(cd[4])] - 1) - (uint32(uint32(stor20[address(cd[4])] - 1) - uint32(idx)) / 2) << 224].field_0
                    mem[_12359 + 32] = checkpoints[address(cd[4])][uint32(stor20[address(cd[4])] - 1) - (uint32(uint32(stor20[address(cd[4])] - 1) - uint32(idx)) / 2) << 224].field_256
                    if cd[36] == checkpoints[address(cd[4])][uint32(stor20[address(cd[4])] - 1) - (uint32(uint32(stor20[address(cd[4])] - 1) - uint32(idx)) / 2) << 224].field_0:
                        return checkpoints[address(cd[4])][uint32(stor20[address(cd[4])] - 1) - (uint32(uint32(stor20[address(cd[4])] - 1) - uint32(idx)) / 2) << 224].field_256
                    if cd[36] > checkpoints[address(cd[4])][uint32(stor20[address(cd[4])] - 1) - (uint32(uint32(stor20[address(cd[4])] - 1) - uint32(idx)) / 2) << 224].field_0:
                        idx = uint32(numCheckpoints[address(cd[4])] - 1) - (uint32(uint32(numCheckpoints[address(cd[4])] - 1) - uint32(idx)) / 2)
                        continue 
                    if uint32(uint32(numCheckpoints[address(cd[4])] - 1) - (uint32(uint32(numCheckpoints[address(cd[4])] - 1) - uint32(idx)) / 2)) < 1:
                        revert with 0, 17
                    idx = idx
                    continue 
                return checkpoints[address(cd[4])][idx << 224].field_256
            if unknown_0x40c10f19(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if not msg.sender:
                    revert with 0, 'Roles: account is the zero address'
                if not stor8[address(msg.sender)]:
                    revert with 0, 'MinterRole: caller does not have the Minter role'
                if not address(cd[4]):
                    revert with 0, 'BEP20: mint to the zero address'
                if stor7 > !cd[36]:
                    revert with 0, 17
                if stor7 + cd[36] < stor7:
                    revert with 0, 'SafeMath: addition overflow'
                if stor7 + cd[36] > 100000 * 10^18:
                    revert with 0, 'Max supply reached'
                if totalSupply > !cd[36]:
                    revert with 0, 17
                if totalSupply + cd[36] < totalSupply:
                    revert with 0, 'SafeMath: addition overflow'
                totalSupply += cd[36]
                if stor7 > !cd[36]:
                    revert with 0, 17
                if stor7 + cd[36] < stor7:
                    revert with 0, 'SafeMath: addition overflow'
                stor7 += cd[36]
                if balanceOf[address(cd[4])].field_0 > !cd[36]:
                    revert with 0, 17
                if balanceOf[address(cd[4])].field_0 + cd[36] < balanceOf[address(cd[4])].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(cd[4])].field_0 += cd[36]
                emit Transfer(cd[36], 0, address(cd[4]));
                if delegates[address(cd[4])] != 0:
                    if cd[36] > 0:
                        if delegates[address(cd[4])]:
                            if not numCheckpoints[stor18[address(cd[4])]]:
                                if 0 > !cd[36]:
                                    revert with 0, 17
                                if cd[36] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                0
                                if numCheckpoints[stor18[address(cd[4])]] <= 0:
                                    checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_0 = uint32(block.number)
                                    checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_256 = cd[36]
                                    if 1 > -numCheckpoints[stor18[address(cd[4])]] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[stor18[address(cd[4])]] = uint32(numCheckpoints[stor18[address(cd[4])]] + 1)
                                else:
                                    if numCheckpoints[stor18[address(cd[4])]] < 1:
                                        revert with 0, 17
                                    if checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[stor18[address(cd[4])]] < 1:
                                            revert with 0, 17
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 = cd[36]
                                    else:
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_0 = uint32(block.number)
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_256 = cd[36]
                                        if 1 > -numCheckpoints[stor18[address(cd[4])]] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[stor18[address(cd[4])]] = uint32(numCheckpoints[stor18[address(cd[4])]] + 1)
                                emit DelegateVotesChanged(0, cd[36], delegates[address(cd[4])]);
                            else:
                                if numCheckpoints[stor18[address(cd[4])]] < 1:
                                    revert with 0, 17
                                if checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 > !cd[36]:
                                    revert with 0, 17
                                if checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 + cd[36] < checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                0
                                if numCheckpoints[stor18[address(cd[4])]] <= 0:
                                    checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_0 = uint32(block.number)
                                    checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_256 = checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 + cd[36]
                                    if 1 > -numCheckpoints[stor18[address(cd[4])]] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[stor18[address(cd[4])]] = uint32(numCheckpoints[stor18[address(cd[4])]] + 1)
                                else:
                                    if numCheckpoints[stor18[address(cd[4])]] < 1:
                                        revert with 0, 17
                                    if checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[stor18[address(cd[4])]] < 1:
                                            revert with 0, 17
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 += cd[36]
                                    else:
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_0 = uint32(block.number)
                                        checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]]].field_256 = checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 + cd[36]
                                        if 1 > -numCheckpoints[stor18[address(cd[4])]] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[stor18[address(cd[4])]] = uint32(numCheckpoints[stor18[address(cd[4])]] + 1)
                                emit DelegateVotesChanged(checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256, checkpoints[stor18[address(cd[4])]][stor20[stor18[address(cd[4])]] - 1 << 224].field_256 + cd[36], delegates[address(cd[4])]);
            else:
                if unknown_0x42966c68(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if not msg.sender:
                        revert with 0, 'BEP20: burn from the zero address'
                    if cd[4] > balanceOf[address(msg.sender)].field_0:
                        revert with 0, 32, 34, 0x6f42455032303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[194 len 30] >> 16, 0
                    if balanceOf[address(msg.sender)].field_0 < cd[4]:
                        revert with 0, 17
                    balanceOf[address(msg.sender)].field_0 -= cd[4]
                    if cd[4] > stor7:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if stor7 < cd[4]:
                        revert with 0, 17
                    stor7 -= cd[4]
                    if cd[4] > totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalSupply < cd[4]:
                        revert with 0, 17
                    totalSupply -= cd[4]
                    emit Transfer(cd[4], msg.sender, 0);
                    return 1
                if unknown_0x4a74bb02(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return bool(stor15)
                if unknown_0x4fbee193(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return bool(stor14[address(cd[4])])
                if unknown_0x587cde1e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return delegates[address(cd[4])]
                require unknown_0x5c19a95c(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                delegates[address(msg.sender)] = address(cd[4])
                emit DelegateChanged(msg.sender, delegates[address(msg.sender)], address(cd[4]));
                if delegates[address(msg.sender)] != address(cd[4]):
                    if balanceOf[address(msg.sender)].field_0 > 0:
                        if not delegates[address(msg.sender)]:
                            if address(cd[4]):
                                if not numCheckpoints[address(cd[4])]:
                                    if 0 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)].field_0 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(cd[4])] <= 0:
                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                    else:
                                        if numCheckpoints[address(cd[4])] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                    emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                else:
                                    if numCheckpoints[address(cd[4])] < 1:
                                        revert with 0, 17
                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                        revert with 0, 17
                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if block.number >= 4294967296:
                                        revert with 0, 
                                                    32,
                                                    51,
                                                    0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                    0
                                    if numCheckpoints[address(cd[4])] <= 0:
                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                    else:
                                        if numCheckpoints[address(cd[4])] < 1:
                                            revert with 0, 17
                                        if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                        else:
                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                            checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                            if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                revert with 0, 17
                                            numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                    emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                        else:
                            if not numCheckpoints[stor18[address(msg.sender)]]:
                                if balanceOf[address(msg.sender)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 < balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                0
                                if numCheckpoints[stor18[address(msg.sender)]] <= 0:
                                    checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                                    checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = -balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                                    emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                    if address(cd[4]):
                                        if not numCheckpoints[address(cd[4])]:
                                            if 0 > !balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 17
                                            if balanceOf[address(msg.sender)].field_0 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                else:
                                    if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                        revert with 0, 17
                                    if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                            revert with 0, 17
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 = -balanceOf[address(msg.sender)].field_0
                                        emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                        if address(cd[4]):
                                            if not numCheckpoints[address(cd[4])]:
                                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[307 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[307 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                    else:
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = -balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                                        emit DelegateVotesChanged(0, -balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                        if address(cd[4]):
                                            if not numCheckpoints[address(cd[4])]:
                                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                            else:
                                if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                    revert with 0, 17
                                if balanceOf[address(msg.sender)].field_0 > checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 < balanceOf[address(msg.sender)].field_0:
                                    revert with 0, 17
                                if block.number >= 4294967296:
                                    revert with 0, 
                                                32,
                                                51,
                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[211 len 13] >> 152,
                                                0
                                if numCheckpoints[stor18[address(msg.sender)]] <= 0:
                                    checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                                    checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0
                                    if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                        revert with 0, 17
                                    numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                                    emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                    if address(cd[4]):
                                        if not numCheckpoints[address(cd[4])]:
                                            if 0 > !balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 17
                                            if balanceOf[address(msg.sender)].field_0 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                        else:
                                            if numCheckpoints[address(cd[4])] < 1:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                revert with 0, 17
                                            if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if block.number >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            51,
                                                            0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                            0
                                            if numCheckpoints[address(cd[4])] <= 0:
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                    revert with 0, 17
                                                numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                else:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                            emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                else:
                                    if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                        revert with 0, 17
                                    if checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_0 == uint32(block.number):
                                        if numCheckpoints[stor18[address(msg.sender)]] < 1:
                                            revert with 0, 17
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 -= balanceOf[address(msg.sender)].field_0
                                        emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                        if address(cd[4]):
                                            if not numCheckpoints[address(cd[4])]:
                                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[307 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[307 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                    else:
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_0 = uint32(block.number)
                                        checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]]].field_256 = checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0
                                        if 1 > -numCheckpoints[stor18[address(msg.sender)]] + test266151307():
                                            revert with 0, 17
                                        numCheckpoints[stor18[address(msg.sender)]] = uint32(numCheckpoints[stor18[address(msg.sender)]] + 1)
                                        emit DelegateVotesChanged(checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256, checkpoints[stor18[address(msg.sender)]][stor20[stor18[address(msg.sender)]] - 1 << 224].field_256 - balanceOf[address(msg.sender)].field_0, delegates[address(msg.sender)]);
                                        if address(cd[4]):
                                            if not numCheckpoints[address(cd[4])]:
                                                if 0 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if balanceOf[address(msg.sender)].field_0 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 = balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(0, balanceOf[address(msg.sender)].field_0, address(cd[4]));
                                            else:
                                                if numCheckpoints[address(cd[4])] < 1:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 > !balanceOf[address(msg.sender)].field_0:
                                                    revert with 0, 17
                                                if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0 < checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if block.number >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                51,
                                                                0x655853483a3a5f7772697465436865636b706f696e743a20626c6f636b206e756d626572206578636565647320333220626974, mem[371 len 13] >> 152,
                                                                0
                                                if numCheckpoints[address(cd[4])] <= 0:
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                    checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                    if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                        revert with 0, 17
                                                    numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                else:
                                                    if numCheckpoints[address(cd[4])] < 1:
                                                        revert with 0, 17
                                                    if checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_0 == uint32(block.number):
                                                        if numCheckpoints[address(cd[4])] < 1:
                                                            revert with 0, 17
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 += balanceOf[address(msg.sender)].field_0
                                                    else:
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_0 = uint32(block.number)
                                                        checkpoints[address(cd[4])][stor20[address(cd[4])]].field_256 = checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0
                                                        if 1 > -numCheckpoints[address(cd[4])] + test266151307():
                                                            revert with 0, 17
                                                        numCheckpoints[address(cd[4])] = uint32(numCheckpoints[address(cd[4])] + 1)
                                                emit DelegateVotesChanged(checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256, checkpoints[address(cd[4])][stor20[address(cd[4])] - 1 << 224].field_256 + balanceOf[address(msg.sender)].field_0, address(cd[4]));
        if unknown_0x20606b70(?????) > uint32(call.func_hash) >> 224:
            if name() == uint32(call.func_hash) >> 224:
                require not msg.value
                if bool(stor4.length):
                    if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor4.length):
                        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor4.length):
                            if 31 < uint255(stor4.length) * 0.5:
                                mem[160] = uint256(stor4.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor4.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor4[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                            mem[160] = 256 * stor4.length.field_8
                    else:
                        if bool(stor4.length) == stor4.length.field_1 < 32:
                            revert with 0, 34
                        if stor4.length.field_1:
                            if 31 < stor4.length.field_1:
                                mem[160] = uint256(stor4.field_0)
                                idx = 160
                                s = 0
                                while stor4.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor4[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                            mem[160] = 256 * stor4.length.field_8
                    mem[ceil32(uint255(stor4.length) * 0.5) + 224 len ceil32(uint255(stor4.length) * 0.5)] = mem[160 len ceil32(uint255(stor4.length) * 0.5)]
                    if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
                        mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 224] = 0
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
                if bool(stor4.length) == stor4.length.field_1 < 32:
                    revert with 0, 34
                if bool(stor4.length):
                    if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor4.length):
                        if 31 < uint255(stor4.length) * 0.5:
                            mem[160] = uint256(stor4.field_0)
                            idx = 160
                            s = 0
                            while (uint255(stor4.length) * 0.5) + 128 > idx:
                                mem[idx + 32] = stor4[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                        mem[160] = 256 * stor4.length.field_8
                else:
                    if bool(stor4.length) == stor4.length.field_1 < 32:
                        revert with 0, 34
                    if stor4.length.field_1:
                        if 31 < stor4.length.field_1:
                            mem[160] = uint256(stor4.field_0)
                            idx = 160
                            s = 0
                            while stor4.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor4[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                        mem[160] = 256 * stor4.length.field_8
                mem[ceil32(stor4.length.field_1) + 224 len ceil32(stor4.length.field_1)] = mem[160 len ceil32(stor4.length.field_1)]
                if ceil32(stor4.length.field_1) > stor4.length.field_1:
                    mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 224] = 0
                return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 224 len 2 * ceil32(stor4.length.field_1)]), 
            if approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if not msg.sender:
                    revert with 0, 'BEP20: approve from the zero address'
                if not address(cd[4]):
                    revert with 0, 'BEP20: approve to the zero address'
                allowance[address(msg.sender)][address(cd[4])] = cd[36]
                emit Approval(cd[36], msg.sender, address(cd[4]));
                return 1
            if setFees(uint256 arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                liquidityFee = cd[4]
                buybackFee = cd[36]
                if cd[4] > !cd[36]:
                    revert with 0, 17
                if cd[4] + cd[36] < cd[4]:
                    revert with 0, 'SafeMath: addition overflow'
                transferTaxRate = cd[4] + cd[36]
                if 100 < cd[4] + cd[36]:
                    revert with 0, 'XSH: Total fees can not be bigger than max value'
            else:
                if uint32(call.func_hash) >> 224 != unknown_0x13cf87ed(?????):
                    if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return totalSupply
                    require unknown_0x1ad9339a(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    return 100
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                sub_7e2fd586Address = address(cd[4])
                require ext_code.size(address(cd[4]))
                staticcall address(cd[4]).factory() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(sub_7e2fd586Address)
                staticcall sub_7e2fd586Address.WETH() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                        gas gas_remaining wei
                       args address(this.address), address(ext_call.return_data[0])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                sub_dd10546aAddress = ext_call.return_data[12 len 20]
                if not ext_call.return_data[12 len 20]:
                    revert with 0, 'XSH::updateXHASHSwapRouter: Invalid pair address.'
                emit 0x719e7f6c: address(cd[4]), sub_7e2fd586Address, sub_dd10546aAddress
        if unknown_0x20606b70(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866
        if uint32(call.func_hash) >> 224 != unknown_0x23b872dd(?????):
            if unknown_0x3092afd5(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if not msg.sender:
                    revert with 0, 'Roles: account is the zero address'
                if not stor8[address(msg.sender)]:
                    revert with 0, 'MinterRole: caller does not have the Minter role'
                if not address(cd[4]):
                    revert with 0, 'Roles: account is the zero address'
                if not stor8[address(cd[4])]:
                    revert with 0, 'Roles: account does not have role'
                stor8[address(cd[4])] = 0
                emit MinterRemoved(address(cd[4]));
            if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return decimals
            if uint32(call.func_hash) >> 224 != unknown_0x39509351(?????):
                require unknown_0x3b2d081c(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                return buybackFee
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if allowance[msg.sender][address(cd[4])] > !cd[36]:
                revert with 0, 17
            if allowance[msg.sender][address(cd[4])] + cd[36] < allowance[msg.sender][address(cd[4])]:
                revert with 0, 'SafeMath: addition overflow'
            if not msg.sender:
                revert with 0, 'BEP20: approve from the zero address'
            if not address(cd[4]):
                revert with 0, 'BEP20: approve to the zero address'
            allowance[address(msg.sender)][address(cd[4])] = allowance[msg.sender][address(cd[4])] + cd[36]
            emit Approval((allowance[msg.sender][address(cd[4])] + cd[36]), msg.sender, address(cd[4]));
        else:
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] == address(cd[4])
            require cd[36] == address(cd[36])
            if bool(stor15) != 1:
                if not transferTaxRate:
                    if not address(cd[4]):
                        revert with 0, 'BEP20: transfer from the zero address'
                    if not address(cd[36]):
                        revert with 0, 'BEP20: transfer to the zero address'
                    if cd[68] > balanceOf[address(cd[4])].field_0:
                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                        revert with 0, 17
                    balanceOf[address(cd[4])].field_0 -= cd[68]
                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                        revert with 0, 17
                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(cd[36])].field_0 += cd[68]
                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                else:
                    if stor14[address(cd[4])]:
                        if not address(cd[4]):
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not address(cd[36]):
                            revert with 0, 'BEP20: transfer to the zero address'
                        if cd[68] > balanceOf[address(cd[4])].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                            revert with 0, 17
                        balanceOf[address(cd[4])].field_0 -= cd[68]
                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                            revert with 0, 17
                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[36])].field_0 += cd[68]
                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                    else:
                        if stor14[address(cd[36])]:
                            if not address(cd[4]):
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'BEP20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])].field_0 -= cd[68]
                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])].field_0 += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                        else:
                            if not cd[68]:
                                if 0 > cd[68]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if cd[68] < 0:
                                    revert with 0, 17
                                if 0 > !cd[68]:
                                    revert with 0, 17
                                if cd[68] != cd[68]:
                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if 0 > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < 0:
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 > -1:
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                emit Transfer(0, address(cd[4]), this.address);
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])].field_0 += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            else:
                                if cd[68] and transferTaxRate > -1 / cd[68]:
                                    revert with 0, 17
                                if not cd[68]:
                                    revert with 0, 18
                                if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if cd[68] * transferTaxRate / 1000 > cd[68]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if cd[68] < cd[68] * transferTaxRate / 1000:
                                    revert with 0, 17
                                if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                    revert with 0, 17
                                if cd[68] != cd[68]:
                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                    revert with 0, 17
                                if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                    revert with 0, 17
                                if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
            else:
                if stor17:
                    if not transferTaxRate:
                        if not address(cd[4]):
                            revert with 0, 'BEP20: transfer from the zero address'
                        if not address(cd[36]):
                            revert with 0, 'BEP20: transfer to the zero address'
                        if cd[68] > balanceOf[address(cd[4])].field_0:
                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                            revert with 0, 17
                        balanceOf[address(cd[4])].field_0 -= cd[68]
                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                            revert with 0, 17
                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[36])].field_0 += cd[68]
                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                    else:
                        if stor14[address(cd[4])]:
                            if not address(cd[4]):
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'BEP20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])].field_0 -= cd[68]
                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])].field_0 += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                        else:
                            if stor14[address(cd[36])]:
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])].field_0 += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                if not cd[68]:
                                    if 0 > cd[68]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if cd[68] < 0:
                                        revert with 0, 17
                                    if 0 > !cd[68]:
                                        revert with 0, 17
                                    if cd[68] != cd[68]:
                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if 0 > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                    emit Transfer(0, address(cd[4]), this.address);
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                else:
                                    if cd[68] and transferTaxRate > -1 / cd[68]:
                                        revert with 0, 17
                                    if not cd[68]:
                                        revert with 0, 18
                                    if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if cd[68] * transferTaxRate / 1000 > cd[68]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if cd[68] < cd[68] * transferTaxRate / 1000:
                                        revert with 0, 17
                                    if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if cd[68] != cd[68]:
                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                    if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                        revert with 0, 17
                                    if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                    emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                    if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                    emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                else:
                    if not sub_7e2fd586Address:
                        if not transferTaxRate:
                            if not address(cd[4]):
                                revert with 0, 'BEP20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'BEP20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])].field_0 -= cd[68]
                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])].field_0 += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                        else:
                            if stor14[address(cd[4])]:
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])].field_0 += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                if stor14[address(cd[36])]:
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    if not cd[68]:
                                        if 0 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if cd[68] < 0:
                                            revert with 0, 17
                                        if 0 > !cd[68]:
                                            revert with 0, 17
                                        if cd[68] != cd[68]:
                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if 0 > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                        emit Transfer(0, address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    else:
                                        if cd[68] and transferTaxRate > -1 / cd[68]:
                                            revert with 0, 17
                                        if not cd[68]:
                                            revert with 0, 18
                                        if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if cd[68] * transferTaxRate / 1000 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if cd[68] < cd[68] * transferTaxRate / 1000:
                                            revert with 0, 17
                                        if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if cd[68] != cd[68]:
                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                        if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                            revert with 0, 17
                                        if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                        emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                        if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                        emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                    else:
                        if not sub_dd10546aAddress:
                            if not transferTaxRate:
                                if not address(cd[4]):
                                    revert with 0, 'BEP20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'BEP20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])].field_0 += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                if stor14[address(cd[4])]:
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    if stor14[address(cd[36])]:
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        if not cd[68]:
                                            if 0 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if cd[68] < 0:
                                                revert with 0, 17
                                            if 0 > !cd[68]:
                                                revert with 0, 17
                                            if cd[68] != cd[68]:
                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if 0 > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                            emit Transfer(0, address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        else:
                                            if cd[68] and transferTaxRate > -1 / cd[68]:
                                                revert with 0, 17
                                            if not cd[68]:
                                                revert with 0, 18
                                            if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if cd[68] < cd[68] * transferTaxRate / 1000:
                                                revert with 0, 17
                                            if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if cd[68] != cd[68]:
                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                            if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                revert with 0, 17
                                            if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                            emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                            if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                            emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                        else:
                            if sub_dd10546aAddress == address(cd[4]):
                                if not transferTaxRate:
                                    if not address(cd[4]):
                                        revert with 0, 'BEP20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'BEP20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    if stor14[address(cd[4])]:
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        if stor14[address(cd[36])]:
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                        else:
                                            if not cd[68]:
                                                if 0 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if cd[68] < 0:
                                                    revert with 0, 17
                                                if 0 > !cd[68]:
                                                    revert with 0, 17
                                                if cd[68] != cd[68]:
                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if 0 > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                emit Transfer(0, address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            else:
                                                if cd[68] and transferTaxRate > -1 / cd[68]:
                                                    revert with 0, 17
                                                if not cd[68]:
                                                    revert with 0, 18
                                                if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if cd[68] < cd[68] * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if cd[68] != cd[68]:
                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                            else:
                                if owner == address(cd[4]):
                                    if not transferTaxRate:
                                        if not address(cd[4]):
                                            revert with 0, 'BEP20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'BEP20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        if stor14[address(cd[4])]:
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                        else:
                                            if stor14[address(cd[36])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                            else:
                                                if not cd[68]:
                                                    if 0 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if cd[68] < 0:
                                                        revert with 0, 17
                                                    if 0 > !cd[68]:
                                                        revert with 0, 17
                                                    if cd[68] != cd[68]:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if 0 > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                    emit Transfer(0, address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                else:
                                                    if cd[68] and transferTaxRate > -1 / cd[68]:
                                                        revert with 0, 17
                                                    if not cd[68]:
                                                        revert with 0, 18
                                                    if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if cd[68] < cd[68] * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if cd[68] != cd[68]:
                                                        revert with 0, 'XSH:: transfer: Tax value invalid'
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                    if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                    emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                    if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                    emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                                else:
                                    if owner == address(cd[36]):
                                        if not transferTaxRate:
                                            if not address(cd[4]):
                                                revert with 0, 'BEP20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'BEP20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                        else:
                                            if stor14[address(cd[4])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                            else:
                                                if stor14[address(cd[36])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                                else:
                                                    if not cd[68]:
                                                        if 0 > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if cd[68] < 0:
                                                            revert with 0, 17
                                                        if 0 > !cd[68]:
                                                            revert with 0, 17
                                                        if cd[68] != cd[68]:
                                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if 0 > balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])].field_0 < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                        emit Transfer(0, address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    else:
                                                        if cd[68] and transferTaxRate > -1 / cd[68]:
                                                            revert with 0, 17
                                                        if not cd[68]:
                                                            revert with 0, 18
                                                        if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if cd[68] < cd[68] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if cd[68] != cd[68]:
                                                            revert with 0, 'XSH:: transfer: Tax value invalid'
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                        if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                        emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                        if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                        emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                                    else:
                                        stor17 = 1
                                        transferTaxRate = 0
                                        if liquidityFee > !buybackFee:
                                            revert with 0, 17
                                        if liquidityFee + buybackFee < liquidityFee:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if balanceOf[address(this.address)].field_0 < minAmountToLiquify:
                                            stor17 = 0
                                            if not transferTaxRate:
                                                if not address(cd[4]):
                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                    revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                    revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                            else:
                                                if stor14[address(cd[4])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                                        revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                        revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                                else:
                                                    if stor14[address(cd[36])]:
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                                            revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                                    else:
                                                        if not cd[68]:
                                                            if 0 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if cd[68] < 0:
                                                                revert with 0, 17
                                                            if 0 > !cd[68]:
                                                                revert with 0, 17
                                                            if cd[68] != cd[68]:
                                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if 0 > balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                            if balanceOf[address(cd[4])].field_0 < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                            emit Transfer(0, address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        else:
                                                            if cd[68] and transferTaxRate > -1 / cd[68]:
                                                                revert with 0, 17
                                                            if not cd[68]:
                                                                revert with 0, 18
                                                            if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            if cd[68] < cd[68] * transferTaxRate / 1000:
                                                                revert with 0, 17
                                                            if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                revert with 0, 17
                                                            if cd[68] != cd[68]:
                                                                revert with 0, 'XSH:: transfer: Tax value invalid'
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                            if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                            if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                                revert with 0, 17
                                                            if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                            emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                                revert with 0, 32, 38, 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                            if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                            if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                            emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                            revert with 0, 32, 40, 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[392 len 24] >> 64, 0
                                        else:
                                            if not minAmountToLiquify:
                                                if liquidityFee + buybackFee <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not liquidityFee + buybackFee:
                                                    revert with 0, 18
                                                mem[128] = 3
                                                mem[160] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[192] = ext_call.return_data[12 len 20]
                                                mem[224] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                allowance[address(this.address)][stor9] = 0 / liquidityFee + buybackFee
                                                emit Approval((0 / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                                if block.timestamp > -301:
                                                    revert with 0, 17
                                                if block.timestamp + 300 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[ceil32(return_data.size) + 256] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(return_data.size) + 260] = 0 / liquidityFee + buybackFee
                                                mem[ceil32(return_data.size) + 420] = 3
                                                idx = 0
                                                s = ceil32(return_data.size) + 452
                                                t = 160
                                                while idx < 3:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(return_data.size) + 356] = 57005
                                                mem[ceil32(return_data.size) + 388] = block.timestamp + 300
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args 0 / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 452 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                                    revert with 0, 17
                                                mem[ceil32(return_data.size) + 256] = 2
                                                mem[ceil32(return_data.size) + 288] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(return_data.size) + 352] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (2 * ceil32(return_data.size)) + 352
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(return_data.size) + 320] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                                emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                                mem[(2 * ceil32(return_data.size)) + 352] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_1
                                                mem[(2 * ceil32(return_data.size)) + 388] = 0
                                                mem[(2 * ceil32(return_data.size)) + 420] = 160
                                                mem[(2 * ceil32(return_data.size)) + 516] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 548
                                                t = ceil32(return_data.size) + 288
                                                while idx < mem[ceil32(return_data.size) + 256]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(2 * ceil32(return_data.size)) + 452] = this.address
                                                mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + 256]) + -mem[64] + 544]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = this.address
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, balanceOf[this.address].field_0 - balanceOf[this.address].field_1, 0, 0, this.address, block.timestamp
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _15590 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_15590 + 64] > 0
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit SwapAndLiquify(2 * Mask(256, -1, balanceOf[this.address].field_1), 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1);
                                                stor17 = 0
                                                if not transferTaxRate:
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _15630 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_15630] = 38
                                                    mem[_15630 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15630 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 1
                                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    _15853 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_15853] = 40
                                                    mem[_15853 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 40
                                                        mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15853 + 72 len 24]
                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    mem[0] = address(cd[4])
                                                    mem[32] = 14
                                                    if stor14[address(cd[4])]:
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        _15652 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_15652] = 38
                                                        mem[_15652 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15652 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 1
                                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        _15862 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_15862] = 40
                                                        mem[_15862 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 40
                                                            mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15862 + 72 len 24]
                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 14
                                                        if stor14[address(cd[36])]:
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            _15677 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_15677] = 38
                                                            mem[_15677 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15677 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 1
                                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            _15872 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_15872] = 40
                                                            mem[_15872 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15872 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not cd[68]:
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if 0 > !cd[68]:
                                                                    revert with 0, 17
                                                                if cd[68] != cd[68]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _15926 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_15926] = 38
                                                                mem[_15926 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15926 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16131 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16131] = 38
                                                                mem[_16131 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16131 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 1
                                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                _16268 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16268] = 40
                                                                mem[_16268 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_16268 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if cd[68] and transferTaxRate > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[68] < cd[68] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if cd[68] != cd[68]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16037 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16037] = 38
                                                                mem[_16037 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16037 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                                if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                                emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16187 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16187] = 38
                                                                mem[_16187 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16187 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                                if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 1
                                                                balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                                emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                                                _16304 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16304] = 40
                                                                mem[_16304 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_16304 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                if minAmountToLiquify and buybackFee > -1 / minAmountToLiquify:
                                                    revert with 0, 17
                                                if not minAmountToLiquify:
                                                    revert with 0, 18
                                                if minAmountToLiquify * buybackFee / minAmountToLiquify != buybackFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if liquidityFee + buybackFee <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not liquidityFee + buybackFee:
                                                    revert with 0, 18
                                                mem[128] = 3
                                                mem[160] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[192] = ext_call.return_data[12 len 20]
                                                mem[224] = 0xfa9651a0ecc19906843c13c60443300b9d37355
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                allowance[address(this.address)][stor9] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                                emit Approval((minAmountToLiquify * buybackFee / liquidityFee + buybackFee), this.address, sub_7e2fd586Address);
                                                if block.timestamp > -301:
                                                    revert with 0, 17
                                                if block.timestamp + 300 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[ceil32(return_data.size) + 256] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(return_data.size) + 260] = minAmountToLiquify * buybackFee / liquidityFee + buybackFee
                                                mem[ceil32(return_data.size) + 420] = 3
                                                idx = 0
                                                s = ceil32(return_data.size) + 452
                                                t = 160
                                                while idx < 3:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(return_data.size) + 356] = 57005
                                                mem[ceil32(return_data.size) + 388] = block.timestamp + 300
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args minAmountToLiquify * buybackFee / liquidityFee + buybackFee, 0, 160, 57005, block.timestamp + 300, 3, mem[ceil32(return_data.size) + 452 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if balanceOf[this.address].field_1 > balanceOf[this.address].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_1:
                                                    revert with 0, 17
                                                mem[ceil32(return_data.size) + 256] = 2
                                                mem[ceil32(return_data.size) + 288] = this.address
                                                require ext_code.size(sub_7e2fd586Address)
                                                staticcall sub_7e2fd586Address.WETH() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(return_data.size) + 352] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (2 * ceil32(return_data.size)) + 352
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(return_data.size) + 320] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_1
                                                emit Approval(balanceOf[this.address].field_1, this.address, sub_7e2fd586Address);
                                                mem[(2 * ceil32(return_data.size)) + 352] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 356] = balanceOf[this.address].field_1
                                                mem[(2 * ceil32(return_data.size)) + 388] = 0
                                                mem[(2 * ceil32(return_data.size)) + 420] = 160
                                                mem[(2 * ceil32(return_data.size)) + 516] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 548
                                                t = ceil32(return_data.size) + 288
                                                while idx < mem[ceil32(return_data.size) + 256]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(2 * ceil32(return_data.size)) + 452] = this.address
                                                mem[(2 * ceil32(return_data.size)) + 484] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + 256]) + -mem[64] + 544]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'BEP20: approve from the zero address'
                                                if not sub_7e2fd586Address:
                                                    revert with 0, 'BEP20: approve to the zero address'
                                                mem[0] = sub_7e2fd586Address
                                                mem[32] = sha3(address(this.address), 2)
                                                allowance[address(this.address)][stor9] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit Approval((balanceOf[this.address].field_0 - balanceOf[this.address].field_1), this.address, sub_7e2fd586Address);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = this.address
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(sub_7e2fd586Address)
                                                call sub_7e2fd586Address.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, balanceOf[this.address].field_0 - balanceOf[this.address].field_1, 0, 0, this.address, block.timestamp
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _15589 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_15589 + 64] > 0
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = balanceOf[this.address].field_0 - balanceOf[this.address].field_1
                                                emit SwapAndLiquify(2 * Mask(256, -1, balanceOf[this.address].field_1), 0, balanceOf[this.address].field_0 - balanceOf[this.address].field_1);
                                                stor17 = 0
                                                if not transferTaxRate:
                                                    if not address(cd[4]):
                                                        revert with 0, 'BEP20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'BEP20: transfer to the zero address'
                                                    _15625 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_15625] = 38
                                                    mem[_15625 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])].field_0:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15625 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])].field_0 -= cd[68]
                                                    if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 1
                                                    balanceOf[address(cd[36])].field_0 += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    _15849 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_15849] = 40
                                                    mem[_15849 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                    if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 40
                                                        mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15849 + 72 len 24]
                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    mem[0] = address(cd[4])
                                                    mem[32] = 14
                                                    if stor14[address(cd[4])]:
                                                        if not address(cd[4]):
                                                            revert with 0, 'BEP20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'BEP20: transfer to the zero address'
                                                        _15646 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_15646] = 38
                                                        mem[_15646 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])].field_0:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15646 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])].field_0 -= cd[68]
                                                        if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 1
                                                        balanceOf[address(cd[36])].field_0 += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        _15859 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_15859] = 40
                                                        mem[_15859 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                        if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 40
                                                            mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15859 + 72 len 24]
                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 14
                                                        if stor14[address(cd[36])]:
                                                            if not address(cd[4]):
                                                                revert with 0, 'BEP20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'BEP20: transfer to the zero address'
                                                            _15671 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_15671] = 38
                                                            mem[_15671 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if cd[68] > balanceOf[address(cd[4])].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15671 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])].field_0 -= cd[68]
                                                            if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 1
                                                            balanceOf[address(cd[36])].field_0 += cd[68]
                                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            _15867 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_15867] = 40
                                                            mem[_15867 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_15867 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not cd[68]:
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if 0 > !cd[68]:
                                                                    revert with 0, 17
                                                                if cd[68] != cd[68]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _15920 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_15920] = 38
                                                                mem[_15920 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_15920 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16126 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16126] = 38
                                                                mem[_16126 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16126 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 -= cd[68]
                                                                if balanceOf[address(cd[36])].field_0 > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])].field_0 + cd[68] < balanceOf[address(cd[36])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 1
                                                                balanceOf[address(cd[36])].field_0 += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                _16265 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16265] = 40
                                                                mem[_16265 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_16265 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if cd[68] and transferTaxRate > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] * transferTaxRate / cd[68] != transferTaxRate:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[68] * transferTaxRate / 1000 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                                if cd[68] < cd[68] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                if cd[68] * transferTaxRate / 1000 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if cd[68] != cd[68]:
                                                                    revert with 0, 'XSH:: transfer: Tax value invalid'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16029 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16029] = 38
                                                                mem[_16029 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * transferTaxRate / 1000 > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16029 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68] * transferTaxRate / 1000:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 -= cd[68] * transferTaxRate / 1000
                                                                if balanceOf[this.address].field_0 > !(cd[68] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000) < balanceOf[this.address].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 1
                                                                balanceOf[address(this.address)].field_0 = balanceOf[this.address].field_0 + (cd[68] * transferTaxRate / 1000)
                                                                emit Transfer((cd[68] * transferTaxRate / 1000), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'BEP20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'BEP20: transfer to the zero address'
                                                                _16181 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16181] = 38
                                                                mem[_16181 + 32 len 38] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * transferTaxRate / 1000) > balanceOf[address(cd[4])].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0x7342455032303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16181 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])].field_0 < cd[68] - (cd[68] * transferTaxRate / 1000):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])].field_0 = balanceOf[address(cd[4])].field_0 - cd[68] + (cd[68] * transferTaxRate / 1000)
                                                                if balanceOf[address(cd[36])].field_0 > !(cd[68] - (cd[68] * transferTaxRate / 1000)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000) < balanceOf[address(cd[36])].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 1
                                                                balanceOf[address(cd[36])].field_0 = balanceOf[address(cd[36])].field_0 + cd[68] - (cd[68] * transferTaxRate / 1000)
                                                                emit Transfer((cd[68] - (cd[68] * transferTaxRate / 1000)), address(cd[4]), address(cd[36]));
                                                                _16301 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_16301] = 40
                                                                mem[_16301 + 32 len 40] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0xfe42455032303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_16301 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            ('le', ('cd', 68), ('stor', ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('cd', 4)), ('name', 'allowance', 2)))))
            if allowance[address(cd[4])][msg.sender] < cd[68]:
                revert with 0, 17
            if not address(cd[4]):
                revert with 0, 'BEP20: approve from the zero address'
            if not msg.sender:
                revert with 0, 'BEP20: approve to the zero address'
            allowance[address(cd[4])][address(msg.sender)] = allowance[address(cd[4])][msg.sender] - cd[68]
            emit Approval((allowance[address(cd[4])][msg.sender] - cd[68]), address(cd[4]), msg.sender);
    return 1
}



}
